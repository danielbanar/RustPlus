// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rustplus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rustplus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rustplus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rustplus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rustplus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[56]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rustplus_2eproto;
namespace rustplus {
class AppBroadcast;
struct AppBroadcastDefaultTypeInternal;
extern AppBroadcastDefaultTypeInternal _AppBroadcast_default_instance_;
class AppCameraInfo;
struct AppCameraInfoDefaultTypeInternal;
extern AppCameraInfoDefaultTypeInternal _AppCameraInfo_default_instance_;
class AppCameraInput;
struct AppCameraInputDefaultTypeInternal;
extern AppCameraInputDefaultTypeInternal _AppCameraInput_default_instance_;
class AppCameraRays;
struct AppCameraRaysDefaultTypeInternal;
extern AppCameraRaysDefaultTypeInternal _AppCameraRays_default_instance_;
class AppCameraRays_Entity;
struct AppCameraRays_EntityDefaultTypeInternal;
extern AppCameraRays_EntityDefaultTypeInternal _AppCameraRays_Entity_default_instance_;
class AppCameraSubscribe;
struct AppCameraSubscribeDefaultTypeInternal;
extern AppCameraSubscribeDefaultTypeInternal _AppCameraSubscribe_default_instance_;
class AppClanChanged;
struct AppClanChangedDefaultTypeInternal;
extern AppClanChangedDefaultTypeInternal _AppClanChanged_default_instance_;
class AppClanChat;
struct AppClanChatDefaultTypeInternal;
extern AppClanChatDefaultTypeInternal _AppClanChat_default_instance_;
class AppClanInfo;
struct AppClanInfoDefaultTypeInternal;
extern AppClanInfoDefaultTypeInternal _AppClanInfo_default_instance_;
class AppClanMessage;
struct AppClanMessageDefaultTypeInternal;
extern AppClanMessageDefaultTypeInternal _AppClanMessage_default_instance_;
class AppEmpty;
struct AppEmptyDefaultTypeInternal;
extern AppEmptyDefaultTypeInternal _AppEmpty_default_instance_;
class AppEntityChanged;
struct AppEntityChangedDefaultTypeInternal;
extern AppEntityChangedDefaultTypeInternal _AppEntityChanged_default_instance_;
class AppEntityInfo;
struct AppEntityInfoDefaultTypeInternal;
extern AppEntityInfoDefaultTypeInternal _AppEntityInfo_default_instance_;
class AppEntityPayload;
struct AppEntityPayloadDefaultTypeInternal;
extern AppEntityPayloadDefaultTypeInternal _AppEntityPayload_default_instance_;
class AppEntityPayload_Item;
struct AppEntityPayload_ItemDefaultTypeInternal;
extern AppEntityPayload_ItemDefaultTypeInternal _AppEntityPayload_Item_default_instance_;
class AppError;
struct AppErrorDefaultTypeInternal;
extern AppErrorDefaultTypeInternal _AppError_default_instance_;
class AppFlag;
struct AppFlagDefaultTypeInternal;
extern AppFlagDefaultTypeInternal _AppFlag_default_instance_;
class AppGetNexusAuth;
struct AppGetNexusAuthDefaultTypeInternal;
extern AppGetNexusAuthDefaultTypeInternal _AppGetNexusAuth_default_instance_;
class AppInfo;
struct AppInfoDefaultTypeInternal;
extern AppInfoDefaultTypeInternal _AppInfo_default_instance_;
class AppMap;
struct AppMapDefaultTypeInternal;
extern AppMapDefaultTypeInternal _AppMap_default_instance_;
class AppMapMarkers;
struct AppMapMarkersDefaultTypeInternal;
extern AppMapMarkersDefaultTypeInternal _AppMapMarkers_default_instance_;
class AppMap_Monument;
struct AppMap_MonumentDefaultTypeInternal;
extern AppMap_MonumentDefaultTypeInternal _AppMap_Monument_default_instance_;
class AppMarker;
struct AppMarkerDefaultTypeInternal;
extern AppMarkerDefaultTypeInternal _AppMarker_default_instance_;
class AppMarker_SellOrder;
struct AppMarker_SellOrderDefaultTypeInternal;
extern AppMarker_SellOrderDefaultTypeInternal _AppMarker_SellOrder_default_instance_;
class AppMessage;
struct AppMessageDefaultTypeInternal;
extern AppMessageDefaultTypeInternal _AppMessage_default_instance_;
class AppNewClanMessage;
struct AppNewClanMessageDefaultTypeInternal;
extern AppNewClanMessageDefaultTypeInternal _AppNewClanMessage_default_instance_;
class AppNewTeamMessage;
struct AppNewTeamMessageDefaultTypeInternal;
extern AppNewTeamMessageDefaultTypeInternal _AppNewTeamMessage_default_instance_;
class AppNexusAuth;
struct AppNexusAuthDefaultTypeInternal;
extern AppNexusAuthDefaultTypeInternal _AppNexusAuth_default_instance_;
class AppPromoteToLeader;
struct AppPromoteToLeaderDefaultTypeInternal;
extern AppPromoteToLeaderDefaultTypeInternal _AppPromoteToLeader_default_instance_;
class AppRequest;
struct AppRequestDefaultTypeInternal;
extern AppRequestDefaultTypeInternal _AppRequest_default_instance_;
class AppResponse;
struct AppResponseDefaultTypeInternal;
extern AppResponseDefaultTypeInternal _AppResponse_default_instance_;
class AppSendMessage;
struct AppSendMessageDefaultTypeInternal;
extern AppSendMessageDefaultTypeInternal _AppSendMessage_default_instance_;
class AppSetEntityValue;
struct AppSetEntityValueDefaultTypeInternal;
extern AppSetEntityValueDefaultTypeInternal _AppSetEntityValue_default_instance_;
class AppSuccess;
struct AppSuccessDefaultTypeInternal;
extern AppSuccessDefaultTypeInternal _AppSuccess_default_instance_;
class AppTeamChanged;
struct AppTeamChangedDefaultTypeInternal;
extern AppTeamChangedDefaultTypeInternal _AppTeamChanged_default_instance_;
class AppTeamChat;
struct AppTeamChatDefaultTypeInternal;
extern AppTeamChatDefaultTypeInternal _AppTeamChat_default_instance_;
class AppTeamInfo;
struct AppTeamInfoDefaultTypeInternal;
extern AppTeamInfoDefaultTypeInternal _AppTeamInfo_default_instance_;
class AppTeamInfo_Member;
struct AppTeamInfo_MemberDefaultTypeInternal;
extern AppTeamInfo_MemberDefaultTypeInternal _AppTeamInfo_Member_default_instance_;
class AppTeamInfo_Note;
struct AppTeamInfo_NoteDefaultTypeInternal;
extern AppTeamInfo_NoteDefaultTypeInternal _AppTeamInfo_Note_default_instance_;
class AppTeamMessage;
struct AppTeamMessageDefaultTypeInternal;
extern AppTeamMessageDefaultTypeInternal _AppTeamMessage_default_instance_;
class AppTime;
struct AppTimeDefaultTypeInternal;
extern AppTimeDefaultTypeInternal _AppTime_default_instance_;
class ClanActionResult;
struct ClanActionResultDefaultTypeInternal;
extern ClanActionResultDefaultTypeInternal _ClanActionResult_default_instance_;
class ClanInfo;
struct ClanInfoDefaultTypeInternal;
extern ClanInfoDefaultTypeInternal _ClanInfo_default_instance_;
class ClanInfo_Invite;
struct ClanInfo_InviteDefaultTypeInternal;
extern ClanInfo_InviteDefaultTypeInternal _ClanInfo_Invite_default_instance_;
class ClanInfo_Member;
struct ClanInfo_MemberDefaultTypeInternal;
extern ClanInfo_MemberDefaultTypeInternal _ClanInfo_Member_default_instance_;
class ClanInfo_Role;
struct ClanInfo_RoleDefaultTypeInternal;
extern ClanInfo_RoleDefaultTypeInternal _ClanInfo_Role_default_instance_;
class ClanInvitations;
struct ClanInvitationsDefaultTypeInternal;
extern ClanInvitationsDefaultTypeInternal _ClanInvitations_default_instance_;
class ClanInvitations_Invitation;
struct ClanInvitations_InvitationDefaultTypeInternal;
extern ClanInvitations_InvitationDefaultTypeInternal _ClanInvitations_Invitation_default_instance_;
class ClanLog;
struct ClanLogDefaultTypeInternal;
extern ClanLogDefaultTypeInternal _ClanLog_default_instance_;
class ClanLog_Entry;
struct ClanLog_EntryDefaultTypeInternal;
extern ClanLog_EntryDefaultTypeInternal _ClanLog_Entry_default_instance_;
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Half3;
struct Half3DefaultTypeInternal;
extern Half3DefaultTypeInternal _Half3_default_instance_;
class Ray;
struct RayDefaultTypeInternal;
extern RayDefaultTypeInternal _Ray_default_instance_;
class Vector2;
struct Vector2DefaultTypeInternal;
extern Vector2DefaultTypeInternal _Vector2_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Vector4;
struct Vector4DefaultTypeInternal;
extern Vector4DefaultTypeInternal _Vector4_default_instance_;
}  // namespace rustplus
PROTOBUF_NAMESPACE_OPEN
template<> ::rustplus::AppBroadcast* Arena::CreateMaybeMessage<::rustplus::AppBroadcast>(Arena*);
template<> ::rustplus::AppCameraInfo* Arena::CreateMaybeMessage<::rustplus::AppCameraInfo>(Arena*);
template<> ::rustplus::AppCameraInput* Arena::CreateMaybeMessage<::rustplus::AppCameraInput>(Arena*);
template<> ::rustplus::AppCameraRays* Arena::CreateMaybeMessage<::rustplus::AppCameraRays>(Arena*);
template<> ::rustplus::AppCameraRays_Entity* Arena::CreateMaybeMessage<::rustplus::AppCameraRays_Entity>(Arena*);
template<> ::rustplus::AppCameraSubscribe* Arena::CreateMaybeMessage<::rustplus::AppCameraSubscribe>(Arena*);
template<> ::rustplus::AppClanChanged* Arena::CreateMaybeMessage<::rustplus::AppClanChanged>(Arena*);
template<> ::rustplus::AppClanChat* Arena::CreateMaybeMessage<::rustplus::AppClanChat>(Arena*);
template<> ::rustplus::AppClanInfo* Arena::CreateMaybeMessage<::rustplus::AppClanInfo>(Arena*);
template<> ::rustplus::AppClanMessage* Arena::CreateMaybeMessage<::rustplus::AppClanMessage>(Arena*);
template<> ::rustplus::AppEmpty* Arena::CreateMaybeMessage<::rustplus::AppEmpty>(Arena*);
template<> ::rustplus::AppEntityChanged* Arena::CreateMaybeMessage<::rustplus::AppEntityChanged>(Arena*);
template<> ::rustplus::AppEntityInfo* Arena::CreateMaybeMessage<::rustplus::AppEntityInfo>(Arena*);
template<> ::rustplus::AppEntityPayload* Arena::CreateMaybeMessage<::rustplus::AppEntityPayload>(Arena*);
template<> ::rustplus::AppEntityPayload_Item* Arena::CreateMaybeMessage<::rustplus::AppEntityPayload_Item>(Arena*);
template<> ::rustplus::AppError* Arena::CreateMaybeMessage<::rustplus::AppError>(Arena*);
template<> ::rustplus::AppFlag* Arena::CreateMaybeMessage<::rustplus::AppFlag>(Arena*);
template<> ::rustplus::AppGetNexusAuth* Arena::CreateMaybeMessage<::rustplus::AppGetNexusAuth>(Arena*);
template<> ::rustplus::AppInfo* Arena::CreateMaybeMessage<::rustplus::AppInfo>(Arena*);
template<> ::rustplus::AppMap* Arena::CreateMaybeMessage<::rustplus::AppMap>(Arena*);
template<> ::rustplus::AppMapMarkers* Arena::CreateMaybeMessage<::rustplus::AppMapMarkers>(Arena*);
template<> ::rustplus::AppMap_Monument* Arena::CreateMaybeMessage<::rustplus::AppMap_Monument>(Arena*);
template<> ::rustplus::AppMarker* Arena::CreateMaybeMessage<::rustplus::AppMarker>(Arena*);
template<> ::rustplus::AppMarker_SellOrder* Arena::CreateMaybeMessage<::rustplus::AppMarker_SellOrder>(Arena*);
template<> ::rustplus::AppMessage* Arena::CreateMaybeMessage<::rustplus::AppMessage>(Arena*);
template<> ::rustplus::AppNewClanMessage* Arena::CreateMaybeMessage<::rustplus::AppNewClanMessage>(Arena*);
template<> ::rustplus::AppNewTeamMessage* Arena::CreateMaybeMessage<::rustplus::AppNewTeamMessage>(Arena*);
template<> ::rustplus::AppNexusAuth* Arena::CreateMaybeMessage<::rustplus::AppNexusAuth>(Arena*);
template<> ::rustplus::AppPromoteToLeader* Arena::CreateMaybeMessage<::rustplus::AppPromoteToLeader>(Arena*);
template<> ::rustplus::AppRequest* Arena::CreateMaybeMessage<::rustplus::AppRequest>(Arena*);
template<> ::rustplus::AppResponse* Arena::CreateMaybeMessage<::rustplus::AppResponse>(Arena*);
template<> ::rustplus::AppSendMessage* Arena::CreateMaybeMessage<::rustplus::AppSendMessage>(Arena*);
template<> ::rustplus::AppSetEntityValue* Arena::CreateMaybeMessage<::rustplus::AppSetEntityValue>(Arena*);
template<> ::rustplus::AppSuccess* Arena::CreateMaybeMessage<::rustplus::AppSuccess>(Arena*);
template<> ::rustplus::AppTeamChanged* Arena::CreateMaybeMessage<::rustplus::AppTeamChanged>(Arena*);
template<> ::rustplus::AppTeamChat* Arena::CreateMaybeMessage<::rustplus::AppTeamChat>(Arena*);
template<> ::rustplus::AppTeamInfo* Arena::CreateMaybeMessage<::rustplus::AppTeamInfo>(Arena*);
template<> ::rustplus::AppTeamInfo_Member* Arena::CreateMaybeMessage<::rustplus::AppTeamInfo_Member>(Arena*);
template<> ::rustplus::AppTeamInfo_Note* Arena::CreateMaybeMessage<::rustplus::AppTeamInfo_Note>(Arena*);
template<> ::rustplus::AppTeamMessage* Arena::CreateMaybeMessage<::rustplus::AppTeamMessage>(Arena*);
template<> ::rustplus::AppTime* Arena::CreateMaybeMessage<::rustplus::AppTime>(Arena*);
template<> ::rustplus::ClanActionResult* Arena::CreateMaybeMessage<::rustplus::ClanActionResult>(Arena*);
template<> ::rustplus::ClanInfo* Arena::CreateMaybeMessage<::rustplus::ClanInfo>(Arena*);
template<> ::rustplus::ClanInfo_Invite* Arena::CreateMaybeMessage<::rustplus::ClanInfo_Invite>(Arena*);
template<> ::rustplus::ClanInfo_Member* Arena::CreateMaybeMessage<::rustplus::ClanInfo_Member>(Arena*);
template<> ::rustplus::ClanInfo_Role* Arena::CreateMaybeMessage<::rustplus::ClanInfo_Role>(Arena*);
template<> ::rustplus::ClanInvitations* Arena::CreateMaybeMessage<::rustplus::ClanInvitations>(Arena*);
template<> ::rustplus::ClanInvitations_Invitation* Arena::CreateMaybeMessage<::rustplus::ClanInvitations_Invitation>(Arena*);
template<> ::rustplus::ClanLog* Arena::CreateMaybeMessage<::rustplus::ClanLog>(Arena*);
template<> ::rustplus::ClanLog_Entry* Arena::CreateMaybeMessage<::rustplus::ClanLog_Entry>(Arena*);
template<> ::rustplus::Color* Arena::CreateMaybeMessage<::rustplus::Color>(Arena*);
template<> ::rustplus::Half3* Arena::CreateMaybeMessage<::rustplus::Half3>(Arena*);
template<> ::rustplus::Ray* Arena::CreateMaybeMessage<::rustplus::Ray>(Arena*);
template<> ::rustplus::Vector2* Arena::CreateMaybeMessage<::rustplus::Vector2>(Arena*);
template<> ::rustplus::Vector3* Arena::CreateMaybeMessage<::rustplus::Vector3>(Arena*);
template<> ::rustplus::Vector4* Arena::CreateMaybeMessage<::rustplus::Vector4>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rustplus {

enum AppCameraRays_EntityType : int {
  AppCameraRays_EntityType_Tree = 1,
  AppCameraRays_EntityType_Player = 2
};
bool AppCameraRays_EntityType_IsValid(int m_iValue);
constexpr AppCameraRays_EntityType AppCameraRays_EntityType_EntityType_MIN = AppCameraRays_EntityType_Tree;
constexpr AppCameraRays_EntityType AppCameraRays_EntityType_EntityType_MAX = AppCameraRays_EntityType_Player;
constexpr int AppCameraRays_EntityType_EntityType_ARRAYSIZE = AppCameraRays_EntityType_EntityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppCameraRays_EntityType_descriptor();
template<typename T>
inline const std::string& AppCameraRays_EntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppCameraRays_EntityType>::m_iValue ||
    ::std::is_integral<T>::m_iValue,
    "Incorrect type passed to function AppCameraRays_EntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppCameraRays_EntityType_descriptor(), enum_t_value);
}
inline bool AppCameraRays_EntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppCameraRays_EntityType* m_iValue) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppCameraRays_EntityType>(
    AppCameraRays_EntityType_descriptor(), name, m_iValue);
}
enum AppEntityType : int {
  Switch = 1,
  Alarm = 2,
  StorageMonitor = 3
};
bool AppEntityType_IsValid(int m_iValue);
constexpr AppEntityType AppEntityType_MIN = Switch;
constexpr AppEntityType AppEntityType_MAX = StorageMonitor;
constexpr int AppEntityType_ARRAYSIZE = AppEntityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppEntityType_descriptor();
template<typename T>
inline const std::string& AppEntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppEntityType>::m_iValue ||
    ::std::is_integral<T>::m_iValue,
    "Incorrect type passed to function AppEntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppEntityType_descriptor(), enum_t_value);
}
inline bool AppEntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppEntityType* m_iValue) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppEntityType>(
    AppEntityType_descriptor(), name, m_iValue);
}
enum AppMarkerType : int {
  Undefined = 0,
  Player = 1,
  Explosion = 2,
  VendingMachine = 3,
  CH47 = 4,
  CargoShip = 5,
  Crate = 6,
  GenericRadius = 7,
  PatrolHelicopter = 8
};
bool AppMarkerType_IsValid(int m_iValue);
constexpr AppMarkerType AppMarkerType_MIN = Undefined;
constexpr AppMarkerType AppMarkerType_MAX = PatrolHelicopter;
constexpr int AppMarkerType_ARRAYSIZE = AppMarkerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppMarkerType_descriptor();
template<typename T>
inline const std::string& AppMarkerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppMarkerType>::m_iValue ||
    ::std::is_integral<T>::m_iValue,
    "Incorrect type passed to function AppMarkerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppMarkerType_descriptor(), enum_t_value);
}
inline bool AppMarkerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppMarkerType* m_iValue) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppMarkerType>(
    AppMarkerType_descriptor(), name, m_iValue);
}
// ===================================================================

class Vector2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.Vector2) */ {
 public:
  inline Vector2() : Vector2(nullptr) {}
  ~Vector2() override;
  explicit constexpr Vector2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2(const Vector2& from);
  Vector2(Vector2&& from) noexcept
    : Vector2() {
    *this = ::std::move(from);
  }

  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2& operator=(Vector2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2* internal_default_instance() {
    return reinterpret_cast<const Vector2*>(
               &_Vector2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2& a, Vector2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector2* New() const final {
    return new Vector2();
  }

  Vector2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.Vector2";
  }
  protected:
  explicit Vector2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.Vector2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit constexpr Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return new Vector3();
  }

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float m_iValue);
  private:
  float _internal_z() const;
  void _internal_set_z(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class Vector4 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.Vector4) */ {
 public:
  inline Vector4() : Vector4(nullptr) {}
  ~Vector4() override;
  explicit constexpr Vector4(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector4(const Vector4& from);
  Vector4(Vector4&& from) noexcept
    : Vector4() {
    *this = ::std::move(from);
  }

  inline Vector4& operator=(const Vector4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector4& operator=(Vector4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector4* internal_default_instance() {
    return reinterpret_cast<const Vector4*>(
               &_Vector4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vector4& a, Vector4& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector4* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector4* New() const final {
    return new Vector4();
  }

  Vector4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector4>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector4& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector4& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.Vector4";
  }
  protected:
  explicit Vector4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float m_iValue);
  private:
  float _internal_z() const;
  void _internal_set_z(float m_iValue);
  public:

  // optional float w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  float w() const;
  void set_w(float m_iValue);
  private:
  float _internal_w() const;
  void _internal_set_w(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.Vector4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class Half3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.Half3) */ {
 public:
  inline Half3() : Half3(nullptr) {}
  ~Half3() override;
  explicit constexpr Half3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Half3(const Half3& from);
  Half3(Half3&& from) noexcept
    : Half3() {
    *this = ::std::move(from);
  }

  inline Half3& operator=(const Half3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Half3& operator=(Half3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Half3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Half3* internal_default_instance() {
    return reinterpret_cast<const Half3*>(
               &_Half3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Half3& a, Half3& b) {
    a.Swap(&b);
  }
  inline void Swap(Half3* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Half3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Half3* New() const final {
    return new Half3();
  }

  Half3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Half3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Half3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Half3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Half3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.Half3";
  }
  protected:
  explicit Half3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float m_iValue);
  private:
  float _internal_z() const;
  void _internal_set_z(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.Half3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  explicit constexpr Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return new Color();
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Color& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // optional float r = 1;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  float r() const;
  void set_r(float m_iValue);
  private:
  float _internal_r() const;
  void _internal_set_r(float m_iValue);
  public:

  // optional float g = 2;
  bool has_g() const;
  private:
  bool _internal_has_g() const;
  public:
  void clear_g();
  float g() const;
  void set_g(float m_iValue);
  private:
  float _internal_g() const;
  void _internal_set_g(float m_iValue);
  public:

  // optional float b = 3;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  float b() const;
  void set_b(float m_iValue);
  private:
  float _internal_b() const;
  void _internal_set_b(float m_iValue);
  public:

  // optional float a = 4;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  float a() const;
  void set_a(float m_iValue);
  private:
  float _internal_a() const;
  void _internal_set_a(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float r_;
  float g_;
  float b_;
  float a_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class Ray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.Ray) */ {
 public:
  inline Ray() : Ray(nullptr) {}
  ~Ray() override;
  explicit constexpr Ray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ray(const Ray& from);
  Ray(Ray&& from) noexcept
    : Ray() {
    *this = ::std::move(from);
  }

  inline Ray& operator=(const Ray& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ray& operator=(Ray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ray& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ray* internal_default_instance() {
    return reinterpret_cast<const Ray*>(
               &_Ray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Ray& a, Ray& b) {
    a.Swap(&b);
  }
  inline void Swap(Ray* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ray* New() const final {
    return new Ray();
  }

  Ray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ray& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.Ray";
  }
  protected:
  explicit Ray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // optional .rustplus.Vector3 origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::rustplus::Vector3& origin() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector3* release_origin();
  ::rustplus::Vector3* mutable_origin();
  void set_allocated_origin(::rustplus::Vector3* origin);
  private:
  const ::rustplus::Vector3& _internal_origin() const;
  ::rustplus::Vector3* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::rustplus::Vector3* origin);
  ::rustplus::Vector3* unsafe_arena_release_origin();

  // optional .rustplus.Vector3 direction = 2;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::rustplus::Vector3& direction() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector3* release_direction();
  ::rustplus::Vector3* mutable_direction();
  void set_allocated_direction(::rustplus::Vector3* direction);
  private:
  const ::rustplus::Vector3& _internal_direction() const;
  ::rustplus::Vector3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::rustplus::Vector3* direction);
  ::rustplus::Vector3* unsafe_arena_release_direction();

  // @@protoc_insertion_point(class_scope:rustplus.Ray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::Vector3* origin_;
  ::rustplus::Vector3* direction_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanActionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanActionResult) */ {
 public:
  inline ClanActionResult() : ClanActionResult(nullptr) {}
  ~ClanActionResult() override;
  explicit constexpr ClanActionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanActionResult(const ClanActionResult& from);
  ClanActionResult(ClanActionResult&& from) noexcept
    : ClanActionResult() {
    *this = ::std::move(from);
  }

  inline ClanActionResult& operator=(const ClanActionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanActionResult& operator=(ClanActionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanActionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanActionResult* internal_default_instance() {
    return reinterpret_cast<const ClanActionResult*>(
               &_ClanActionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClanActionResult& a, ClanActionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanActionResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanActionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanActionResult* New() const final {
    return new ClanActionResult();
  }

  ClanActionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanActionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanActionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanActionResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanActionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanActionResult";
  }
  protected:
  explicit ClanActionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClanInfoFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kResultFieldNumber = 2,
    kHasClanInfoFieldNumber = 3,
  };
  // optional .rustplus.ClanInfo clanInfo = 4;
  bool has_claninfo() const;
  private:
  bool _internal_has_claninfo() const;
  public:
  void clear_claninfo();
  const ::rustplus::ClanInfo& claninfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::ClanInfo* release_claninfo();
  ::rustplus::ClanInfo* mutable_claninfo();
  void set_allocated_claninfo(::rustplus::ClanInfo* claninfo);
  private:
  const ::rustplus::ClanInfo& _internal_claninfo() const;
  ::rustplus::ClanInfo* _internal_mutable_claninfo();
  public:
  void unsafe_arena_set_allocated_claninfo(
      ::rustplus::ClanInfo* claninfo);
  ::rustplus::ClanInfo* unsafe_arena_release_claninfo();

  // required int32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  ::PROTOBUF_NAMESPACE_ID::int32 requestid() const;
  void set_requestid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_requestid() const;
  void _internal_set_requestid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required bool hasClanInfo = 3;
  bool has_hasclaninfo() const;
  private:
  bool _internal_has_hasclaninfo() const;
  public:
  void clear_hasclaninfo();
  bool hasclaninfo() const;
  void set_hasclaninfo(bool m_iValue);
  private:
  bool _internal_hasclaninfo() const;
  void _internal_set_hasclaninfo(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanActionResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::ClanInfo* claninfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 requestid_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  bool hasclaninfo_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanInfo_Role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanInfo.Role) */ {
 public:
  inline ClanInfo_Role() : ClanInfo_Role(nullptr) {}
  ~ClanInfo_Role() override;
  explicit constexpr ClanInfo_Role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanInfo_Role(const ClanInfo_Role& from);
  ClanInfo_Role(ClanInfo_Role&& from) noexcept
    : ClanInfo_Role() {
    *this = ::std::move(from);
  }

  inline ClanInfo_Role& operator=(const ClanInfo_Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanInfo_Role& operator=(ClanInfo_Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanInfo_Role& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanInfo_Role* internal_default_instance() {
    return reinterpret_cast<const ClanInfo_Role*>(
               &_ClanInfo_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClanInfo_Role& a, ClanInfo_Role& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanInfo_Role* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanInfo_Role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanInfo_Role* New() const final {
    return new ClanInfo_Role();
  }

  ClanInfo_Role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanInfo_Role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanInfo_Role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanInfo_Role& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanInfo_Role* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanInfo.Role";
  }
  protected:
  explicit ClanInfo_Role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kRoleIdFieldNumber = 1,
    kRankFieldNumber = 2,
    kCanSetMotdFieldNumber = 4,
    kCanSetLogoFieldNumber = 5,
    kCanInviteFieldNumber = 6,
    kCanKickFieldNumber = 7,
    kCanPromoteFieldNumber = 8,
    kCanDemoteFieldNumber = 9,
    kCanSetPlayerNotesFieldNumber = 10,
    kCanAccessLogsFieldNumber = 11,
  };
  // required string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // required int32 roleId = 1;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int32 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 rank = 2;
  bool has_rank() const;
  private:
  bool _internal_has_rank() const;
  public:
  void clear_rank();
  ::PROTOBUF_NAMESPACE_ID::int32 rank() const;
  void set_rank(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rank() const;
  void _internal_set_rank(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required bool canSetMotd = 4;
  bool has_cansetmotd() const;
  private:
  bool _internal_has_cansetmotd() const;
  public:
  void clear_cansetmotd();
  bool cansetmotd() const;
  void set_cansetmotd(bool m_iValue);
  private:
  bool _internal_cansetmotd() const;
  void _internal_set_cansetmotd(bool m_iValue);
  public:

  // required bool canSetLogo = 5;
  bool has_cansetlogo() const;
  private:
  bool _internal_has_cansetlogo() const;
  public:
  void clear_cansetlogo();
  bool cansetlogo() const;
  void set_cansetlogo(bool m_iValue);
  private:
  bool _internal_cansetlogo() const;
  void _internal_set_cansetlogo(bool m_iValue);
  public:

  // required bool canInvite = 6;
  bool has_caninvite() const;
  private:
  bool _internal_has_caninvite() const;
  public:
  void clear_caninvite();
  bool caninvite() const;
  void set_caninvite(bool m_iValue);
  private:
  bool _internal_caninvite() const;
  void _internal_set_caninvite(bool m_iValue);
  public:

  // required bool canKick = 7;
  bool has_cankick() const;
  private:
  bool _internal_has_cankick() const;
  public:
  void clear_cankick();
  bool cankick() const;
  void set_cankick(bool m_iValue);
  private:
  bool _internal_cankick() const;
  void _internal_set_cankick(bool m_iValue);
  public:

  // required bool canPromote = 8;
  bool has_canpromote() const;
  private:
  bool _internal_has_canpromote() const;
  public:
  void clear_canpromote();
  bool canpromote() const;
  void set_canpromote(bool m_iValue);
  private:
  bool _internal_canpromote() const;
  void _internal_set_canpromote(bool m_iValue);
  public:

  // required bool canDemote = 9;
  bool has_candemote() const;
  private:
  bool _internal_has_candemote() const;
  public:
  void clear_candemote();
  bool candemote() const;
  void set_candemote(bool m_iValue);
  private:
  bool _internal_candemote() const;
  void _internal_set_candemote(bool m_iValue);
  public:

  // required bool canSetPlayerNotes = 10;
  bool has_cansetplayernotes() const;
  private:
  bool _internal_has_cansetplayernotes() const;
  public:
  void clear_cansetplayernotes();
  bool cansetplayernotes() const;
  void set_cansetplayernotes(bool m_iValue);
  private:
  bool _internal_cansetplayernotes() const;
  void _internal_set_cansetplayernotes(bool m_iValue);
  public:

  // required bool canAccessLogs = 11;
  bool has_canaccesslogs() const;
  private:
  bool _internal_has_canaccesslogs() const;
  public:
  void clear_canaccesslogs();
  bool canaccesslogs() const;
  void set_canaccesslogs(bool m_iValue);
  private:
  bool _internal_canaccesslogs() const;
  void _internal_set_canaccesslogs(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanInfo.Role)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 roleid_;
  ::PROTOBUF_NAMESPACE_ID::int32 rank_;
  bool cansetmotd_;
  bool cansetlogo_;
  bool caninvite_;
  bool cankick_;
  bool canpromote_;
  bool candemote_;
  bool cansetplayernotes_;
  bool canaccesslogs_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanInfo_Member final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanInfo.Member) */ {
 public:
  inline ClanInfo_Member() : ClanInfo_Member(nullptr) {}
  ~ClanInfo_Member() override;
  explicit constexpr ClanInfo_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanInfo_Member(const ClanInfo_Member& from);
  ClanInfo_Member(ClanInfo_Member&& from) noexcept
    : ClanInfo_Member() {
    *this = ::std::move(from);
  }

  inline ClanInfo_Member& operator=(const ClanInfo_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanInfo_Member& operator=(ClanInfo_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanInfo_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanInfo_Member* internal_default_instance() {
    return reinterpret_cast<const ClanInfo_Member*>(
               &_ClanInfo_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClanInfo_Member& a, ClanInfo_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanInfo_Member* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanInfo_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanInfo_Member* New() const final {
    return new ClanInfo_Member();
  }

  ClanInfo_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanInfo_Member>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanInfo_Member& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanInfo_Member& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanInfo_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanInfo.Member";
  }
  protected:
  explicit ClanInfo_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotesFieldNumber = 5,
    kSteamIdFieldNumber = 1,
    kJoinedFieldNumber = 3,
    kLastSeenFieldNumber = 4,
    kRoleIdFieldNumber = 2,
    kOnlineFieldNumber = 6,
  };
  // optional string notes = 5;
  bool has_notes() const;
  private:
  bool _internal_has_notes() const;
  public:
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_MUST_USE_RESULT std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& m_iValue);
  std::string* _internal_mutable_notes();
  public:

  // required int64 steamId = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::int64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 joined = 3;
  bool has_joined() const;
  private:
  bool _internal_has_joined() const;
  public:
  void clear_joined();
  ::PROTOBUF_NAMESPACE_ID::int64 joined() const;
  void set_joined(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_joined() const;
  void _internal_set_joined(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 lastSeen = 4;
  bool has_lastseen() const;
  private:
  bool _internal_has_lastseen() const;
  public:
  void clear_lastseen();
  ::PROTOBUF_NAMESPACE_ID::int64 lastseen() const;
  void set_lastseen(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_lastseen() const;
  void _internal_set_lastseen(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int32 roleId = 2;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int32 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // optional bool online = 6;
  bool has_online() const;
  private:
  bool _internal_has_online() const;
  public:
  void clear_online();
  bool online() const;
  void set_online(bool m_iValue);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanInfo.Member)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
  ::PROTOBUF_NAMESPACE_ID::int64 steamid_;
  ::PROTOBUF_NAMESPACE_ID::int64 joined_;
  ::PROTOBUF_NAMESPACE_ID::int64 lastseen_;
  ::PROTOBUF_NAMESPACE_ID::int32 roleid_;
  bool online_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanInfo_Invite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanInfo.Invite) */ {
 public:
  inline ClanInfo_Invite() : ClanInfo_Invite(nullptr) {}
  ~ClanInfo_Invite() override;
  explicit constexpr ClanInfo_Invite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanInfo_Invite(const ClanInfo_Invite& from);
  ClanInfo_Invite(ClanInfo_Invite&& from) noexcept
    : ClanInfo_Invite() {
    *this = ::std::move(from);
  }

  inline ClanInfo_Invite& operator=(const ClanInfo_Invite& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanInfo_Invite& operator=(ClanInfo_Invite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanInfo_Invite& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanInfo_Invite* internal_default_instance() {
    return reinterpret_cast<const ClanInfo_Invite*>(
               &_ClanInfo_Invite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClanInfo_Invite& a, ClanInfo_Invite& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanInfo_Invite* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanInfo_Invite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanInfo_Invite* New() const final {
    return new ClanInfo_Invite();
  }

  ClanInfo_Invite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanInfo_Invite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanInfo_Invite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanInfo_Invite& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanInfo_Invite* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanInfo.Invite";
  }
  protected:
  explicit ClanInfo_Invite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdFieldNumber = 1,
    kRecruiterFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // required int64 steamId = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::int64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 recruiter = 2;
  bool has_recruiter() const;
  private:
  bool _internal_has_recruiter() const;
  public:
  void clear_recruiter();
  ::PROTOBUF_NAMESPACE_ID::int64 recruiter() const;
  void set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_recruiter() const;
  void _internal_set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanInfo.Invite)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 steamid_;
  ::PROTOBUF_NAMESPACE_ID::int64 recruiter_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanInfo) */ {
 public:
  inline ClanInfo() : ClanInfo(nullptr) {}
  ~ClanInfo() override;
  explicit constexpr ClanInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanInfo(const ClanInfo& from);
  ClanInfo(ClanInfo&& from) noexcept
    : ClanInfo() {
    *this = ::std::move(from);
  }

  inline ClanInfo& operator=(const ClanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanInfo& operator=(ClanInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanInfo* internal_default_instance() {
    return reinterpret_cast<const ClanInfo*>(
               &_ClanInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClanInfo& a, ClanInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanInfo* New() const final {
    return new ClanInfo();
  }

  ClanInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanInfo";
  }
  protected:
  explicit ClanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClanInfo_Role Role;
  typedef ClanInfo_Member Member;
  typedef ClanInfo_Invite Invite;

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 10,
    kMembersFieldNumber = 11,
    kInvitesFieldNumber = 12,
    kNameFieldNumber = 2,
    kMotdFieldNumber = 5,
    kLogoFieldNumber = 8,
    kClanIdFieldNumber = 1,
    kCreatedFieldNumber = 3,
    kCreatorFieldNumber = 4,
    kMotdTimestampFieldNumber = 6,
    kMotdAuthorFieldNumber = 7,
    kColorFieldNumber = 9,
    kMaxMemberCountFieldNumber = 13,
  };
  // repeated .rustplus.ClanInfo.Role roles = 10;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::rustplus::ClanInfo_Role* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Role >*
      mutable_roles();
  private:
  const ::rustplus::ClanInfo_Role& _internal_roles(int index) const;
  ::rustplus::ClanInfo_Role* _internal_add_roles();
  public:
  const ::rustplus::ClanInfo_Role& roles(int index) const;
  ::rustplus::ClanInfo_Role* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Role >&
      roles() const;

  // repeated .rustplus.ClanInfo.Member members = 11;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::rustplus::ClanInfo_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Member >*
      mutable_members();
  private:
  const ::rustplus::ClanInfo_Member& _internal_members(int index) const;
  ::rustplus::ClanInfo_Member* _internal_add_members();
  public:
  const ::rustplus::ClanInfo_Member& members(int index) const;
  ::rustplus::ClanInfo_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Member >&
      members() const;

  // repeated .rustplus.ClanInfo.Invite invites = 12;
  int invites_size() const;
  private:
  int _internal_invites_size() const;
  public:
  void clear_invites();
  ::rustplus::ClanInfo_Invite* mutable_invites(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Invite >*
      mutable_invites();
  private:
  const ::rustplus::ClanInfo_Invite& _internal_invites(int index) const;
  ::rustplus::ClanInfo_Invite* _internal_add_invites();
  public:
  const ::rustplus::ClanInfo_Invite& invites(int index) const;
  ::rustplus::ClanInfo_Invite* add_invites();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Invite >&
      invites() const;

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // optional string motd = 5;
  bool has_motd() const;
  private:
  bool _internal_has_motd() const;
  public:
  void clear_motd();
  const std::string& motd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_motd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_motd();
  PROTOBUF_MUST_USE_RESULT std::string* release_motd();
  void set_allocated_motd(std::string* motd);
  private:
  const std::string& _internal_motd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_motd(const std::string& m_iValue);
  std::string* _internal_mutable_motd();
  public:

  // optional bytes logo = 8;
  bool has_logo() const;
  private:
  bool _internal_has_logo() const;
  public:
  void clear_logo();
  const std::string& logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo();
  PROTOBUF_MUST_USE_RESULT std::string* release_logo();
  void set_allocated_logo(std::string* logo);
  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(const std::string& m_iValue);
  std::string* _internal_mutable_logo();
  public:

  // required int64 clanId = 1;
  bool has_clanid() const;
  private:
  bool _internal_has_clanid() const;
  public:
  void clear_clanid();
  ::PROTOBUF_NAMESPACE_ID::int64 clanid() const;
  void set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_clanid() const;
  void _internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 created = 3;
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  ::PROTOBUF_NAMESPACE_ID::int64 created() const;
  void set_created(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_created() const;
  void _internal_set_created(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 creator = 4;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  ::PROTOBUF_NAMESPACE_ID::int64 creator() const;
  void set_creator(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_creator() const;
  void _internal_set_creator(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // optional int64 motdTimestamp = 6;
  bool has_motdtimestamp() const;
  private:
  bool _internal_has_motdtimestamp() const;
  public:
  void clear_motdtimestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 motdtimestamp() const;
  void set_motdtimestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_motdtimestamp() const;
  void _internal_set_motdtimestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // optional int64 motdAuthor = 7;
  bool has_motdauthor() const;
  private:
  bool _internal_has_motdauthor() const;
  public:
  void clear_motdauthor();
  ::PROTOBUF_NAMESPACE_ID::int64 motdauthor() const;
  void set_motdauthor(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_motdauthor() const;
  void _internal_set_motdauthor(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // optional sint32 color = 9;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::int32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // optional int32 maxMemberCount = 13;
  bool has_maxmembercount() const;
  private:
  bool _internal_has_maxmembercount() const;
  public:
  void clear_maxmembercount();
  ::PROTOBUF_NAMESPACE_ID::int32 maxmembercount() const;
  void set_maxmembercount(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxmembercount() const;
  void _internal_set_maxmembercount(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Role > roles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Member > members_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Invite > invites_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr motd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
  ::PROTOBUF_NAMESPACE_ID::int64 clanid_;
  ::PROTOBUF_NAMESPACE_ID::int64 created_;
  ::PROTOBUF_NAMESPACE_ID::int64 creator_;
  ::PROTOBUF_NAMESPACE_ID::int64 motdtimestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 motdauthor_;
  ::PROTOBUF_NAMESPACE_ID::int32 color_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxmembercount_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanLog_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanLog.Entry) */ {
 public:
  inline ClanLog_Entry() : ClanLog_Entry(nullptr) {}
  ~ClanLog_Entry() override;
  explicit constexpr ClanLog_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanLog_Entry(const ClanLog_Entry& from);
  ClanLog_Entry(ClanLog_Entry&& from) noexcept
    : ClanLog_Entry() {
    *this = ::std::move(from);
  }

  inline ClanLog_Entry& operator=(const ClanLog_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanLog_Entry& operator=(ClanLog_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanLog_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanLog_Entry* internal_default_instance() {
    return reinterpret_cast<const ClanLog_Entry*>(
               &_ClanLog_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClanLog_Entry& a, ClanLog_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanLog_Entry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanLog_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanLog_Entry* New() const final {
    return new ClanLog_Entry();
  }

  ClanLog_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanLog_Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanLog_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanLog_Entry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanLog_Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanLog.Entry";
  }
  protected:
  explicit ClanLog_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventKeyFieldNumber = 2,
    kArg1FieldNumber = 3,
    kArg2FieldNumber = 4,
    kArg3FieldNumber = 5,
    kArg4FieldNumber = 6,
    kTimestampFieldNumber = 1,
  };
  // required string eventKey = 2;
  bool has_eventkey() const;
  private:
  bool _internal_has_eventkey() const;
  public:
  void clear_eventkey();
  const std::string& eventkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventkey();
  PROTOBUF_MUST_USE_RESULT std::string* release_eventkey();
  void set_allocated_eventkey(std::string* eventkey);
  private:
  const std::string& _internal_eventkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventkey(const std::string& m_iValue);
  std::string* _internal_mutable_eventkey();
  public:

  // optional string arg1 = 3;
  bool has_arg1() const;
  private:
  bool _internal_has_arg1() const;
  public:
  void clear_arg1();
  const std::string& arg1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arg1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arg1();
  PROTOBUF_MUST_USE_RESULT std::string* release_arg1();
  void set_allocated_arg1(std::string* arg1);
  private:
  const std::string& _internal_arg1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg1(const std::string& m_iValue);
  std::string* _internal_mutable_arg1();
  public:

  // optional string arg2 = 4;
  bool has_arg2() const;
  private:
  bool _internal_has_arg2() const;
  public:
  void clear_arg2();
  const std::string& arg2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arg2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arg2();
  PROTOBUF_MUST_USE_RESULT std::string* release_arg2();
  void set_allocated_arg2(std::string* arg2);
  private:
  const std::string& _internal_arg2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg2(const std::string& m_iValue);
  std::string* _internal_mutable_arg2();
  public:

  // optional string arg3 = 5;
  bool has_arg3() const;
  private:
  bool _internal_has_arg3() const;
  public:
  void clear_arg3();
  const std::string& arg3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arg3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arg3();
  PROTOBUF_MUST_USE_RESULT std::string* release_arg3();
  void set_allocated_arg3(std::string* arg3);
  private:
  const std::string& _internal_arg3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg3(const std::string& m_iValue);
  std::string* _internal_mutable_arg3();
  public:

  // optional string arg4 = 6;
  bool has_arg4() const;
  private:
  bool _internal_has_arg4() const;
  public:
  void clear_arg4();
  const std::string& arg4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arg4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arg4();
  PROTOBUF_MUST_USE_RESULT std::string* release_arg4();
  void set_allocated_arg4(std::string* arg4);
  private:
  const std::string& _internal_arg4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg4(const std::string& m_iValue);
  std::string* _internal_mutable_arg4();
  public:

  // required int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanLog.Entry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg3_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg4_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanLog) */ {
 public:
  inline ClanLog() : ClanLog(nullptr) {}
  ~ClanLog() override;
  explicit constexpr ClanLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanLog(const ClanLog& from);
  ClanLog(ClanLog&& from) noexcept
    : ClanLog() {
    *this = ::std::move(from);
  }

  inline ClanLog& operator=(const ClanLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanLog& operator=(ClanLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanLog* internal_default_instance() {
    return reinterpret_cast<const ClanLog*>(
               &_ClanLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ClanLog& a, ClanLog& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanLog* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanLog* New() const final {
    return new ClanLog();
  }

  ClanLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanLog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanLog";
  }
  protected:
  explicit ClanLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClanLog_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kLogEntriesFieldNumber = 2,
    kClanIdFieldNumber = 1,
  };
  // repeated .rustplus.ClanLog.Entry logEntries = 2;
  int logentries_size() const;
  private:
  int _internal_logentries_size() const;
  public:
  void clear_logentries();
  ::rustplus::ClanLog_Entry* mutable_logentries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanLog_Entry >*
      mutable_logentries();
  private:
  const ::rustplus::ClanLog_Entry& _internal_logentries(int index) const;
  ::rustplus::ClanLog_Entry* _internal_add_logentries();
  public:
  const ::rustplus::ClanLog_Entry& logentries(int index) const;
  ::rustplus::ClanLog_Entry* add_logentries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanLog_Entry >&
      logentries() const;

  // required int64 clanId = 1;
  bool has_clanid() const;
  private:
  bool _internal_has_clanid() const;
  public:
  void clear_clanid();
  ::PROTOBUF_NAMESPACE_ID::int64 clanid() const;
  void set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_clanid() const;
  void _internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanLog_Entry > logentries_;
  ::PROTOBUF_NAMESPACE_ID::int64 clanid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanInvitations_Invitation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanInvitations.Invitation) */ {
 public:
  inline ClanInvitations_Invitation() : ClanInvitations_Invitation(nullptr) {}
  ~ClanInvitations_Invitation() override;
  explicit constexpr ClanInvitations_Invitation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanInvitations_Invitation(const ClanInvitations_Invitation& from);
  ClanInvitations_Invitation(ClanInvitations_Invitation&& from) noexcept
    : ClanInvitations_Invitation() {
    *this = ::std::move(from);
  }

  inline ClanInvitations_Invitation& operator=(const ClanInvitations_Invitation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanInvitations_Invitation& operator=(ClanInvitations_Invitation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanInvitations_Invitation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanInvitations_Invitation* internal_default_instance() {
    return reinterpret_cast<const ClanInvitations_Invitation*>(
               &_ClanInvitations_Invitation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ClanInvitations_Invitation& a, ClanInvitations_Invitation& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanInvitations_Invitation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanInvitations_Invitation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanInvitations_Invitation* New() const final {
    return new ClanInvitations_Invitation();
  }

  ClanInvitations_Invitation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanInvitations_Invitation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanInvitations_Invitation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanInvitations_Invitation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanInvitations_Invitation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanInvitations.Invitation";
  }
  protected:
  explicit ClanInvitations_Invitation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClanIdFieldNumber = 1,
    kRecruiterFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // required int64 clanId = 1;
  bool has_clanid() const;
  private:
  bool _internal_has_clanid() const;
  public:
  void clear_clanid();
  ::PROTOBUF_NAMESPACE_ID::int64 clanid() const;
  void set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_clanid() const;
  void _internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 recruiter = 2;
  bool has_recruiter() const;
  private:
  bool _internal_has_recruiter() const;
  public:
  void clear_recruiter();
  ::PROTOBUF_NAMESPACE_ID::int64 recruiter() const;
  void set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_recruiter() const;
  void _internal_set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // required int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.ClanInvitations.Invitation)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 clanid_;
  ::PROTOBUF_NAMESPACE_ID::int64 recruiter_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class ClanInvitations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.ClanInvitations) */ {
 public:
  inline ClanInvitations() : ClanInvitations(nullptr) {}
  ~ClanInvitations() override;
  explicit constexpr ClanInvitations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClanInvitations(const ClanInvitations& from);
  ClanInvitations(ClanInvitations&& from) noexcept
    : ClanInvitations() {
    *this = ::std::move(from);
  }

  inline ClanInvitations& operator=(const ClanInvitations& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClanInvitations& operator=(ClanInvitations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClanInvitations& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClanInvitations* internal_default_instance() {
    return reinterpret_cast<const ClanInvitations*>(
               &_ClanInvitations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ClanInvitations& a, ClanInvitations& b) {
    a.Swap(&b);
  }
  inline void Swap(ClanInvitations* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClanInvitations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClanInvitations* New() const final {
    return new ClanInvitations();
  }

  ClanInvitations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClanInvitations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClanInvitations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClanInvitations& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClanInvitations* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.ClanInvitations";
  }
  protected:
  explicit ClanInvitations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClanInvitations_Invitation Invitation;

  // accessors -------------------------------------------------------

  enum : int {
    kInvitationsFieldNumber = 1,
  };
  // repeated .rustplus.ClanInvitations.Invitation invitations = 1;
  int invitations_size() const;
  private:
  int _internal_invitations_size() const;
  public:
  void clear_invitations();
  ::rustplus::ClanInvitations_Invitation* mutable_invitations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInvitations_Invitation >*
      mutable_invitations();
  private:
  const ::rustplus::ClanInvitations_Invitation& _internal_invitations(int index) const;
  ::rustplus::ClanInvitations_Invitation* _internal_add_invitations();
  public:
  const ::rustplus::ClanInvitations_Invitation& invitations(int index) const;
  ::rustplus::ClanInvitations_Invitation* add_invitations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInvitations_Invitation >&
      invitations() const;

  // @@protoc_insertion_point(class_scope:rustplus.ClanInvitations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInvitations_Invitation > invitations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppRequest) */ {
 public:
  inline AppRequest() : AppRequest(nullptr) {}
  ~AppRequest() override;
  explicit constexpr AppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppRequest(const AppRequest& from);
  AppRequest(AppRequest&& from) noexcept
    : AppRequest() {
    *this = ::std::move(from);
  }

  inline AppRequest& operator=(const AppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppRequest& operator=(AppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppRequest* internal_default_instance() {
    return reinterpret_cast<const AppRequest*>(
               &_AppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AppRequest& a, AppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppRequest* New() const final {
    return new AppRequest();
  }

  AppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppRequest";
  }
  protected:
  explicit AppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetInfoFieldNumber = 8,
    kGetTimeFieldNumber = 9,
    kGetMapFieldNumber = 10,
    kGetTeamInfoFieldNumber = 11,
    kGetTeamChatFieldNumber = 12,
    kSendTeamMessageFieldNumber = 13,
    kGetEntityInfoFieldNumber = 14,
    kSetEntityValueFieldNumber = 15,
    kCheckSubscriptionFieldNumber = 16,
    kSetSubscriptionFieldNumber = 17,
    kGetMapMarkersFieldNumber = 18,
    kPromoteToLeaderFieldNumber = 20,
    kGetClanInfoFieldNumber = 21,
    kSetClanMotdFieldNumber = 22,
    kGetClanChatFieldNumber = 23,
    kSendClanMessageFieldNumber = 24,
    kGetNexusAuthFieldNumber = 25,
    kCameraSubscribeFieldNumber = 30,
    kCameraUnsubscribeFieldNumber = 31,
    kCameraInputFieldNumber = 32,
    kPlayerIdFieldNumber = 2,
    kSeqFieldNumber = 1,
    kPlayerTokenFieldNumber = 3,
    kEntityIdFieldNumber = 4,
  };
  // optional .rustplus.AppEmpty getInfo = 8;
  bool has_getinfo() const;
  private:
  bool _internal_has_getinfo() const;
  public:
  void clear_getinfo();
  const ::rustplus::AppEmpty& getinfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getinfo();
  ::rustplus::AppEmpty* mutable_getinfo();
  void set_allocated_getinfo(::rustplus::AppEmpty* getinfo);
  private:
  const ::rustplus::AppEmpty& _internal_getinfo() const;
  ::rustplus::AppEmpty* _internal_mutable_getinfo();
  public:
  void unsafe_arena_set_allocated_getinfo(
      ::rustplus::AppEmpty* getinfo);
  ::rustplus::AppEmpty* unsafe_arena_release_getinfo();

  // optional .rustplus.AppEmpty getTime = 9;
  bool has_gettime() const;
  private:
  bool _internal_has_gettime() const;
  public:
  void clear_gettime();
  const ::rustplus::AppEmpty& gettime() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_gettime();
  ::rustplus::AppEmpty* mutable_gettime();
  void set_allocated_gettime(::rustplus::AppEmpty* gettime);
  private:
  const ::rustplus::AppEmpty& _internal_gettime() const;
  ::rustplus::AppEmpty* _internal_mutable_gettime();
  public:
  void unsafe_arena_set_allocated_gettime(
      ::rustplus::AppEmpty* gettime);
  ::rustplus::AppEmpty* unsafe_arena_release_gettime();

  // optional .rustplus.AppEmpty getMap = 10;
  bool has_getmap() const;
  private:
  bool _internal_has_getmap() const;
  public:
  void clear_getmap();
  const ::rustplus::AppEmpty& getmap() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getmap();
  ::rustplus::AppEmpty* mutable_getmap();
  void set_allocated_getmap(::rustplus::AppEmpty* getmap);
  private:
  const ::rustplus::AppEmpty& _internal_getmap() const;
  ::rustplus::AppEmpty* _internal_mutable_getmap();
  public:
  void unsafe_arena_set_allocated_getmap(
      ::rustplus::AppEmpty* getmap);
  ::rustplus::AppEmpty* unsafe_arena_release_getmap();

  // optional .rustplus.AppEmpty getTeamInfo = 11;
  bool has_getteaminfo() const;
  private:
  bool _internal_has_getteaminfo() const;
  public:
  void clear_getteaminfo();
  const ::rustplus::AppEmpty& getteaminfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getteaminfo();
  ::rustplus::AppEmpty* mutable_getteaminfo();
  void set_allocated_getteaminfo(::rustplus::AppEmpty* getteaminfo);
  private:
  const ::rustplus::AppEmpty& _internal_getteaminfo() const;
  ::rustplus::AppEmpty* _internal_mutable_getteaminfo();
  public:
  void unsafe_arena_set_allocated_getteaminfo(
      ::rustplus::AppEmpty* getteaminfo);
  ::rustplus::AppEmpty* unsafe_arena_release_getteaminfo();

  // optional .rustplus.AppEmpty getTeamChat = 12;
  bool has_getteamchat() const;
  private:
  bool _internal_has_getteamchat() const;
  public:
  void clear_getteamchat();
  const ::rustplus::AppEmpty& getteamchat() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getteamchat();
  ::rustplus::AppEmpty* mutable_getteamchat();
  void set_allocated_getteamchat(::rustplus::AppEmpty* getteamchat);
  private:
  const ::rustplus::AppEmpty& _internal_getteamchat() const;
  ::rustplus::AppEmpty* _internal_mutable_getteamchat();
  public:
  void unsafe_arena_set_allocated_getteamchat(
      ::rustplus::AppEmpty* getteamchat);
  ::rustplus::AppEmpty* unsafe_arena_release_getteamchat();

  // optional .rustplus.AppSendMessage sendTeamMessage = 13;
  bool has_sendteammessage() const;
  private:
  bool _internal_has_sendteammessage() const;
  public:
  void clear_sendteammessage();
  const ::rustplus::AppSendMessage& sendteammessage() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppSendMessage* release_sendteammessage();
  ::rustplus::AppSendMessage* mutable_sendteammessage();
  void set_allocated_sendteammessage(::rustplus::AppSendMessage* sendteammessage);
  private:
  const ::rustplus::AppSendMessage& _internal_sendteammessage() const;
  ::rustplus::AppSendMessage* _internal_mutable_sendteammessage();
  public:
  void unsafe_arena_set_allocated_sendteammessage(
      ::rustplus::AppSendMessage* sendteammessage);
  ::rustplus::AppSendMessage* unsafe_arena_release_sendteammessage();

  // optional .rustplus.AppEmpty getEntityInfo = 14;
  bool has_getentityinfo() const;
  private:
  bool _internal_has_getentityinfo() const;
  public:
  void clear_getentityinfo();
  const ::rustplus::AppEmpty& getentityinfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getentityinfo();
  ::rustplus::AppEmpty* mutable_getentityinfo();
  void set_allocated_getentityinfo(::rustplus::AppEmpty* getentityinfo);
  private:
  const ::rustplus::AppEmpty& _internal_getentityinfo() const;
  ::rustplus::AppEmpty* _internal_mutable_getentityinfo();
  public:
  void unsafe_arena_set_allocated_getentityinfo(
      ::rustplus::AppEmpty* getentityinfo);
  ::rustplus::AppEmpty* unsafe_arena_release_getentityinfo();

  // optional .rustplus.AppSetEntityValue setEntityValue = 15;
  bool has_setentityvalue() const;
  private:
  bool _internal_has_setentityvalue() const;
  public:
  void clear_setentityvalue();
  const ::rustplus::AppSetEntityValue& setentityvalue() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppSetEntityValue* release_setentityvalue();
  ::rustplus::AppSetEntityValue* mutable_setentityvalue();
  void set_allocated_setentityvalue(::rustplus::AppSetEntityValue* setentityvalue);
  private:
  const ::rustplus::AppSetEntityValue& _internal_setentityvalue() const;
  ::rustplus::AppSetEntityValue* _internal_mutable_setentityvalue();
  public:
  void unsafe_arena_set_allocated_setentityvalue(
      ::rustplus::AppSetEntityValue* setentityvalue);
  ::rustplus::AppSetEntityValue* unsafe_arena_release_setentityvalue();

  // optional .rustplus.AppEmpty checkSubscription = 16;
  bool has_checksubscription() const;
  private:
  bool _internal_has_checksubscription() const;
  public:
  void clear_checksubscription();
  const ::rustplus::AppEmpty& checksubscription() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_checksubscription();
  ::rustplus::AppEmpty* mutable_checksubscription();
  void set_allocated_checksubscription(::rustplus::AppEmpty* checksubscription);
  private:
  const ::rustplus::AppEmpty& _internal_checksubscription() const;
  ::rustplus::AppEmpty* _internal_mutable_checksubscription();
  public:
  void unsafe_arena_set_allocated_checksubscription(
      ::rustplus::AppEmpty* checksubscription);
  ::rustplus::AppEmpty* unsafe_arena_release_checksubscription();

  // optional .rustplus.AppFlag setSubscription = 17;
  bool has_setsubscription() const;
  private:
  bool _internal_has_setsubscription() const;
  public:
  void clear_setsubscription();
  const ::rustplus::AppFlag& setsubscription() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppFlag* release_setsubscription();
  ::rustplus::AppFlag* mutable_setsubscription();
  void set_allocated_setsubscription(::rustplus::AppFlag* setsubscription);
  private:
  const ::rustplus::AppFlag& _internal_setsubscription() const;
  ::rustplus::AppFlag* _internal_mutable_setsubscription();
  public:
  void unsafe_arena_set_allocated_setsubscription(
      ::rustplus::AppFlag* setsubscription);
  ::rustplus::AppFlag* unsafe_arena_release_setsubscription();

  // optional .rustplus.AppEmpty getMapMarkers = 18;
  bool has_getmapmarkers() const;
  private:
  bool _internal_has_getmapmarkers() const;
  public:
  void clear_getmapmarkers();
  const ::rustplus::AppEmpty& getmapmarkers() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getmapmarkers();
  ::rustplus::AppEmpty* mutable_getmapmarkers();
  void set_allocated_getmapmarkers(::rustplus::AppEmpty* getmapmarkers);
  private:
  const ::rustplus::AppEmpty& _internal_getmapmarkers() const;
  ::rustplus::AppEmpty* _internal_mutable_getmapmarkers();
  public:
  void unsafe_arena_set_allocated_getmapmarkers(
      ::rustplus::AppEmpty* getmapmarkers);
  ::rustplus::AppEmpty* unsafe_arena_release_getmapmarkers();

  // optional .rustplus.AppPromoteToLeader promoteToLeader = 20;
  bool has_promotetoleader() const;
  private:
  bool _internal_has_promotetoleader() const;
  public:
  void clear_promotetoleader();
  const ::rustplus::AppPromoteToLeader& promotetoleader() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppPromoteToLeader* release_promotetoleader();
  ::rustplus::AppPromoteToLeader* mutable_promotetoleader();
  void set_allocated_promotetoleader(::rustplus::AppPromoteToLeader* promotetoleader);
  private:
  const ::rustplus::AppPromoteToLeader& _internal_promotetoleader() const;
  ::rustplus::AppPromoteToLeader* _internal_mutable_promotetoleader();
  public:
  void unsafe_arena_set_allocated_promotetoleader(
      ::rustplus::AppPromoteToLeader* promotetoleader);
  ::rustplus::AppPromoteToLeader* unsafe_arena_release_promotetoleader();

  // optional .rustplus.AppEmpty getClanInfo = 21;
  bool has_getclaninfo() const;
  private:
  bool _internal_has_getclaninfo() const;
  public:
  void clear_getclaninfo();
  const ::rustplus::AppEmpty& getclaninfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getclaninfo();
  ::rustplus::AppEmpty* mutable_getclaninfo();
  void set_allocated_getclaninfo(::rustplus::AppEmpty* getclaninfo);
  private:
  const ::rustplus::AppEmpty& _internal_getclaninfo() const;
  ::rustplus::AppEmpty* _internal_mutable_getclaninfo();
  public:
  void unsafe_arena_set_allocated_getclaninfo(
      ::rustplus::AppEmpty* getclaninfo);
  ::rustplus::AppEmpty* unsafe_arena_release_getclaninfo();

  // optional .rustplus.AppSendMessage setClanMotd = 22;
  bool has_setclanmotd() const;
  private:
  bool _internal_has_setclanmotd() const;
  public:
  void clear_setclanmotd();
  const ::rustplus::AppSendMessage& setclanmotd() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppSendMessage* release_setclanmotd();
  ::rustplus::AppSendMessage* mutable_setclanmotd();
  void set_allocated_setclanmotd(::rustplus::AppSendMessage* setclanmotd);
  private:
  const ::rustplus::AppSendMessage& _internal_setclanmotd() const;
  ::rustplus::AppSendMessage* _internal_mutable_setclanmotd();
  public:
  void unsafe_arena_set_allocated_setclanmotd(
      ::rustplus::AppSendMessage* setclanmotd);
  ::rustplus::AppSendMessage* unsafe_arena_release_setclanmotd();

  // optional .rustplus.AppEmpty getClanChat = 23;
  bool has_getclanchat() const;
  private:
  bool _internal_has_getclanchat() const;
  public:
  void clear_getclanchat();
  const ::rustplus::AppEmpty& getclanchat() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_getclanchat();
  ::rustplus::AppEmpty* mutable_getclanchat();
  void set_allocated_getclanchat(::rustplus::AppEmpty* getclanchat);
  private:
  const ::rustplus::AppEmpty& _internal_getclanchat() const;
  ::rustplus::AppEmpty* _internal_mutable_getclanchat();
  public:
  void unsafe_arena_set_allocated_getclanchat(
      ::rustplus::AppEmpty* getclanchat);
  ::rustplus::AppEmpty* unsafe_arena_release_getclanchat();

  // optional .rustplus.AppSendMessage sendClanMessage = 24;
  bool has_sendclanmessage() const;
  private:
  bool _internal_has_sendclanmessage() const;
  public:
  void clear_sendclanmessage();
  const ::rustplus::AppSendMessage& sendclanmessage() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppSendMessage* release_sendclanmessage();
  ::rustplus::AppSendMessage* mutable_sendclanmessage();
  void set_allocated_sendclanmessage(::rustplus::AppSendMessage* sendclanmessage);
  private:
  const ::rustplus::AppSendMessage& _internal_sendclanmessage() const;
  ::rustplus::AppSendMessage* _internal_mutable_sendclanmessage();
  public:
  void unsafe_arena_set_allocated_sendclanmessage(
      ::rustplus::AppSendMessage* sendclanmessage);
  ::rustplus::AppSendMessage* unsafe_arena_release_sendclanmessage();

  // optional .rustplus.AppGetNexusAuth getNexusAuth = 25;
  bool has_getnexusauth() const;
  private:
  bool _internal_has_getnexusauth() const;
  public:
  void clear_getnexusauth();
  const ::rustplus::AppGetNexusAuth& getnexusauth() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppGetNexusAuth* release_getnexusauth();
  ::rustplus::AppGetNexusAuth* mutable_getnexusauth();
  void set_allocated_getnexusauth(::rustplus::AppGetNexusAuth* getnexusauth);
  private:
  const ::rustplus::AppGetNexusAuth& _internal_getnexusauth() const;
  ::rustplus::AppGetNexusAuth* _internal_mutable_getnexusauth();
  public:
  void unsafe_arena_set_allocated_getnexusauth(
      ::rustplus::AppGetNexusAuth* getnexusauth);
  ::rustplus::AppGetNexusAuth* unsafe_arena_release_getnexusauth();

  // optional .rustplus.AppCameraSubscribe cameraSubscribe = 30;
  bool has_camerasubscribe() const;
  private:
  bool _internal_has_camerasubscribe() const;
  public:
  void clear_camerasubscribe();
  const ::rustplus::AppCameraSubscribe& camerasubscribe() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppCameraSubscribe* release_camerasubscribe();
  ::rustplus::AppCameraSubscribe* mutable_camerasubscribe();
  void set_allocated_camerasubscribe(::rustplus::AppCameraSubscribe* camerasubscribe);
  private:
  const ::rustplus::AppCameraSubscribe& _internal_camerasubscribe() const;
  ::rustplus::AppCameraSubscribe* _internal_mutable_camerasubscribe();
  public:
  void unsafe_arena_set_allocated_camerasubscribe(
      ::rustplus::AppCameraSubscribe* camerasubscribe);
  ::rustplus::AppCameraSubscribe* unsafe_arena_release_camerasubscribe();

  // optional .rustplus.AppEmpty cameraUnsubscribe = 31;
  bool has_cameraunsubscribe() const;
  private:
  bool _internal_has_cameraunsubscribe() const;
  public:
  void clear_cameraunsubscribe();
  const ::rustplus::AppEmpty& cameraunsubscribe() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEmpty* release_cameraunsubscribe();
  ::rustplus::AppEmpty* mutable_cameraunsubscribe();
  void set_allocated_cameraunsubscribe(::rustplus::AppEmpty* cameraunsubscribe);
  private:
  const ::rustplus::AppEmpty& _internal_cameraunsubscribe() const;
  ::rustplus::AppEmpty* _internal_mutable_cameraunsubscribe();
  public:
  void unsafe_arena_set_allocated_cameraunsubscribe(
      ::rustplus::AppEmpty* cameraunsubscribe);
  ::rustplus::AppEmpty* unsafe_arena_release_cameraunsubscribe();

  // optional .rustplus.AppCameraInput cameraInput = 32;
  bool has_camerainput() const;
  private:
  bool _internal_has_camerainput() const;
  public:
  void clear_camerainput();
  const ::rustplus::AppCameraInput& camerainput() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppCameraInput* release_camerainput();
  ::rustplus::AppCameraInput* mutable_camerainput();
  void set_allocated_camerainput(::rustplus::AppCameraInput* camerainput);
  private:
  const ::rustplus::AppCameraInput& _internal_camerainput() const;
  ::rustplus::AppCameraInput* _internal_mutable_camerainput();
  public:
  void unsafe_arena_set_allocated_camerainput(
      ::rustplus::AppCameraInput* camerainput);
  ::rustplus::AppCameraInput* unsafe_arena_release_camerainput();

  // required uint64 playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // required uint32 seq = 1;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint32 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required int32 playerToken = 3;
  bool has_playertoken() const;
  private:
  bool _internal_has_playertoken() const;
  public:
  void clear_playertoken();
  ::PROTOBUF_NAMESPACE_ID::int32 playertoken() const;
  void set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playertoken() const;
  void _internal_set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // optional uint32 entityId = 4;
  bool has_entityid() const;
  private:
  bool _internal_has_entityid() const;
  public:
  void clear_entityid();
  ::PROTOBUF_NAMESPACE_ID::uint32 entityid() const;
  void set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entityid() const;
  void _internal_set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppEmpty* getinfo_;
  ::rustplus::AppEmpty* gettime_;
  ::rustplus::AppEmpty* getmap_;
  ::rustplus::AppEmpty* getteaminfo_;
  ::rustplus::AppEmpty* getteamchat_;
  ::rustplus::AppSendMessage* sendteammessage_;
  ::rustplus::AppEmpty* getentityinfo_;
  ::rustplus::AppSetEntityValue* setentityvalue_;
  ::rustplus::AppEmpty* checksubscription_;
  ::rustplus::AppFlag* setsubscription_;
  ::rustplus::AppEmpty* getmapmarkers_;
  ::rustplus::AppPromoteToLeader* promotetoleader_;
  ::rustplus::AppEmpty* getclaninfo_;
  ::rustplus::AppSendMessage* setclanmotd_;
  ::rustplus::AppEmpty* getclanchat_;
  ::rustplus::AppSendMessage* sendclanmessage_;
  ::rustplus::AppGetNexusAuth* getnexusauth_;
  ::rustplus::AppCameraSubscribe* camerasubscribe_;
  ::rustplus::AppEmpty* cameraunsubscribe_;
  ::rustplus::AppCameraInput* camerainput_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seq_;
  ::PROTOBUF_NAMESPACE_ID::int32 playertoken_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entityid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppMessage) */ {
 public:
  inline AppMessage() : AppMessage(nullptr) {}
  ~AppMessage() override;
  explicit constexpr AppMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMessage(const AppMessage& from);
  AppMessage(AppMessage&& from) noexcept
    : AppMessage() {
    *this = ::std::move(from);
  }

  inline AppMessage& operator=(const AppMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMessage& operator=(AppMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMessage* internal_default_instance() {
    return reinterpret_cast<const AppMessage*>(
               &_AppMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AppMessage& a, AppMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppMessage* New() const final {
    return new AppMessage();
  }

  AppMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppMessage";
  }
  protected:
  explicit AppMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kBroadcastFieldNumber = 2,
  };
  // optional .rustplus.AppResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::rustplus::AppResponse& response() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppResponse* release_response();
  ::rustplus::AppResponse* mutable_response();
  void set_allocated_response(::rustplus::AppResponse* response);
  private:
  const ::rustplus::AppResponse& _internal_response() const;
  ::rustplus::AppResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::rustplus::AppResponse* response);
  ::rustplus::AppResponse* unsafe_arena_release_response();

  // optional .rustplus.AppBroadcast broadcast = 2;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::rustplus::AppBroadcast& broadcast() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppBroadcast* release_broadcast();
  ::rustplus::AppBroadcast* mutable_broadcast();
  void set_allocated_broadcast(::rustplus::AppBroadcast* broadcast);
  private:
  const ::rustplus::AppBroadcast& _internal_broadcast() const;
  ::rustplus::AppBroadcast* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::rustplus::AppBroadcast* broadcast);
  ::rustplus::AppBroadcast* unsafe_arena_release_broadcast();

  // @@protoc_insertion_point(class_scope:rustplus.AppMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppResponse* response_;
  ::rustplus::AppBroadcast* broadcast_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppResponse) */ {
 public:
  inline AppResponse() : AppResponse(nullptr) {}
  ~AppResponse() override;
  explicit constexpr AppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppResponse(const AppResponse& from);
  AppResponse(AppResponse&& from) noexcept
    : AppResponse() {
    *this = ::std::move(from);
  }

  inline AppResponse& operator=(const AppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppResponse& operator=(AppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppResponse* internal_default_instance() {
    return reinterpret_cast<const AppResponse*>(
               &_AppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AppResponse& a, AppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppResponse* New() const final {
    return new AppResponse();
  }

  AppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppResponse";
  }
  protected:
  explicit AppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 4,
    kErrorFieldNumber = 5,
    kInfoFieldNumber = 6,
    kTimeFieldNumber = 7,
    kMapFieldNumber = 8,
    kTeamInfoFieldNumber = 9,
    kTeamChatFieldNumber = 10,
    kEntityInfoFieldNumber = 11,
    kFlagFieldNumber = 12,
    kMapMarkersFieldNumber = 13,
    kClanInfoFieldNumber = 15,
    kClanChatFieldNumber = 16,
    kNexusAuthFieldNumber = 17,
    kCameraSubscribeInfoFieldNumber = 20,
    kSeqFieldNumber = 1,
  };
  // optional .rustplus.AppSuccess success = 4;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  const ::rustplus::AppSuccess& success() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppSuccess* release_success();
  ::rustplus::AppSuccess* mutable_success();
  void set_allocated_success(::rustplus::AppSuccess* success);
  private:
  const ::rustplus::AppSuccess& _internal_success() const;
  ::rustplus::AppSuccess* _internal_mutable_success();
  public:
  void unsafe_arena_set_allocated_success(
      ::rustplus::AppSuccess* success);
  ::rustplus::AppSuccess* unsafe_arena_release_success();

  // optional .rustplus.AppError error = 5;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::rustplus::AppError& error() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppError* release_error();
  ::rustplus::AppError* mutable_error();
  void set_allocated_error(::rustplus::AppError* error);
  private:
  const ::rustplus::AppError& _internal_error() const;
  ::rustplus::AppError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::rustplus::AppError* error);
  ::rustplus::AppError* unsafe_arena_release_error();

  // optional .rustplus.AppInfo info = 6;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::rustplus::AppInfo& info() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppInfo* release_info();
  ::rustplus::AppInfo* mutable_info();
  void set_allocated_info(::rustplus::AppInfo* info);
  private:
  const ::rustplus::AppInfo& _internal_info() const;
  ::rustplus::AppInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::rustplus::AppInfo* info);
  ::rustplus::AppInfo* unsafe_arena_release_info();

  // optional .rustplus.AppTime time = 7;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::rustplus::AppTime& time() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppTime* release_time();
  ::rustplus::AppTime* mutable_time();
  void set_allocated_time(::rustplus::AppTime* time);
  private:
  const ::rustplus::AppTime& _internal_time() const;
  ::rustplus::AppTime* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::rustplus::AppTime* time);
  ::rustplus::AppTime* unsafe_arena_release_time();

  // optional .rustplus.AppMap map = 8;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::rustplus::AppMap& map() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppMap* release_map();
  ::rustplus::AppMap* mutable_map();
  void set_allocated_map(::rustplus::AppMap* map);
  private:
  const ::rustplus::AppMap& _internal_map() const;
  ::rustplus::AppMap* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::rustplus::AppMap* map);
  ::rustplus::AppMap* unsafe_arena_release_map();

  // optional .rustplus.AppTeamInfo teamInfo = 9;
  bool has_teaminfo() const;
  private:
  bool _internal_has_teaminfo() const;
  public:
  void clear_teaminfo();
  const ::rustplus::AppTeamInfo& teaminfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppTeamInfo* release_teaminfo();
  ::rustplus::AppTeamInfo* mutable_teaminfo();
  void set_allocated_teaminfo(::rustplus::AppTeamInfo* teaminfo);
  private:
  const ::rustplus::AppTeamInfo& _internal_teaminfo() const;
  ::rustplus::AppTeamInfo* _internal_mutable_teaminfo();
  public:
  void unsafe_arena_set_allocated_teaminfo(
      ::rustplus::AppTeamInfo* teaminfo);
  ::rustplus::AppTeamInfo* unsafe_arena_release_teaminfo();

  // optional .rustplus.AppTeamChat teamChat = 10;
  bool has_teamchat() const;
  private:
  bool _internal_has_teamchat() const;
  public:
  void clear_teamchat();
  const ::rustplus::AppTeamChat& teamchat() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppTeamChat* release_teamchat();
  ::rustplus::AppTeamChat* mutable_teamchat();
  void set_allocated_teamchat(::rustplus::AppTeamChat* teamchat);
  private:
  const ::rustplus::AppTeamChat& _internal_teamchat() const;
  ::rustplus::AppTeamChat* _internal_mutable_teamchat();
  public:
  void unsafe_arena_set_allocated_teamchat(
      ::rustplus::AppTeamChat* teamchat);
  ::rustplus::AppTeamChat* unsafe_arena_release_teamchat();

  // optional .rustplus.AppEntityInfo entityInfo = 11;
  bool has_entityinfo() const;
  private:
  bool _internal_has_entityinfo() const;
  public:
  void clear_entityinfo();
  const ::rustplus::AppEntityInfo& entityinfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEntityInfo* release_entityinfo();
  ::rustplus::AppEntityInfo* mutable_entityinfo();
  void set_allocated_entityinfo(::rustplus::AppEntityInfo* entityinfo);
  private:
  const ::rustplus::AppEntityInfo& _internal_entityinfo() const;
  ::rustplus::AppEntityInfo* _internal_mutable_entityinfo();
  public:
  void unsafe_arena_set_allocated_entityinfo(
      ::rustplus::AppEntityInfo* entityinfo);
  ::rustplus::AppEntityInfo* unsafe_arena_release_entityinfo();

  // optional .rustplus.AppFlag flag = 12;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  const ::rustplus::AppFlag& flag() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppFlag* release_flag();
  ::rustplus::AppFlag* mutable_flag();
  void set_allocated_flag(::rustplus::AppFlag* flag);
  private:
  const ::rustplus::AppFlag& _internal_flag() const;
  ::rustplus::AppFlag* _internal_mutable_flag();
  public:
  void unsafe_arena_set_allocated_flag(
      ::rustplus::AppFlag* flag);
  ::rustplus::AppFlag* unsafe_arena_release_flag();

  // optional .rustplus.AppMapMarkers mapMarkers = 13;
  bool has_mapmarkers() const;
  private:
  bool _internal_has_mapmarkers() const;
  public:
  void clear_mapmarkers();
  const ::rustplus::AppMapMarkers& mapmarkers() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppMapMarkers* release_mapmarkers();
  ::rustplus::AppMapMarkers* mutable_mapmarkers();
  void set_allocated_mapmarkers(::rustplus::AppMapMarkers* mapmarkers);
  private:
  const ::rustplus::AppMapMarkers& _internal_mapmarkers() const;
  ::rustplus::AppMapMarkers* _internal_mutable_mapmarkers();
  public:
  void unsafe_arena_set_allocated_mapmarkers(
      ::rustplus::AppMapMarkers* mapmarkers);
  ::rustplus::AppMapMarkers* unsafe_arena_release_mapmarkers();

  // optional .rustplus.AppClanInfo clanInfo = 15;
  bool has_claninfo() const;
  private:
  bool _internal_has_claninfo() const;
  public:
  void clear_claninfo();
  const ::rustplus::AppClanInfo& claninfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppClanInfo* release_claninfo();
  ::rustplus::AppClanInfo* mutable_claninfo();
  void set_allocated_claninfo(::rustplus::AppClanInfo* claninfo);
  private:
  const ::rustplus::AppClanInfo& _internal_claninfo() const;
  ::rustplus::AppClanInfo* _internal_mutable_claninfo();
  public:
  void unsafe_arena_set_allocated_claninfo(
      ::rustplus::AppClanInfo* claninfo);
  ::rustplus::AppClanInfo* unsafe_arena_release_claninfo();

  // optional .rustplus.AppClanChat clanChat = 16;
  bool has_clanchat() const;
  private:
  bool _internal_has_clanchat() const;
  public:
  void clear_clanchat();
  const ::rustplus::AppClanChat& clanchat() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppClanChat* release_clanchat();
  ::rustplus::AppClanChat* mutable_clanchat();
  void set_allocated_clanchat(::rustplus::AppClanChat* clanchat);
  private:
  const ::rustplus::AppClanChat& _internal_clanchat() const;
  ::rustplus::AppClanChat* _internal_mutable_clanchat();
  public:
  void unsafe_arena_set_allocated_clanchat(
      ::rustplus::AppClanChat* clanchat);
  ::rustplus::AppClanChat* unsafe_arena_release_clanchat();

  // optional .rustplus.AppNexusAuth nexusAuth = 17;
  bool has_nexusauth() const;
  private:
  bool _internal_has_nexusauth() const;
  public:
  void clear_nexusauth();
  const ::rustplus::AppNexusAuth& nexusauth() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppNexusAuth* release_nexusauth();
  ::rustplus::AppNexusAuth* mutable_nexusauth();
  void set_allocated_nexusauth(::rustplus::AppNexusAuth* nexusauth);
  private:
  const ::rustplus::AppNexusAuth& _internal_nexusauth() const;
  ::rustplus::AppNexusAuth* _internal_mutable_nexusauth();
  public:
  void unsafe_arena_set_allocated_nexusauth(
      ::rustplus::AppNexusAuth* nexusauth);
  ::rustplus::AppNexusAuth* unsafe_arena_release_nexusauth();

  // optional .rustplus.AppCameraInfo cameraSubscribeInfo = 20;
  bool has_camerasubscribeinfo() const;
  private:
  bool _internal_has_camerasubscribeinfo() const;
  public:
  void clear_camerasubscribeinfo();
  const ::rustplus::AppCameraInfo& camerasubscribeinfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppCameraInfo* release_camerasubscribeinfo();
  ::rustplus::AppCameraInfo* mutable_camerasubscribeinfo();
  void set_allocated_camerasubscribeinfo(::rustplus::AppCameraInfo* camerasubscribeinfo);
  private:
  const ::rustplus::AppCameraInfo& _internal_camerasubscribeinfo() const;
  ::rustplus::AppCameraInfo* _internal_mutable_camerasubscribeinfo();
  public:
  void unsafe_arena_set_allocated_camerasubscribeinfo(
      ::rustplus::AppCameraInfo* camerasubscribeinfo);
  ::rustplus::AppCameraInfo* unsafe_arena_release_camerasubscribeinfo();

  // required int32 seq = 1;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::int32 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppSuccess* success_;
  ::rustplus::AppError* error_;
  ::rustplus::AppInfo* info_;
  ::rustplus::AppTime* time_;
  ::rustplus::AppMap* map_;
  ::rustplus::AppTeamInfo* teaminfo_;
  ::rustplus::AppTeamChat* teamchat_;
  ::rustplus::AppEntityInfo* entityinfo_;
  ::rustplus::AppFlag* flag_;
  ::rustplus::AppMapMarkers* mapmarkers_;
  ::rustplus::AppClanInfo* claninfo_;
  ::rustplus::AppClanChat* clanchat_;
  ::rustplus::AppNexusAuth* nexusauth_;
  ::rustplus::AppCameraInfo* camerasubscribeinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 seq_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppBroadcast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppBroadcast) */ {
 public:
  inline AppBroadcast() : AppBroadcast(nullptr) {}
  ~AppBroadcast() override;
  explicit constexpr AppBroadcast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppBroadcast(const AppBroadcast& from);
  AppBroadcast(AppBroadcast&& from) noexcept
    : AppBroadcast() {
    *this = ::std::move(from);
  }

  inline AppBroadcast& operator=(const AppBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppBroadcast& operator=(AppBroadcast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppBroadcast& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppBroadcast* internal_default_instance() {
    return reinterpret_cast<const AppBroadcast*>(
               &_AppBroadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AppBroadcast& a, AppBroadcast& b) {
    a.Swap(&b);
  }
  inline void Swap(AppBroadcast* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppBroadcast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppBroadcast* New() const final {
    return new AppBroadcast();
  }

  AppBroadcast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppBroadcast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppBroadcast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppBroadcast& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppBroadcast* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppBroadcast";
  }
  protected:
  explicit AppBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamChangedFieldNumber = 4,
    kNewTeamMessageFieldNumber = 5,
    kEntityChangedFieldNumber = 6,
    kClanChangedFieldNumber = 7,
    kClanMessageFieldNumber = 8,
    kCameraRaysFieldNumber = 10,
  };
  // optional .rustplus.AppTeamChanged teamChanged = 4;
  bool has_teamchanged() const;
  private:
  bool _internal_has_teamchanged() const;
  public:
  void clear_teamchanged();
  const ::rustplus::AppTeamChanged& teamchanged() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppTeamChanged* release_teamchanged();
  ::rustplus::AppTeamChanged* mutable_teamchanged();
  void set_allocated_teamchanged(::rustplus::AppTeamChanged* teamchanged);
  private:
  const ::rustplus::AppTeamChanged& _internal_teamchanged() const;
  ::rustplus::AppTeamChanged* _internal_mutable_teamchanged();
  public:
  void unsafe_arena_set_allocated_teamchanged(
      ::rustplus::AppTeamChanged* teamchanged);
  ::rustplus::AppTeamChanged* unsafe_arena_release_teamchanged();

  // optional .rustplus.AppNewTeamMessage newTeamMessage = 5;
  bool has_newteammessage() const;
  private:
  bool _internal_has_newteammessage() const;
  public:
  void clear_newteammessage();
  const ::rustplus::AppNewTeamMessage& newteammessage() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppNewTeamMessage* release_newteammessage();
  ::rustplus::AppNewTeamMessage* mutable_newteammessage();
  void set_allocated_newteammessage(::rustplus::AppNewTeamMessage* newteammessage);
  private:
  const ::rustplus::AppNewTeamMessage& _internal_newteammessage() const;
  ::rustplus::AppNewTeamMessage* _internal_mutable_newteammessage();
  public:
  void unsafe_arena_set_allocated_newteammessage(
      ::rustplus::AppNewTeamMessage* newteammessage);
  ::rustplus::AppNewTeamMessage* unsafe_arena_release_newteammessage();

  // optional .rustplus.AppEntityChanged entityChanged = 6;
  bool has_entitychanged() const;
  private:
  bool _internal_has_entitychanged() const;
  public:
  void clear_entitychanged();
  const ::rustplus::AppEntityChanged& entitychanged() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEntityChanged* release_entitychanged();
  ::rustplus::AppEntityChanged* mutable_entitychanged();
  void set_allocated_entitychanged(::rustplus::AppEntityChanged* entitychanged);
  private:
  const ::rustplus::AppEntityChanged& _internal_entitychanged() const;
  ::rustplus::AppEntityChanged* _internal_mutable_entitychanged();
  public:
  void unsafe_arena_set_allocated_entitychanged(
      ::rustplus::AppEntityChanged* entitychanged);
  ::rustplus::AppEntityChanged* unsafe_arena_release_entitychanged();

  // optional .rustplus.AppClanChanged clanChanged = 7;
  bool has_clanchanged() const;
  private:
  bool _internal_has_clanchanged() const;
  public:
  void clear_clanchanged();
  const ::rustplus::AppClanChanged& clanchanged() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppClanChanged* release_clanchanged();
  ::rustplus::AppClanChanged* mutable_clanchanged();
  void set_allocated_clanchanged(::rustplus::AppClanChanged* clanchanged);
  private:
  const ::rustplus::AppClanChanged& _internal_clanchanged() const;
  ::rustplus::AppClanChanged* _internal_mutable_clanchanged();
  public:
  void unsafe_arena_set_allocated_clanchanged(
      ::rustplus::AppClanChanged* clanchanged);
  ::rustplus::AppClanChanged* unsafe_arena_release_clanchanged();

  // optional .rustplus.AppNewClanMessage clanMessage = 8;
  bool has_clanmessage() const;
  private:
  bool _internal_has_clanmessage() const;
  public:
  void clear_clanmessage();
  const ::rustplus::AppNewClanMessage& clanmessage() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppNewClanMessage* release_clanmessage();
  ::rustplus::AppNewClanMessage* mutable_clanmessage();
  void set_allocated_clanmessage(::rustplus::AppNewClanMessage* clanmessage);
  private:
  const ::rustplus::AppNewClanMessage& _internal_clanmessage() const;
  ::rustplus::AppNewClanMessage* _internal_mutable_clanmessage();
  public:
  void unsafe_arena_set_allocated_clanmessage(
      ::rustplus::AppNewClanMessage* clanmessage);
  ::rustplus::AppNewClanMessage* unsafe_arena_release_clanmessage();

  // optional .rustplus.AppCameraRays cameraRays = 10;
  bool has_camerarays() const;
  private:
  bool _internal_has_camerarays() const;
  public:
  void clear_camerarays();
  const ::rustplus::AppCameraRays& camerarays() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppCameraRays* release_camerarays();
  ::rustplus::AppCameraRays* mutable_camerarays();
  void set_allocated_camerarays(::rustplus::AppCameraRays* camerarays);
  private:
  const ::rustplus::AppCameraRays& _internal_camerarays() const;
  ::rustplus::AppCameraRays* _internal_mutable_camerarays();
  public:
  void unsafe_arena_set_allocated_camerarays(
      ::rustplus::AppCameraRays* camerarays);
  ::rustplus::AppCameraRays* unsafe_arena_release_camerarays();

  // @@protoc_insertion_point(class_scope:rustplus.AppBroadcast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppTeamChanged* teamchanged_;
  ::rustplus::AppNewTeamMessage* newteammessage_;
  ::rustplus::AppEntityChanged* entitychanged_;
  ::rustplus::AppClanChanged* clanchanged_;
  ::rustplus::AppNewClanMessage* clanmessage_;
  ::rustplus::AppCameraRays* camerarays_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppEmpty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppEmpty) */ {
 public:
  inline AppEmpty() : AppEmpty(nullptr) {}
  ~AppEmpty() override;
  explicit constexpr AppEmpty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEmpty(const AppEmpty& from);
  AppEmpty(AppEmpty&& from) noexcept
    : AppEmpty() {
    *this = ::std::move(from);
  }

  inline AppEmpty& operator=(const AppEmpty& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEmpty& operator=(AppEmpty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEmpty& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppEmpty* internal_default_instance() {
    return reinterpret_cast<const AppEmpty*>(
               &_AppEmpty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AppEmpty& a, AppEmpty& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEmpty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEmpty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppEmpty* New() const final {
    return new AppEmpty();
  }

  AppEmpty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppEmpty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEmpty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppEmpty& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEmpty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppEmpty";
  }
  protected:
  explicit AppEmpty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rustplus.AppEmpty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppSendMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppSendMessage) */ {
 public:
  inline AppSendMessage() : AppSendMessage(nullptr) {}
  ~AppSendMessage() override;
  explicit constexpr AppSendMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppSendMessage(const AppSendMessage& from);
  AppSendMessage(AppSendMessage&& from) noexcept
    : AppSendMessage() {
    *this = ::std::move(from);
  }

  inline AppSendMessage& operator=(const AppSendMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppSendMessage& operator=(AppSendMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppSendMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppSendMessage* internal_default_instance() {
    return reinterpret_cast<const AppSendMessage*>(
               &_AppSendMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AppSendMessage& a, AppSendMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AppSendMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppSendMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppSendMessage* New() const final {
    return new AppSendMessage();
  }

  AppSendMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppSendMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppSendMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppSendMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppSendMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppSendMessage";
  }
  protected:
  explicit AppSendMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // required string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& m_iValue);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppSendMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppSetEntityValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppSetEntityValue) */ {
 public:
  inline AppSetEntityValue() : AppSetEntityValue(nullptr) {}
  ~AppSetEntityValue() override;
  explicit constexpr AppSetEntityValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppSetEntityValue(const AppSetEntityValue& from);
  AppSetEntityValue(AppSetEntityValue&& from) noexcept
    : AppSetEntityValue() {
    *this = ::std::move(from);
  }

  inline AppSetEntityValue& operator=(const AppSetEntityValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppSetEntityValue& operator=(AppSetEntityValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppSetEntityValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppSetEntityValue* internal_default_instance() {
    return reinterpret_cast<const AppSetEntityValue*>(
               &_AppSetEntityValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AppSetEntityValue& a, AppSetEntityValue& b) {
    a.Swap(&b);
  }
  inline void Swap(AppSetEntityValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppSetEntityValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppSetEntityValue* New() const final {
    return new AppSetEntityValue();
  }

  AppSetEntityValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppSetEntityValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppSetEntityValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppSetEntityValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppSetEntityValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppSetEntityValue";
  }
  protected:
  explicit AppSetEntityValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required bool value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool m_iValue() const;
  void set_value(bool m_iValue);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppSetEntityValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool value_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppPromoteToLeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppPromoteToLeader) */ {
 public:
  inline AppPromoteToLeader() : AppPromoteToLeader(nullptr) {}
  ~AppPromoteToLeader() override;
  explicit constexpr AppPromoteToLeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppPromoteToLeader(const AppPromoteToLeader& from);
  AppPromoteToLeader(AppPromoteToLeader&& from) noexcept
    : AppPromoteToLeader() {
    *this = ::std::move(from);
  }

  inline AppPromoteToLeader& operator=(const AppPromoteToLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppPromoteToLeader& operator=(AppPromoteToLeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppPromoteToLeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppPromoteToLeader* internal_default_instance() {
    return reinterpret_cast<const AppPromoteToLeader*>(
               &_AppPromoteToLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AppPromoteToLeader& a, AppPromoteToLeader& b) {
    a.Swap(&b);
  }
  inline void Swap(AppPromoteToLeader* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppPromoteToLeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppPromoteToLeader* New() const final {
    return new AppPromoteToLeader();
  }

  AppPromoteToLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppPromoteToLeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppPromoteToLeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppPromoteToLeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppPromoteToLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppPromoteToLeader";
  }
  protected:
  explicit AppPromoteToLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdFieldNumber = 1,
  };
  // required int64 steamId = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::int64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppPromoteToLeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 steamid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppGetNexusAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppGetNexusAuth) */ {
 public:
  inline AppGetNexusAuth() : AppGetNexusAuth(nullptr) {}
  ~AppGetNexusAuth() override;
  explicit constexpr AppGetNexusAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppGetNexusAuth(const AppGetNexusAuth& from);
  AppGetNexusAuth(AppGetNexusAuth&& from) noexcept
    : AppGetNexusAuth() {
    *this = ::std::move(from);
  }

  inline AppGetNexusAuth& operator=(const AppGetNexusAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppGetNexusAuth& operator=(AppGetNexusAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppGetNexusAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppGetNexusAuth* internal_default_instance() {
    return reinterpret_cast<const AppGetNexusAuth*>(
               &_AppGetNexusAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AppGetNexusAuth& a, AppGetNexusAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(AppGetNexusAuth* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppGetNexusAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppGetNexusAuth* New() const final {
    return new AppGetNexusAuth();
  }

  AppGetNexusAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppGetNexusAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppGetNexusAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppGetNexusAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppGetNexusAuth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppGetNexusAuth";
  }
  protected:
  explicit AppGetNexusAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppKeyFieldNumber = 1,
  };
  // required string appKey = 1;
  bool has_appkey() const;
  private:
  bool _internal_has_appkey() const;
  public:
  void clear_appkey();
  const std::string& appkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appkey();
  PROTOBUF_MUST_USE_RESULT std::string* release_appkey();
  void set_allocated_appkey(std::string* appkey);
  private:
  const std::string& _internal_appkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appkey(const std::string& m_iValue);
  std::string* _internal_mutable_appkey();
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppGetNexusAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appkey_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppSuccess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppSuccess) */ {
 public:
  inline AppSuccess() : AppSuccess(nullptr) {}
  ~AppSuccess() override;
  explicit constexpr AppSuccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppSuccess(const AppSuccess& from);
  AppSuccess(AppSuccess&& from) noexcept
    : AppSuccess() {
    *this = ::std::move(from);
  }

  inline AppSuccess& operator=(const AppSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppSuccess& operator=(AppSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppSuccess* internal_default_instance() {
    return reinterpret_cast<const AppSuccess*>(
               &_AppSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AppSuccess& a, AppSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(AppSuccess* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppSuccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppSuccess* New() const final {
    return new AppSuccess();
  }

  AppSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppSuccess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppSuccess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppSuccess& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppSuccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppSuccess";
  }
  protected:
  explicit AppSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rustplus.AppSuccess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppError) */ {
 public:
  inline AppError() : AppError(nullptr) {}
  ~AppError() override;
  explicit constexpr AppError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppError(const AppError& from);
  AppError(AppError&& from) noexcept
    : AppError() {
    *this = ::std::move(from);
  }

  inline AppError& operator=(const AppError& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppError& operator=(AppError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppError& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppError* internal_default_instance() {
    return reinterpret_cast<const AppError*>(
               &_AppError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AppError& a, AppError& b) {
    a.Swap(&b);
  }
  inline void Swap(AppError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppError* New() const final {
    return new AppError();
  }

  AppError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppError";
  }
  protected:
  explicit AppError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // required string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& m_iValue);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppFlag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppFlag) */ {
 public:
  inline AppFlag() : AppFlag(nullptr) {}
  ~AppFlag() override;
  explicit constexpr AppFlag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppFlag(const AppFlag& from);
  AppFlag(AppFlag&& from) noexcept
    : AppFlag() {
    *this = ::std::move(from);
  }

  inline AppFlag& operator=(const AppFlag& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppFlag& operator=(AppFlag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppFlag& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppFlag* internal_default_instance() {
    return reinterpret_cast<const AppFlag*>(
               &_AppFlag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AppFlag& a, AppFlag& b) {
    a.Swap(&b);
  }
  inline void Swap(AppFlag* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppFlag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppFlag* New() const final {
    return new AppFlag();
  }

  AppFlag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppFlag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppFlag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppFlag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppFlag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppFlag";
  }
  protected:
  explicit AppFlag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required bool value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool m_iValue() const;
  void set_value(bool m_iValue);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppFlag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool value_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppInfo) */ {
 public:
  inline AppInfo() : AppInfo(nullptr) {}
  ~AppInfo() override;
  explicit constexpr AppInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInfo(const AppInfo& from);
  AppInfo(AppInfo&& from) noexcept
    : AppInfo() {
    *this = ::std::move(from);
  }

  inline AppInfo& operator=(const AppInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInfo& operator=(AppInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInfo* internal_default_instance() {
    return reinterpret_cast<const AppInfo*>(
               &_AppInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AppInfo& a, AppInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppInfo* New() const final {
    return new AppInfo();
  }

  AppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppInfo";
  }
  protected:
  explicit AppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHeaderImageFieldNumber = 2,
    kUrlFieldNumber = 3,
    kMapFieldNumber = 4,
    kLogoImageFieldNumber = 12,
    kNexusFieldNumber = 13,
    kNexusZoneFieldNumber = 15,
    kMapSizeFieldNumber = 5,
    kWipeTimeFieldNumber = 6,
    kPlayersFieldNumber = 7,
    kMaxPlayersFieldNumber = 8,
    kQueuedPlayersFieldNumber = 9,
    kSeedFieldNumber = 10,
    kSaltFieldNumber = 11,
    kNexusIdFieldNumber = 14,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // required string headerImage = 2;
  bool has_headerimage() const;
  private:
  bool _internal_has_headerimage() const;
  public:
  void clear_headerimage();
  const std::string& headerimage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headerimage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headerimage();
  PROTOBUF_MUST_USE_RESULT std::string* release_headerimage();
  void set_allocated_headerimage(std::string* headerimage);
  private:
  const std::string& _internal_headerimage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headerimage(const std::string& m_iValue);
  std::string* _internal_mutable_headerimage();
  public:

  // required string url = 3;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& m_iValue);
  std::string* _internal_mutable_url();
  public:

  // required string map = 4;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const std::string& map() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map();
  PROTOBUF_MUST_USE_RESULT std::string* release_map();
  void set_allocated_map(std::string* map);
  private:
  const std::string& _internal_map() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map(const std::string& m_iValue);
  std::string* _internal_mutable_map();
  public:

  // optional string logoImage = 12;
  bool has_logoimage() const;
  private:
  bool _internal_has_logoimage() const;
  public:
  void clear_logoimage();
  const std::string& logoimage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logoimage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logoimage();
  PROTOBUF_MUST_USE_RESULT std::string* release_logoimage();
  void set_allocated_logoimage(std::string* logoimage);
  private:
  const std::string& _internal_logoimage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logoimage(const std::string& m_iValue);
  std::string* _internal_mutable_logoimage();
  public:

  // optional string nexus = 13;
  bool has_nexus() const;
  private:
  bool _internal_has_nexus() const;
  public:
  void clear_nexus();
  const std::string& nexus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nexus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nexus();
  PROTOBUF_MUST_USE_RESULT std::string* release_nexus();
  void set_allocated_nexus(std::string* nexus);
  private:
  const std::string& _internal_nexus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nexus(const std::string& m_iValue);
  std::string* _internal_mutable_nexus();
  public:

  // optional string nexusZone = 15;
  bool has_nexuszone() const;
  private:
  bool _internal_has_nexuszone() const;
  public:
  void clear_nexuszone();
  const std::string& nexuszone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nexuszone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nexuszone();
  PROTOBUF_MUST_USE_RESULT std::string* release_nexuszone();
  void set_allocated_nexuszone(std::string* nexuszone);
  private:
  const std::string& _internal_nexuszone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nexuszone(const std::string& m_iValue);
  std::string* _internal_mutable_nexuszone();
  public:

  // required uint32 mapSize = 5;
  bool has_mapsize() const;
  private:
  bool _internal_has_mapsize() const;
  public:
  void clear_mapsize();
  ::PROTOBUF_NAMESPACE_ID::uint32 mapsize() const;
  void set_mapsize(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mapsize() const;
  void _internal_set_mapsize(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required uint32 wipeTime = 6;
  bool has_wipetime() const;
  private:
  bool _internal_has_wipetime() const;
  public:
  void clear_wipetime();
  ::PROTOBUF_NAMESPACE_ID::uint32 wipetime() const;
  void set_wipetime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_wipetime() const;
  void _internal_set_wipetime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required uint32 players = 7;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  ::PROTOBUF_NAMESPACE_ID::uint32 players() const;
  void set_players(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_players() const;
  void _internal_set_players(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required uint32 maxPlayers = 8;
  bool has_maxplayers() const;
  private:
  bool _internal_has_maxplayers() const;
  public:
  void clear_maxplayers();
  ::PROTOBUF_NAMESPACE_ID::uint32 maxplayers() const;
  void set_maxplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_maxplayers() const;
  void _internal_set_maxplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required uint32 queuedPlayers = 9;
  bool has_queuedplayers() const;
  private:
  bool _internal_has_queuedplayers() const;
  public:
  void clear_queuedplayers();
  ::PROTOBUF_NAMESPACE_ID::uint32 queuedplayers() const;
  void set_queuedplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_queuedplayers() const;
  void _internal_set_queuedplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // optional uint32 seed = 10;
  bool has_seed() const;
  private:
  bool _internal_has_seed() const;
  public:
  void clear_seed();
  ::PROTOBUF_NAMESPACE_ID::uint32 seed() const;
  void set_seed(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seed() const;
  void _internal_set_seed(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // optional uint32 salt = 11;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  ::PROTOBUF_NAMESPACE_ID::uint32 salt() const;
  void set_salt(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_salt() const;
  void _internal_set_salt(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // optional int32 nexusId = 14;
  bool has_nexusid() const;
  private:
  bool _internal_has_nexusid() const;
  public:
  void clear_nexusid();
  ::PROTOBUF_NAMESPACE_ID::int32 nexusid() const;
  void set_nexusid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nexusid() const;
  void _internal_set_nexusid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headerimage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logoimage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nexus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nexuszone_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mapsize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 wipetime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 players_;
  ::PROTOBUF_NAMESPACE_ID::uint32 maxplayers_;
  ::PROTOBUF_NAMESPACE_ID::uint32 queuedplayers_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seed_;
  ::PROTOBUF_NAMESPACE_ID::uint32 salt_;
  ::PROTOBUF_NAMESPACE_ID::int32 nexusid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTime) */ {
 public:
  inline AppTime() : AppTime(nullptr) {}
  ~AppTime() override;
  explicit constexpr AppTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTime(const AppTime& from);
  AppTime(AppTime&& from) noexcept
    : AppTime() {
    *this = ::std::move(from);
  }

  inline AppTime& operator=(const AppTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTime& operator=(AppTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTime* internal_default_instance() {
    return reinterpret_cast<const AppTime*>(
               &_AppTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AppTime& a, AppTime& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTime* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTime* New() const final {
    return new AppTime();
  }

  AppTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTime& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTime";
  }
  protected:
  explicit AppTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayLengthMinutesFieldNumber = 1,
    kTimeScaleFieldNumber = 2,
    kSunriseFieldNumber = 3,
    kSunsetFieldNumber = 4,
    kTimeFieldNumber = 5,
  };
  // required float dayLengthMinutes = 1;
  bool has_daylengthminutes() const;
  private:
  bool _internal_has_daylengthminutes() const;
  public:
  void clear_daylengthminutes();
  float daylengthminutes() const;
  void set_daylengthminutes(float m_iValue);
  private:
  float _internal_daylengthminutes() const;
  void _internal_set_daylengthminutes(float m_iValue);
  public:

  // required float timeScale = 2;
  bool has_timescale() const;
  private:
  bool _internal_has_timescale() const;
  public:
  void clear_timescale();
  float timescale() const;
  void set_timescale(float m_iValue);
  private:
  float _internal_timescale() const;
  void _internal_set_timescale(float m_iValue);
  public:

  // required float sunrise = 3;
  bool has_sunrise() const;
  private:
  bool _internal_has_sunrise() const;
  public:
  void clear_sunrise();
  float sunrise() const;
  void set_sunrise(float m_iValue);
  private:
  float _internal_sunrise() const;
  void _internal_set_sunrise(float m_iValue);
  public:

  // required float sunset = 4;
  bool has_sunset() const;
  private:
  bool _internal_has_sunset() const;
  public:
  void clear_sunset();
  float sunset() const;
  void set_sunset(float m_iValue);
  private:
  float _internal_sunset() const;
  void _internal_set_sunset(float m_iValue);
  public:

  // required float time = 5;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  float time() const;
  void set_time(float m_iValue);
  private:
  float _internal_time() const;
  void _internal_set_time(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppTime)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float daylengthminutes_;
  float timescale_;
  float sunrise_;
  float sunset_;
  float time_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppMap_Monument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppMap.Monument) */ {
 public:
  inline AppMap_Monument() : AppMap_Monument(nullptr) {}
  ~AppMap_Monument() override;
  explicit constexpr AppMap_Monument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMap_Monument(const AppMap_Monument& from);
  AppMap_Monument(AppMap_Monument&& from) noexcept
    : AppMap_Monument() {
    *this = ::std::move(from);
  }

  inline AppMap_Monument& operator=(const AppMap_Monument& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMap_Monument& operator=(AppMap_Monument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMap_Monument& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMap_Monument* internal_default_instance() {
    return reinterpret_cast<const AppMap_Monument*>(
               &_AppMap_Monument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AppMap_Monument& a, AppMap_Monument& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMap_Monument* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMap_Monument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppMap_Monument* New() const final {
    return new AppMap_Monument();
  }

  AppMap_Monument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppMap_Monument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMap_Monument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMap_Monument& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMap_Monument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppMap.Monument";
  }
  protected:
  explicit AppMap_Monument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // required string token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& m_iValue);
  std::string* _internal_mutable_token();
  public:

  // required float x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // required float y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppMap.Monument)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  float x_;
  float y_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppMap) */ {
 public:
  inline AppMap() : AppMap(nullptr) {}
  ~AppMap() override;
  explicit constexpr AppMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMap(const AppMap& from);
  AppMap(AppMap&& from) noexcept
    : AppMap() {
    *this = ::std::move(from);
  }

  inline AppMap& operator=(const AppMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMap& operator=(AppMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMap* internal_default_instance() {
    return reinterpret_cast<const AppMap*>(
               &_AppMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AppMap& a, AppMap& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppMap* New() const final {
    return new AppMap();
  }

  AppMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppMap";
  }
  protected:
  explicit AppMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AppMap_Monument Monument;

  // accessors -------------------------------------------------------

  enum : int {
    kMonumentsFieldNumber = 5,
    kJpgImageFieldNumber = 3,
    kBackgroundFieldNumber = 6,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kOceanMarginFieldNumber = 4,
  };
  // repeated .rustplus.AppMap.Monument monuments = 5;
  int monuments_size() const;
  private:
  int _internal_monuments_size() const;
  public:
  void clear_monuments();
  ::rustplus::AppMap_Monument* mutable_monuments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMap_Monument >*
      mutable_monuments();
  private:
  const ::rustplus::AppMap_Monument& _internal_monuments(int index) const;
  ::rustplus::AppMap_Monument* _internal_add_monuments();
  public:
  const ::rustplus::AppMap_Monument& monuments(int index) const;
  ::rustplus::AppMap_Monument* add_monuments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMap_Monument >&
      monuments() const;

  // required bytes jpgImage = 3;
  bool has_jpgimage() const;
  private:
  bool _internal_has_jpgimage() const;
  public:
  void clear_jpgimage();
  const std::string& jpgimage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpgimage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpgimage();
  PROTOBUF_MUST_USE_RESULT std::string* release_jpgimage();
  void set_allocated_jpgimage(std::string* jpgimage);
  private:
  const std::string& _internal_jpgimage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpgimage(const std::string& m_iValue);
  std::string* _internal_mutable_jpgimage();
  public:

  // optional string background = 6;
  bool has_background() const;
  private:
  bool _internal_has_background() const;
  public:
  void clear_background();
  const std::string& background() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_background(ArgT0&& arg0, ArgT... args);
  std::string* mutable_background();
  PROTOBUF_MUST_USE_RESULT std::string* release_background();
  void set_allocated_background(std::string* background);
  private:
  const std::string& _internal_background() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_background(const std::string& m_iValue);
  std::string* _internal_mutable_background();
  public:

  // required uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required int32 oceanMargin = 4;
  bool has_oceanmargin() const;
  private:
  bool _internal_has_oceanmargin() const;
  public:
  void clear_oceanmargin();
  ::PROTOBUF_NAMESPACE_ID::int32 oceanmargin() const;
  void set_oceanmargin(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oceanmargin() const;
  void _internal_set_oceanmargin(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppMap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMap_Monument > monuments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpgimage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr background_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 oceanmargin_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppEntityInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppEntityInfo) */ {
 public:
  inline AppEntityInfo() : AppEntityInfo(nullptr) {}
  ~AppEntityInfo() override;
  explicit constexpr AppEntityInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEntityInfo(const AppEntityInfo& from);
  AppEntityInfo(AppEntityInfo&& from) noexcept
    : AppEntityInfo() {
    *this = ::std::move(from);
  }

  inline AppEntityInfo& operator=(const AppEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEntityInfo& operator=(AppEntityInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEntityInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppEntityInfo* internal_default_instance() {
    return reinterpret_cast<const AppEntityInfo*>(
               &_AppEntityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AppEntityInfo& a, AppEntityInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEntityInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEntityInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppEntityInfo* New() const final {
    return new AppEntityInfo();
  }

  AppEntityInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppEntityInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEntityInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppEntityInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEntityInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppEntityInfo";
  }
  protected:
  explicit AppEntityInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // required .rustplus.AppEntityPayload payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::rustplus::AppEntityPayload& payload() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEntityPayload* release_payload();
  ::rustplus::AppEntityPayload* mutable_payload();
  void set_allocated_payload(::rustplus::AppEntityPayload* payload);
  private:
  const ::rustplus::AppEntityPayload& _internal_payload() const;
  ::rustplus::AppEntityPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::rustplus::AppEntityPayload* payload);
  ::rustplus::AppEntityPayload* unsafe_arena_release_payload();

  // required .rustplus.AppEntityType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::rustplus::AppEntityType type() const;
  void set_type(::rustplus::AppEntityType m_iValue);
  private:
  ::rustplus::AppEntityType _internal_type() const;
  void _internal_set_type(::rustplus::AppEntityType m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppEntityInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppEntityPayload* payload_;
  int type_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppEntityPayload_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppEntityPayload.Item) */ {
 public:
  inline AppEntityPayload_Item() : AppEntityPayload_Item(nullptr) {}
  ~AppEntityPayload_Item() override;
  explicit constexpr AppEntityPayload_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEntityPayload_Item(const AppEntityPayload_Item& from);
  AppEntityPayload_Item(AppEntityPayload_Item&& from) noexcept
    : AppEntityPayload_Item() {
    *this = ::std::move(from);
  }

  inline AppEntityPayload_Item& operator=(const AppEntityPayload_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEntityPayload_Item& operator=(AppEntityPayload_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEntityPayload_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppEntityPayload_Item* internal_default_instance() {
    return reinterpret_cast<const AppEntityPayload_Item*>(
               &_AppEntityPayload_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AppEntityPayload_Item& a, AppEntityPayload_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEntityPayload_Item* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEntityPayload_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppEntityPayload_Item* New() const final {
    return new AppEntityPayload_Item();
  }

  AppEntityPayload_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppEntityPayload_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEntityPayload_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppEntityPayload_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEntityPayload_Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppEntityPayload.Item";
  }
  protected:
  explicit AppEntityPayload_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kItemIsBlueprintFieldNumber = 3,
  };
  // required int32 itemId = 1;
  bool has_itemid() const;
  private:
  bool _internal_has_itemid() const;
  public:
  void clear_itemid();
  ::PROTOBUF_NAMESPACE_ID::int32 itemid() const;
  void set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_itemid() const;
  void _internal_set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 quantity = 2;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  ::PROTOBUF_NAMESPACE_ID::int32 quantity() const;
  void set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_quantity() const;
  void _internal_set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required bool itemIsBlueprint = 3;
  bool has_itemisblueprint() const;
  private:
  bool _internal_has_itemisblueprint() const;
  public:
  void clear_itemisblueprint();
  bool itemisblueprint() const;
  void set_itemisblueprint(bool m_iValue);
  private:
  bool _internal_itemisblueprint() const;
  void _internal_set_itemisblueprint(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppEntityPayload.Item)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 itemid_;
  ::PROTOBUF_NAMESPACE_ID::int32 quantity_;
  bool itemisblueprint_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppEntityPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppEntityPayload) */ {
 public:
  inline AppEntityPayload() : AppEntityPayload(nullptr) {}
  ~AppEntityPayload() override;
  explicit constexpr AppEntityPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEntityPayload(const AppEntityPayload& from);
  AppEntityPayload(AppEntityPayload&& from) noexcept
    : AppEntityPayload() {
    *this = ::std::move(from);
  }

  inline AppEntityPayload& operator=(const AppEntityPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEntityPayload& operator=(AppEntityPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEntityPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppEntityPayload* internal_default_instance() {
    return reinterpret_cast<const AppEntityPayload*>(
               &_AppEntityPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AppEntityPayload& a, AppEntityPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEntityPayload* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEntityPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppEntityPayload* New() const final {
    return new AppEntityPayload();
  }

  AppEntityPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppEntityPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEntityPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppEntityPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEntityPayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppEntityPayload";
  }
  protected:
  explicit AppEntityPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AppEntityPayload_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kValueFieldNumber = 1,
    kHasProtectionFieldNumber = 4,
    kCapacityFieldNumber = 3,
    kProtectionExpiryFieldNumber = 5,
  };
  // repeated .rustplus.AppEntityPayload.Item items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::rustplus::AppEntityPayload_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppEntityPayload_Item >*
      mutable_items();
  private:
  const ::rustplus::AppEntityPayload_Item& _internal_items(int index) const;
  ::rustplus::AppEntityPayload_Item* _internal_add_items();
  public:
  const ::rustplus::AppEntityPayload_Item& items(int index) const;
  ::rustplus::AppEntityPayload_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppEntityPayload_Item >&
      items() const;

  // optional bool value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool m_iValue() const;
  void set_value(bool m_iValue);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool m_iValue);
  public:

  // optional bool hasProtection = 4;
  bool has_hasprotection() const;
  private:
  bool _internal_has_hasprotection() const;
  public:
  void clear_hasprotection();
  bool hasprotection() const;
  void set_hasprotection(bool m_iValue);
  private:
  bool _internal_hasprotection() const;
  void _internal_set_hasprotection(bool m_iValue);
  public:

  // optional int32 capacity = 3;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  ::PROTOBUF_NAMESPACE_ID::int32 capacity() const;
  void set_capacity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_capacity() const;
  void _internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // optional uint32 protectionExpiry = 5;
  bool has_protectionexpiry() const;
  private:
  bool _internal_has_protectionexpiry() const;
  public:
  void clear_protectionexpiry();
  ::PROTOBUF_NAMESPACE_ID::uint32 protectionexpiry() const;
  void set_protectionexpiry(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_protectionexpiry() const;
  void _internal_set_protectionexpiry(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppEntityPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppEntityPayload_Item > items_;
  bool value_;
  bool hasprotection_;
  ::PROTOBUF_NAMESPACE_ID::int32 capacity_;
  ::PROTOBUF_NAMESPACE_ID::uint32 protectionexpiry_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTeamInfo_Member final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTeamInfo.Member) */ {
 public:
  inline AppTeamInfo_Member() : AppTeamInfo_Member(nullptr) {}
  ~AppTeamInfo_Member() override;
  explicit constexpr AppTeamInfo_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTeamInfo_Member(const AppTeamInfo_Member& from);
  AppTeamInfo_Member(AppTeamInfo_Member&& from) noexcept
    : AppTeamInfo_Member() {
    *this = ::std::move(from);
  }

  inline AppTeamInfo_Member& operator=(const AppTeamInfo_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTeamInfo_Member& operator=(AppTeamInfo_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTeamInfo_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTeamInfo_Member* internal_default_instance() {
    return reinterpret_cast<const AppTeamInfo_Member*>(
               &_AppTeamInfo_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(AppTeamInfo_Member& a, AppTeamInfo_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTeamInfo_Member* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTeamInfo_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTeamInfo_Member* New() const final {
    return new AppTeamInfo_Member();
  }

  AppTeamInfo_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTeamInfo_Member>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTeamInfo_Member& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTeamInfo_Member& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTeamInfo_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTeamInfo.Member";
  }
  protected:
  explicit AppTeamInfo_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSteamIdFieldNumber = 1,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kSpawnTimeFieldNumber = 6,
    kIsOnlineFieldNumber = 5,
    kIsAliveFieldNumber = 7,
    kDeathTimeFieldNumber = 8,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // required uint64 steamId = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // required float x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // required float y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // required uint32 spawnTime = 6;
  bool has_spawntime() const;
  private:
  bool _internal_has_spawntime() const;
  public:
  void clear_spawntime();
  ::PROTOBUF_NAMESPACE_ID::uint32 spawntime() const;
  void set_spawntime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_spawntime() const;
  void _internal_set_spawntime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required bool isOnline = 5;
  bool has_isonline() const;
  private:
  bool _internal_has_isonline() const;
  public:
  void clear_isonline();
  bool isonline() const;
  void set_isonline(bool m_iValue);
  private:
  bool _internal_isonline() const;
  void _internal_set_isonline(bool m_iValue);
  public:

  // required bool isAlive = 7;
  bool has_isalive() const;
  private:
  bool _internal_has_isalive() const;
  public:
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool m_iValue);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool m_iValue);
  public:

  // required uint32 deathTime = 8;
  bool has_deathtime() const;
  private:
  bool _internal_has_deathtime() const;
  public:
  void clear_deathtime();
  ::PROTOBUF_NAMESPACE_ID::uint32 deathtime() const;
  void set_deathtime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_deathtime() const;
  void _internal_set_deathtime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppTeamInfo.Member)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid_;
  float x_;
  float y_;
  ::PROTOBUF_NAMESPACE_ID::uint32 spawntime_;
  bool isonline_;
  bool isalive_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deathtime_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTeamInfo_Note final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTeamInfo.Note) */ {
 public:
  inline AppTeamInfo_Note() : AppTeamInfo_Note(nullptr) {}
  ~AppTeamInfo_Note() override;
  explicit constexpr AppTeamInfo_Note(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTeamInfo_Note(const AppTeamInfo_Note& from);
  AppTeamInfo_Note(AppTeamInfo_Note&& from) noexcept
    : AppTeamInfo_Note() {
    *this = ::std::move(from);
  }

  inline AppTeamInfo_Note& operator=(const AppTeamInfo_Note& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTeamInfo_Note& operator=(AppTeamInfo_Note&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTeamInfo_Note& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTeamInfo_Note* internal_default_instance() {
    return reinterpret_cast<const AppTeamInfo_Note*>(
               &_AppTeamInfo_Note_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AppTeamInfo_Note& a, AppTeamInfo_Note& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTeamInfo_Note* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTeamInfo_Note* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTeamInfo_Note* New() const final {
    return new AppTeamInfo_Note();
  }

  AppTeamInfo_Note* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTeamInfo_Note>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTeamInfo_Note& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTeamInfo_Note& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTeamInfo_Note* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTeamInfo.Note";
  }
  protected:
  explicit AppTeamInfo_Note(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // required int32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required float x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // required float y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppTeamInfo.Note)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  float x_;
  float y_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTeamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTeamInfo) */ {
 public:
  inline AppTeamInfo() : AppTeamInfo(nullptr) {}
  ~AppTeamInfo() override;
  explicit constexpr AppTeamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTeamInfo(const AppTeamInfo& from);
  AppTeamInfo(AppTeamInfo&& from) noexcept
    : AppTeamInfo() {
    *this = ::std::move(from);
  }

  inline AppTeamInfo& operator=(const AppTeamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTeamInfo& operator=(AppTeamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTeamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTeamInfo* internal_default_instance() {
    return reinterpret_cast<const AppTeamInfo*>(
               &_AppTeamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(AppTeamInfo& a, AppTeamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTeamInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTeamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTeamInfo* New() const final {
    return new AppTeamInfo();
  }

  AppTeamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTeamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTeamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTeamInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTeamInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTeamInfo";
  }
  protected:
  explicit AppTeamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AppTeamInfo_Member Member;
  typedef AppTeamInfo_Note Note;

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kMapNotesFieldNumber = 3,
    kLeaderMapNotesFieldNumber = 4,
    kLeaderSteamIdFieldNumber = 1,
  };
  // repeated .rustplus.AppTeamInfo.Member members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::rustplus::AppTeamInfo_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Member >*
      mutable_members();
  private:
  const ::rustplus::AppTeamInfo_Member& _internal_members(int index) const;
  ::rustplus::AppTeamInfo_Member* _internal_add_members();
  public:
  const ::rustplus::AppTeamInfo_Member& members(int index) const;
  ::rustplus::AppTeamInfo_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Member >&
      members() const;

  // repeated .rustplus.AppTeamInfo.Note mapNotes = 3;
  int mapnotes_size() const;
  private:
  int _internal_mapnotes_size() const;
  public:
  void clear_mapnotes();
  ::rustplus::AppTeamInfo_Note* mutable_mapnotes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >*
      mutable_mapnotes();
  private:
  const ::rustplus::AppTeamInfo_Note& _internal_mapnotes(int index) const;
  ::rustplus::AppTeamInfo_Note* _internal_add_mapnotes();
  public:
  const ::rustplus::AppTeamInfo_Note& mapnotes(int index) const;
  ::rustplus::AppTeamInfo_Note* add_mapnotes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >&
      mapnotes() const;

  // repeated .rustplus.AppTeamInfo.Note leaderMapNotes = 4;
  int leadermapnotes_size() const;
  private:
  int _internal_leadermapnotes_size() const;
  public:
  void clear_leadermapnotes();
  ::rustplus::AppTeamInfo_Note* mutable_leadermapnotes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >*
      mutable_leadermapnotes();
  private:
  const ::rustplus::AppTeamInfo_Note& _internal_leadermapnotes(int index) const;
  ::rustplus::AppTeamInfo_Note* _internal_add_leadermapnotes();
  public:
  const ::rustplus::AppTeamInfo_Note& leadermapnotes(int index) const;
  ::rustplus::AppTeamInfo_Note* add_leadermapnotes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >&
      leadermapnotes() const;

  // required uint64 leaderSteamId = 1;
  bool has_leadersteamid() const;
  private:
  bool _internal_has_leadersteamid() const;
  public:
  void clear_leadersteamid();
  ::PROTOBUF_NAMESPACE_ID::uint64 leadersteamid() const;
  void set_leadersteamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leadersteamid() const;
  void _internal_set_leadersteamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppTeamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Member > members_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note > mapnotes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note > leadermapnotes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leadersteamid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTeamMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTeamMessage) */ {
 public:
  inline AppTeamMessage() : AppTeamMessage(nullptr) {}
  ~AppTeamMessage() override;
  explicit constexpr AppTeamMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTeamMessage(const AppTeamMessage& from);
  AppTeamMessage(AppTeamMessage&& from) noexcept
    : AppTeamMessage() {
    *this = ::std::move(from);
  }

  inline AppTeamMessage& operator=(const AppTeamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTeamMessage& operator=(AppTeamMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTeamMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTeamMessage* internal_default_instance() {
    return reinterpret_cast<const AppTeamMessage*>(
               &_AppTeamMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AppTeamMessage& a, AppTeamMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTeamMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTeamMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTeamMessage* New() const final {
    return new AppTeamMessage();
  }

  AppTeamMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTeamMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTeamMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTeamMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTeamMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTeamMessage";
  }
  protected:
  explicit AppTeamMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kColorFieldNumber = 4,
    kSteamIdFieldNumber = 1,
    kTimeFieldNumber = 5,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // required string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& m_iValue);
  std::string* _internal_mutable_message();
  public:

  // required string color = 4;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_MUST_USE_RESULT std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& m_iValue);
  std::string* _internal_mutable_color();
  public:

  // required uint64 steamId = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // required uint32 time = 5;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppTeamMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTeamChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTeamChat) */ {
 public:
  inline AppTeamChat() : AppTeamChat(nullptr) {}
  ~AppTeamChat() override;
  explicit constexpr AppTeamChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTeamChat(const AppTeamChat& from);
  AppTeamChat(AppTeamChat&& from) noexcept
    : AppTeamChat() {
    *this = ::std::move(from);
  }

  inline AppTeamChat& operator=(const AppTeamChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTeamChat& operator=(AppTeamChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTeamChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTeamChat* internal_default_instance() {
    return reinterpret_cast<const AppTeamChat*>(
               &_AppTeamChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AppTeamChat& a, AppTeamChat& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTeamChat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTeamChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTeamChat* New() const final {
    return new AppTeamChat();
  }

  AppTeamChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTeamChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTeamChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTeamChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTeamChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTeamChat";
  }
  protected:
  explicit AppTeamChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .rustplus.AppTeamMessage messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::rustplus::AppTeamMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamMessage >*
      mutable_messages();
  private:
  const ::rustplus::AppTeamMessage& _internal_messages(int index) const;
  ::rustplus::AppTeamMessage* _internal_add_messages();
  public:
  const ::rustplus::AppTeamMessage& messages(int index) const;
  ::rustplus::AppTeamMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:rustplus.AppTeamChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamMessage > messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppMarker_SellOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppMarker.SellOrder) */ {
 public:
  inline AppMarker_SellOrder() : AppMarker_SellOrder(nullptr) {}
  ~AppMarker_SellOrder() override;
  explicit constexpr AppMarker_SellOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMarker_SellOrder(const AppMarker_SellOrder& from);
  AppMarker_SellOrder(AppMarker_SellOrder&& from) noexcept
    : AppMarker_SellOrder() {
    *this = ::std::move(from);
  }

  inline AppMarker_SellOrder& operator=(const AppMarker_SellOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMarker_SellOrder& operator=(AppMarker_SellOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMarker_SellOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMarker_SellOrder* internal_default_instance() {
    return reinterpret_cast<const AppMarker_SellOrder*>(
               &_AppMarker_SellOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(AppMarker_SellOrder& a, AppMarker_SellOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMarker_SellOrder* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMarker_SellOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppMarker_SellOrder* New() const final {
    return new AppMarker_SellOrder();
  }

  AppMarker_SellOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppMarker_SellOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMarker_SellOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMarker_SellOrder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMarker_SellOrder* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppMarker.SellOrder";
  }
  protected:
  explicit AppMarker_SellOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kCurrencyIdFieldNumber = 3,
    kCostPerItemFieldNumber = 4,
    kAmountInStockFieldNumber = 5,
    kItemIsBlueprintFieldNumber = 6,
    kCurrencyIsBlueprintFieldNumber = 7,
    kItemConditionFieldNumber = 8,
    kItemConditionMaxFieldNumber = 9,
  };
  // required int32 itemId = 1;
  bool has_itemid() const;
  private:
  bool _internal_has_itemid() const;
  public:
  void clear_itemid();
  ::PROTOBUF_NAMESPACE_ID::int32 itemid() const;
  void set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_itemid() const;
  void _internal_set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 quantity = 2;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  ::PROTOBUF_NAMESPACE_ID::int32 quantity() const;
  void set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_quantity() const;
  void _internal_set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 currencyId = 3;
  bool has_currencyid() const;
  private:
  bool _internal_has_currencyid() const;
  public:
  void clear_currencyid();
  ::PROTOBUF_NAMESPACE_ID::int32 currencyid() const;
  void set_currencyid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_currencyid() const;
  void _internal_set_currencyid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 costPerItem = 4;
  bool has_costperitem() const;
  private:
  bool _internal_has_costperitem() const;
  public:
  void clear_costperitem();
  ::PROTOBUF_NAMESPACE_ID::int32 costperitem() const;
  void set_costperitem(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_costperitem() const;
  void _internal_set_costperitem(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 amountInStock = 5;
  bool has_amountinstock() const;
  private:
  bool _internal_has_amountinstock() const;
  public:
  void clear_amountinstock();
  ::PROTOBUF_NAMESPACE_ID::int32 amountinstock() const;
  void set_amountinstock(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_amountinstock() const;
  void _internal_set_amountinstock(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required bool itemIsBlueprint = 6;
  bool has_itemisblueprint() const;
  private:
  bool _internal_has_itemisblueprint() const;
  public:
  void clear_itemisblueprint();
  bool itemisblueprint() const;
  void set_itemisblueprint(bool m_iValue);
  private:
  bool _internal_itemisblueprint() const;
  void _internal_set_itemisblueprint(bool m_iValue);
  public:

  // required bool currencyIsBlueprint = 7;
  bool has_currencyisblueprint() const;
  private:
  bool _internal_has_currencyisblueprint() const;
  public:
  void clear_currencyisblueprint();
  bool currencyisblueprint() const;
  void set_currencyisblueprint(bool m_iValue);
  private:
  bool _internal_currencyisblueprint() const;
  void _internal_set_currencyisblueprint(bool m_iValue);
  public:

  // optional float itemCondition = 8;
  bool has_itemcondition() const;
  private:
  bool _internal_has_itemcondition() const;
  public:
  void clear_itemcondition();
  float itemcondition() const;
  void set_itemcondition(float m_iValue);
  private:
  float _internal_itemcondition() const;
  void _internal_set_itemcondition(float m_iValue);
  public:

  // optional float itemConditionMax = 9;
  bool has_itemconditionmax() const;
  private:
  bool _internal_has_itemconditionmax() const;
  public:
  void clear_itemconditionmax();
  float itemconditionmax() const;
  void set_itemconditionmax(float m_iValue);
  private:
  float _internal_itemconditionmax() const;
  void _internal_set_itemconditionmax(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppMarker.SellOrder)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 itemid_;
  ::PROTOBUF_NAMESPACE_ID::int32 quantity_;
  ::PROTOBUF_NAMESPACE_ID::int32 currencyid_;
  ::PROTOBUF_NAMESPACE_ID::int32 costperitem_;
  ::PROTOBUF_NAMESPACE_ID::int32 amountinstock_;
  bool itemisblueprint_;
  bool currencyisblueprint_;
  float itemcondition_;
  float itemconditionmax_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppMarker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppMarker) */ {
 public:
  inline AppMarker() : AppMarker(nullptr) {}
  ~AppMarker() override;
  explicit constexpr AppMarker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMarker(const AppMarker& from);
  AppMarker(AppMarker&& from) noexcept
    : AppMarker() {
    *this = ::std::move(from);
  }

  inline AppMarker& operator=(const AppMarker& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMarker& operator=(AppMarker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMarker& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMarker* internal_default_instance() {
    return reinterpret_cast<const AppMarker*>(
               &_AppMarker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(AppMarker& a, AppMarker& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMarker* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMarker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppMarker* New() const final {
    return new AppMarker();
  }

  AppMarker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppMarker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMarker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMarker& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMarker* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppMarker";
  }
  protected:
  explicit AppMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AppMarker_SellOrder SellOrder;

  // accessors -------------------------------------------------------

  enum : int {
    kSellOrdersFieldNumber = 13,
    kNameFieldNumber = 11,
    kColor1FieldNumber = 8,
    kColor2FieldNumber = 9,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kSteamIdFieldNumber = 5,
    kRotationFieldNumber = 6,
    kRadiusFieldNumber = 7,
    kAlphaFieldNumber = 10,
    kOutOfStockFieldNumber = 12,
  };
  // repeated .rustplus.AppMarker.SellOrder sellOrders = 13;
  int sellorders_size() const;
  private:
  int _internal_sellorders_size() const;
  public:
  void clear_sellorders();
  ::rustplus::AppMarker_SellOrder* mutable_sellorders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker_SellOrder >*
      mutable_sellorders();
  private:
  const ::rustplus::AppMarker_SellOrder& _internal_sellorders(int index) const;
  ::rustplus::AppMarker_SellOrder* _internal_add_sellorders();
  public:
  const ::rustplus::AppMarker_SellOrder& sellorders(int index) const;
  ::rustplus::AppMarker_SellOrder* add_sellorders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker_SellOrder >&
      sellorders() const;

  // optional string name = 11;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // optional .rustplus.Vector4 color1 = 8;
  bool has_color1() const;
  private:
  bool _internal_has_color1() const;
  public:
  void clear_color1();
  const ::rustplus::Vector4& color1() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector4* release_color1();
  ::rustplus::Vector4* mutable_color1();
  void set_allocated_color1(::rustplus::Vector4* color1);
  private:
  const ::rustplus::Vector4& _internal_color1() const;
  ::rustplus::Vector4* _internal_mutable_color1();
  public:
  void unsafe_arena_set_allocated_color1(
      ::rustplus::Vector4* color1);
  ::rustplus::Vector4* unsafe_arena_release_color1();

  // optional .rustplus.Vector4 color2 = 9;
  bool has_color2() const;
  private:
  bool _internal_has_color2() const;
  public:
  void clear_color2();
  const ::rustplus::Vector4& color2() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector4* release_color2();
  ::rustplus::Vector4* mutable_color2();
  void set_allocated_color2(::rustplus::Vector4* color2);
  private:
  const ::rustplus::Vector4& _internal_color2() const;
  ::rustplus::Vector4* _internal_mutable_color2();
  public:
  void unsafe_arena_set_allocated_color2(
      ::rustplus::Vector4* color2);
  ::rustplus::Vector4* unsafe_arena_release_color2();

  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required .rustplus.AppMarkerType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::rustplus::AppMarkerType type() const;
  void set_type(::rustplus::AppMarkerType m_iValue);
  private:
  ::rustplus::AppMarkerType _internal_type() const;
  void _internal_set_type(::rustplus::AppMarkerType m_iValue);
  public:

  // required float x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float m_iValue);
  private:
  float _internal_x() const;
  void _internal_set_x(float m_iValue);
  public:

  // required float y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float m_iValue);
  private:
  float _internal_y() const;
  void _internal_set_y(float m_iValue);
  public:

  // optional uint64 steamId = 5;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // optional float rotation = 6;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  float rotation() const;
  void set_rotation(float m_iValue);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float m_iValue);
  public:

  // optional float radius = 7;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float m_iValue);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float m_iValue);
  public:

  // optional float alpha = 10;
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  float alpha() const;
  void set_alpha(float m_iValue);
  private:
  float _internal_alpha() const;
  void _internal_set_alpha(float m_iValue);
  public:

  // optional bool outOfStock = 12;
  bool has_outofstock() const;
  private:
  bool _internal_has_outofstock() const;
  public:
  void clear_outofstock();
  bool outofstock() const;
  void set_outofstock(bool m_iValue);
  private:
  bool _internal_outofstock() const;
  void _internal_set_outofstock(bool m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppMarker)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker_SellOrder > sellorders_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::rustplus::Vector4* color1_;
  ::rustplus::Vector4* color2_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int type_;
  float x_;
  float y_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid_;
  float rotation_;
  float radius_;
  float alpha_;
  bool outofstock_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppMapMarkers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppMapMarkers) */ {
 public:
  inline AppMapMarkers() : AppMapMarkers(nullptr) {}
  ~AppMapMarkers() override;
  explicit constexpr AppMapMarkers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMapMarkers(const AppMapMarkers& from);
  AppMapMarkers(AppMapMarkers&& from) noexcept
    : AppMapMarkers() {
    *this = ::std::move(from);
  }

  inline AppMapMarkers& operator=(const AppMapMarkers& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMapMarkers& operator=(AppMapMarkers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMapMarkers& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMapMarkers* internal_default_instance() {
    return reinterpret_cast<const AppMapMarkers*>(
               &_AppMapMarkers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(AppMapMarkers& a, AppMapMarkers& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMapMarkers* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMapMarkers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppMapMarkers* New() const final {
    return new AppMapMarkers();
  }

  AppMapMarkers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppMapMarkers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMapMarkers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMapMarkers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMapMarkers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppMapMarkers";
  }
  protected:
  explicit AppMapMarkers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarkersFieldNumber = 1,
  };
  // repeated .rustplus.AppMarker markers = 1;
  int markers_size() const;
  private:
  int _internal_markers_size() const;
  public:
  void clear_markers();
  ::rustplus::AppMarker* mutable_markers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker >*
      mutable_markers();
  private:
  const ::rustplus::AppMarker& _internal_markers(int index) const;
  ::rustplus::AppMarker* _internal_add_markers();
  public:
  const ::rustplus::AppMarker& markers(int index) const;
  ::rustplus::AppMarker* add_markers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker >&
      markers() const;

  // @@protoc_insertion_point(class_scope:rustplus.AppMapMarkers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker > markers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppClanInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppClanInfo) */ {
 public:
  inline AppClanInfo() : AppClanInfo(nullptr) {}
  ~AppClanInfo() override;
  explicit constexpr AppClanInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppClanInfo(const AppClanInfo& from);
  AppClanInfo(AppClanInfo&& from) noexcept
    : AppClanInfo() {
    *this = ::std::move(from);
  }

  inline AppClanInfo& operator=(const AppClanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppClanInfo& operator=(AppClanInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppClanInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppClanInfo* internal_default_instance() {
    return reinterpret_cast<const AppClanInfo*>(
               &_AppClanInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AppClanInfo& a, AppClanInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppClanInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppClanInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppClanInfo* New() const final {
    return new AppClanInfo();
  }

  AppClanInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppClanInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppClanInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppClanInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppClanInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppClanInfo";
  }
  protected:
  explicit AppClanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClanInfoFieldNumber = 1,
  };
  // optional .rustplus.ClanInfo clanInfo = 1;
  bool has_claninfo() const;
  private:
  bool _internal_has_claninfo() const;
  public:
  void clear_claninfo();
  const ::rustplus::ClanInfo& claninfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::ClanInfo* release_claninfo();
  ::rustplus::ClanInfo* mutable_claninfo();
  void set_allocated_claninfo(::rustplus::ClanInfo* claninfo);
  private:
  const ::rustplus::ClanInfo& _internal_claninfo() const;
  ::rustplus::ClanInfo* _internal_mutable_claninfo();
  public:
  void unsafe_arena_set_allocated_claninfo(
      ::rustplus::ClanInfo* claninfo);
  ::rustplus::ClanInfo* unsafe_arena_release_claninfo();

  // @@protoc_insertion_point(class_scope:rustplus.AppClanInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::ClanInfo* claninfo_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppClanMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppClanMessage) */ {
 public:
  inline AppClanMessage() : AppClanMessage(nullptr) {}
  ~AppClanMessage() override;
  explicit constexpr AppClanMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppClanMessage(const AppClanMessage& from);
  AppClanMessage(AppClanMessage&& from) noexcept
    : AppClanMessage() {
    *this = ::std::move(from);
  }

  inline AppClanMessage& operator=(const AppClanMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppClanMessage& operator=(AppClanMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppClanMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppClanMessage* internal_default_instance() {
    return reinterpret_cast<const AppClanMessage*>(
               &_AppClanMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AppClanMessage& a, AppClanMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AppClanMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppClanMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppClanMessage* New() const final {
    return new AppClanMessage();
  }

  AppClanMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppClanMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppClanMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppClanMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppClanMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppClanMessage";
  }
  protected:
  explicit AppClanMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSteamIdFieldNumber = 1,
    kTimeFieldNumber = 4,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // required string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& m_iValue);
  std::string* _internal_mutable_message();
  public:

  // required uint64 steamId = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid() const;
  void set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steamid() const;
  void _internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // required int64 time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppClanMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steamid_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppClanChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppClanChat) */ {
 public:
  inline AppClanChat() : AppClanChat(nullptr) {}
  ~AppClanChat() override;
  explicit constexpr AppClanChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppClanChat(const AppClanChat& from);
  AppClanChat(AppClanChat&& from) noexcept
    : AppClanChat() {
    *this = ::std::move(from);
  }

  inline AppClanChat& operator=(const AppClanChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppClanChat& operator=(AppClanChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppClanChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppClanChat* internal_default_instance() {
    return reinterpret_cast<const AppClanChat*>(
               &_AppClanChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(AppClanChat& a, AppClanChat& b) {
    a.Swap(&b);
  }
  inline void Swap(AppClanChat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppClanChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppClanChat* New() const final {
    return new AppClanChat();
  }

  AppClanChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppClanChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppClanChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppClanChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppClanChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppClanChat";
  }
  protected:
  explicit AppClanChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .rustplus.AppClanMessage messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::rustplus::AppClanMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppClanMessage >*
      mutable_messages();
  private:
  const ::rustplus::AppClanMessage& _internal_messages(int index) const;
  ::rustplus::AppClanMessage* _internal_add_messages();
  public:
  const ::rustplus::AppClanMessage& messages(int index) const;
  ::rustplus::AppClanMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppClanMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:rustplus.AppClanChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppClanMessage > messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppNexusAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppNexusAuth) */ {
 public:
  inline AppNexusAuth() : AppNexusAuth(nullptr) {}
  ~AppNexusAuth() override;
  explicit constexpr AppNexusAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppNexusAuth(const AppNexusAuth& from);
  AppNexusAuth(AppNexusAuth&& from) noexcept
    : AppNexusAuth() {
    *this = ::std::move(from);
  }

  inline AppNexusAuth& operator=(const AppNexusAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppNexusAuth& operator=(AppNexusAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppNexusAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppNexusAuth* internal_default_instance() {
    return reinterpret_cast<const AppNexusAuth*>(
               &_AppNexusAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(AppNexusAuth& a, AppNexusAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(AppNexusAuth* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppNexusAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppNexusAuth* New() const final {
    return new AppNexusAuth();
  }

  AppNexusAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppNexusAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppNexusAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppNexusAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppNexusAuth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppNexusAuth";
  }
  protected:
  explicit AppNexusAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 1,
    kPlayerTokenFieldNumber = 2,
  };
  // required string serverId = 1;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  const std::string& serverid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverid();
  PROTOBUF_MUST_USE_RESULT std::string* release_serverid();
  void set_allocated_serverid(std::string* serverid);
  private:
  const std::string& _internal_serverid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverid(const std::string& m_iValue);
  std::string* _internal_mutable_serverid();
  public:

  // required int32 playerToken = 2;
  bool has_playertoken() const;
  private:
  bool _internal_has_playertoken() const;
  public:
  void clear_playertoken();
  ::PROTOBUF_NAMESPACE_ID::int32 playertoken() const;
  void set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playertoken() const;
  void _internal_set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppNexusAuth)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverid_;
  ::PROTOBUF_NAMESPACE_ID::int32 playertoken_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppTeamChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppTeamChanged) */ {
 public:
  inline AppTeamChanged() : AppTeamChanged(nullptr) {}
  ~AppTeamChanged() override;
  explicit constexpr AppTeamChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppTeamChanged(const AppTeamChanged& from);
  AppTeamChanged(AppTeamChanged&& from) noexcept
    : AppTeamChanged() {
    *this = ::std::move(from);
  }

  inline AppTeamChanged& operator=(const AppTeamChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppTeamChanged& operator=(AppTeamChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppTeamChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppTeamChanged* internal_default_instance() {
    return reinterpret_cast<const AppTeamChanged*>(
               &_AppTeamChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(AppTeamChanged& a, AppTeamChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(AppTeamChanged* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppTeamChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppTeamChanged* New() const final {
    return new AppTeamChanged();
  }

  AppTeamChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppTeamChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppTeamChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppTeamChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppTeamChanged* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppTeamChanged";
  }
  protected:
  explicit AppTeamChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamInfoFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // required .rustplus.AppTeamInfo teamInfo = 2;
  bool has_teaminfo() const;
  private:
  bool _internal_has_teaminfo() const;
  public:
  void clear_teaminfo();
  const ::rustplus::AppTeamInfo& teaminfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppTeamInfo* release_teaminfo();
  ::rustplus::AppTeamInfo* mutable_teaminfo();
  void set_allocated_teaminfo(::rustplus::AppTeamInfo* teaminfo);
  private:
  const ::rustplus::AppTeamInfo& _internal_teaminfo() const;
  ::rustplus::AppTeamInfo* _internal_mutable_teaminfo();
  public:
  void unsafe_arena_set_allocated_teaminfo(
      ::rustplus::AppTeamInfo* teaminfo);
  ::rustplus::AppTeamInfo* unsafe_arena_release_teaminfo();

  // required uint64 playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppTeamChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppTeamInfo* teaminfo_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppNewTeamMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppNewTeamMessage) */ {
 public:
  inline AppNewTeamMessage() : AppNewTeamMessage(nullptr) {}
  ~AppNewTeamMessage() override;
  explicit constexpr AppNewTeamMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppNewTeamMessage(const AppNewTeamMessage& from);
  AppNewTeamMessage(AppNewTeamMessage&& from) noexcept
    : AppNewTeamMessage() {
    *this = ::std::move(from);
  }

  inline AppNewTeamMessage& operator=(const AppNewTeamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppNewTeamMessage& operator=(AppNewTeamMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppNewTeamMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppNewTeamMessage* internal_default_instance() {
    return reinterpret_cast<const AppNewTeamMessage*>(
               &_AppNewTeamMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(AppNewTeamMessage& a, AppNewTeamMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AppNewTeamMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppNewTeamMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppNewTeamMessage* New() const final {
    return new AppNewTeamMessage();
  }

  AppNewTeamMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppNewTeamMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppNewTeamMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppNewTeamMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppNewTeamMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppNewTeamMessage";
  }
  protected:
  explicit AppNewTeamMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // required .rustplus.AppTeamMessage message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::rustplus::AppTeamMessage& message() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppTeamMessage* release_message();
  ::rustplus::AppTeamMessage* mutable_message();
  void set_allocated_message(::rustplus::AppTeamMessage* message);
  private:
  const ::rustplus::AppTeamMessage& _internal_message() const;
  ::rustplus::AppTeamMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::rustplus::AppTeamMessage* message);
  ::rustplus::AppTeamMessage* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:rustplus.AppNewTeamMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppTeamMessage* message_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppEntityChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppEntityChanged) */ {
 public:
  inline AppEntityChanged() : AppEntityChanged(nullptr) {}
  ~AppEntityChanged() override;
  explicit constexpr AppEntityChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEntityChanged(const AppEntityChanged& from);
  AppEntityChanged(AppEntityChanged&& from) noexcept
    : AppEntityChanged() {
    *this = ::std::move(from);
  }

  inline AppEntityChanged& operator=(const AppEntityChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEntityChanged& operator=(AppEntityChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEntityChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppEntityChanged* internal_default_instance() {
    return reinterpret_cast<const AppEntityChanged*>(
               &_AppEntityChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(AppEntityChanged& a, AppEntityChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEntityChanged* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEntityChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppEntityChanged* New() const final {
    return new AppEntityChanged();
  }

  AppEntityChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppEntityChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEntityChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppEntityChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEntityChanged* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppEntityChanged";
  }
  protected:
  explicit AppEntityChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // required .rustplus.AppEntityPayload payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::rustplus::AppEntityPayload& payload() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppEntityPayload* release_payload();
  ::rustplus::AppEntityPayload* mutable_payload();
  void set_allocated_payload(::rustplus::AppEntityPayload* payload);
  private:
  const ::rustplus::AppEntityPayload& _internal_payload() const;
  ::rustplus::AppEntityPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::rustplus::AppEntityPayload* payload);
  ::rustplus::AppEntityPayload* unsafe_arena_release_payload();

  // required uint32 entityId = 1;
  bool has_entityid() const;
  private:
  bool _internal_has_entityid() const;
  public:
  void clear_entityid();
  ::PROTOBUF_NAMESPACE_ID::uint32 entityid() const;
  void set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entityid() const;
  void _internal_set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppEntityChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppEntityPayload* payload_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entityid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppClanChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppClanChanged) */ {
 public:
  inline AppClanChanged() : AppClanChanged(nullptr) {}
  ~AppClanChanged() override;
  explicit constexpr AppClanChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppClanChanged(const AppClanChanged& from);
  AppClanChanged(AppClanChanged&& from) noexcept
    : AppClanChanged() {
    *this = ::std::move(from);
  }

  inline AppClanChanged& operator=(const AppClanChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppClanChanged& operator=(AppClanChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppClanChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppClanChanged* internal_default_instance() {
    return reinterpret_cast<const AppClanChanged*>(
               &_AppClanChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(AppClanChanged& a, AppClanChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(AppClanChanged* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppClanChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppClanChanged* New() const final {
    return new AppClanChanged();
  }

  AppClanChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppClanChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppClanChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppClanChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppClanChanged* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppClanChanged";
  }
  protected:
  explicit AppClanChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClanInfoFieldNumber = 1,
  };
  // optional .rustplus.ClanInfo clanInfo = 1;
  bool has_claninfo() const;
  private:
  bool _internal_has_claninfo() const;
  public:
  void clear_claninfo();
  const ::rustplus::ClanInfo& claninfo() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::ClanInfo* release_claninfo();
  ::rustplus::ClanInfo* mutable_claninfo();
  void set_allocated_claninfo(::rustplus::ClanInfo* claninfo);
  private:
  const ::rustplus::ClanInfo& _internal_claninfo() const;
  ::rustplus::ClanInfo* _internal_mutable_claninfo();
  public:
  void unsafe_arena_set_allocated_claninfo(
      ::rustplus::ClanInfo* claninfo);
  ::rustplus::ClanInfo* unsafe_arena_release_claninfo();

  // @@protoc_insertion_point(class_scope:rustplus.AppClanChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::ClanInfo* claninfo_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppNewClanMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppNewClanMessage) */ {
 public:
  inline AppNewClanMessage() : AppNewClanMessage(nullptr) {}
  ~AppNewClanMessage() override;
  explicit constexpr AppNewClanMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppNewClanMessage(const AppNewClanMessage& from);
  AppNewClanMessage(AppNewClanMessage&& from) noexcept
    : AppNewClanMessage() {
    *this = ::std::move(from);
  }

  inline AppNewClanMessage& operator=(const AppNewClanMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppNewClanMessage& operator=(AppNewClanMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppNewClanMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppNewClanMessage* internal_default_instance() {
    return reinterpret_cast<const AppNewClanMessage*>(
               &_AppNewClanMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AppNewClanMessage& a, AppNewClanMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AppNewClanMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppNewClanMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppNewClanMessage* New() const final {
    return new AppNewClanMessage();
  }

  AppNewClanMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppNewClanMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppNewClanMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppNewClanMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppNewClanMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppNewClanMessage";
  }
  protected:
  explicit AppNewClanMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kClanIdFieldNumber = 1,
  };
  // required .rustplus.AppClanMessage message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::rustplus::AppClanMessage& message() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::AppClanMessage* release_message();
  ::rustplus::AppClanMessage* mutable_message();
  void set_allocated_message(::rustplus::AppClanMessage* message);
  private:
  const ::rustplus::AppClanMessage& _internal_message() const;
  ::rustplus::AppClanMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::rustplus::AppClanMessage* message);
  ::rustplus::AppClanMessage* unsafe_arena_release_message();

  // required int64 clanId = 1;
  bool has_clanid() const;
  private:
  bool _internal_has_clanid() const;
  public:
  void clear_clanid();
  ::PROTOBUF_NAMESPACE_ID::int64 clanid() const;
  void set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_clanid() const;
  void _internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppNewClanMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::AppClanMessage* message_;
  ::PROTOBUF_NAMESPACE_ID::int64 clanid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppCameraSubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppCameraSubscribe) */ {
 public:
  inline AppCameraSubscribe() : AppCameraSubscribe(nullptr) {}
  ~AppCameraSubscribe() override;
  explicit constexpr AppCameraSubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCameraSubscribe(const AppCameraSubscribe& from);
  AppCameraSubscribe(AppCameraSubscribe&& from) noexcept
    : AppCameraSubscribe() {
    *this = ::std::move(from);
  }

  inline AppCameraSubscribe& operator=(const AppCameraSubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCameraSubscribe& operator=(AppCameraSubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCameraSubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCameraSubscribe* internal_default_instance() {
    return reinterpret_cast<const AppCameraSubscribe*>(
               &_AppCameraSubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(AppCameraSubscribe& a, AppCameraSubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCameraSubscribe* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCameraSubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppCameraSubscribe* New() const final {
    return new AppCameraSubscribe();
  }

  AppCameraSubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppCameraSubscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCameraSubscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppCameraSubscribe& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCameraSubscribe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppCameraSubscribe";
  }
  protected:
  explicit AppCameraSubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraIdFieldNumber = 1,
  };
  // required string cameraId = 1;
  bool has_cameraid() const;
  private:
  bool _internal_has_cameraid() const;
  public:
  void clear_cameraid();
  const std::string& cameraid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cameraid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cameraid();
  PROTOBUF_MUST_USE_RESULT std::string* release_cameraid();
  void set_allocated_cameraid(std::string* cameraid);
  private:
  const std::string& _internal_cameraid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cameraid(const std::string& m_iValue);
  std::string* _internal_mutable_cameraid();
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppCameraSubscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraid_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppCameraInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppCameraInput) */ {
 public:
  inline AppCameraInput() : AppCameraInput(nullptr) {}
  ~AppCameraInput() override;
  explicit constexpr AppCameraInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCameraInput(const AppCameraInput& from);
  AppCameraInput(AppCameraInput&& from) noexcept
    : AppCameraInput() {
    *this = ::std::move(from);
  }

  inline AppCameraInput& operator=(const AppCameraInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCameraInput& operator=(AppCameraInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCameraInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCameraInput* internal_default_instance() {
    return reinterpret_cast<const AppCameraInput*>(
               &_AppCameraInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(AppCameraInput& a, AppCameraInput& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCameraInput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCameraInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppCameraInput* New() const final {
    return new AppCameraInput();
  }

  AppCameraInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppCameraInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCameraInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppCameraInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCameraInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppCameraInput";
  }
  protected:
  explicit AppCameraInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMouseDeltaFieldNumber = 2,
    kButtonsFieldNumber = 1,
  };
  // required .rustplus.Vector2 mouseDelta = 2;
  bool has_mousedelta() const;
  private:
  bool _internal_has_mousedelta() const;
  public:
  void clear_mousedelta();
  const ::rustplus::Vector2& mousedelta() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector2* release_mousedelta();
  ::rustplus::Vector2* mutable_mousedelta();
  void set_allocated_mousedelta(::rustplus::Vector2* mousedelta);
  private:
  const ::rustplus::Vector2& _internal_mousedelta() const;
  ::rustplus::Vector2* _internal_mutable_mousedelta();
  public:
  void unsafe_arena_set_allocated_mousedelta(
      ::rustplus::Vector2* mousedelta);
  ::rustplus::Vector2* unsafe_arena_release_mousedelta();

  // required int32 buttons = 1;
  bool has_buttons() const;
  private:
  bool _internal_has_buttons() const;
  public:
  void clear_buttons();
  ::PROTOBUF_NAMESPACE_ID::int32 buttons() const;
  void set_buttons(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_buttons() const;
  void _internal_set_buttons(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppCameraInput)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rustplus::Vector2* mousedelta_;
  ::PROTOBUF_NAMESPACE_ID::int32 buttons_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppCameraInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppCameraInfo) */ {
 public:
  inline AppCameraInfo() : AppCameraInfo(nullptr) {}
  ~AppCameraInfo() override;
  explicit constexpr AppCameraInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCameraInfo(const AppCameraInfo& from);
  AppCameraInfo(AppCameraInfo&& from) noexcept
    : AppCameraInfo() {
    *this = ::std::move(from);
  }

  inline AppCameraInfo& operator=(const AppCameraInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCameraInfo& operator=(AppCameraInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCameraInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCameraInfo* internal_default_instance() {
    return reinterpret_cast<const AppCameraInfo*>(
               &_AppCameraInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(AppCameraInfo& a, AppCameraInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCameraInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCameraInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppCameraInfo* New() const final {
    return new AppCameraInfo();
  }

  AppCameraInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppCameraInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCameraInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppCameraInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCameraInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppCameraInfo";
  }
  protected:
  explicit AppCameraInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kNearPlaneFieldNumber = 3,
    kFarPlaneFieldNumber = 4,
    kControlFlagsFieldNumber = 5,
  };
  // required int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required float nearPlane = 3;
  bool has_nearplane() const;
  private:
  bool _internal_has_nearplane() const;
  public:
  void clear_nearplane();
  float nearplane() const;
  void set_nearplane(float m_iValue);
  private:
  float _internal_nearplane() const;
  void _internal_set_nearplane(float m_iValue);
  public:

  // required float farPlane = 4;
  bool has_farplane() const;
  private:
  bool _internal_has_farplane() const;
  public:
  void clear_farplane();
  float farplane() const;
  void set_farplane(float m_iValue);
  private:
  float _internal_farplane() const;
  void _internal_set_farplane(float m_iValue);
  public:

  // required int32 controlFlags = 5;
  bool has_controlflags() const;
  private:
  bool _internal_has_controlflags() const;
  public:
  void clear_controlflags();
  ::PROTOBUF_NAMESPACE_ID::int32 controlflags() const;
  void set_controlflags(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_controlflags() const;
  void _internal_set_controlflags(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppCameraInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  float nearplane_;
  float farplane_;
  ::PROTOBUF_NAMESPACE_ID::int32 controlflags_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppCameraRays_Entity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppCameraRays.Entity) */ {
 public:
  inline AppCameraRays_Entity() : AppCameraRays_Entity(nullptr) {}
  ~AppCameraRays_Entity() override;
  explicit constexpr AppCameraRays_Entity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCameraRays_Entity(const AppCameraRays_Entity& from);
  AppCameraRays_Entity(AppCameraRays_Entity&& from) noexcept
    : AppCameraRays_Entity() {
    *this = ::std::move(from);
  }

  inline AppCameraRays_Entity& operator=(const AppCameraRays_Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCameraRays_Entity& operator=(AppCameraRays_Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCameraRays_Entity& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCameraRays_Entity* internal_default_instance() {
    return reinterpret_cast<const AppCameraRays_Entity*>(
               &_AppCameraRays_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(AppCameraRays_Entity& a, AppCameraRays_Entity& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCameraRays_Entity* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCameraRays_Entity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppCameraRays_Entity* New() const final {
    return new AppCameraRays_Entity();
  }

  AppCameraRays_Entity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppCameraRays_Entity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCameraRays_Entity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppCameraRays_Entity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCameraRays_Entity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppCameraRays.Entity";
  }
  protected:
  explicit AppCameraRays_Entity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 6,
    kPositionFieldNumber = 3,
    kRotationFieldNumber = 4,
    kSizeFieldNumber = 5,
    kEntityIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string name = 6;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& m_iValue);
  std::string* _internal_mutable_name();
  public:

  // required .rustplus.Vector3 position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::rustplus::Vector3& position() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector3* release_position();
  ::rustplus::Vector3* mutable_position();
  void set_allocated_position(::rustplus::Vector3* position);
  private:
  const ::rustplus::Vector3& _internal_position() const;
  ::rustplus::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::rustplus::Vector3* position);
  ::rustplus::Vector3* unsafe_arena_release_position();

  // required .rustplus.Vector3 rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::rustplus::Vector3& rotation() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector3* release_rotation();
  ::rustplus::Vector3* mutable_rotation();
  void set_allocated_rotation(::rustplus::Vector3* rotation);
  private:
  const ::rustplus::Vector3& _internal_rotation() const;
  ::rustplus::Vector3* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::rustplus::Vector3* rotation);
  ::rustplus::Vector3* unsafe_arena_release_rotation();

  // required .rustplus.Vector3 size = 5;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::rustplus::Vector3& size() const;
  PROTOBUF_MUST_USE_RESULT ::rustplus::Vector3* release_size();
  ::rustplus::Vector3* mutable_size();
  void set_allocated_size(::rustplus::Vector3* size);
  private:
  const ::rustplus::Vector3& _internal_size() const;
  ::rustplus::Vector3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::rustplus::Vector3* size);
  ::rustplus::Vector3* unsafe_arena_release_size();

  // required uint32 entityId = 1;
  bool has_entityid() const;
  private:
  bool _internal_has_entityid() const;
  public:
  void clear_entityid();
  ::PROTOBUF_NAMESPACE_ID::uint32 entityid() const;
  void set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entityid() const;
  void _internal_set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue);
  public:

  // required .rustplus.AppCameraRays.EntityType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::rustplus::AppCameraRays_EntityType type() const;
  void set_type(::rustplus::AppCameraRays_EntityType m_iValue);
  private:
  ::rustplus::AppCameraRays_EntityType _internal_type() const;
  void _internal_set_type(::rustplus::AppCameraRays_EntityType m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppCameraRays.Entity)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::rustplus::Vector3* position_;
  ::rustplus::Vector3* rotation_;
  ::rustplus::Vector3* size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entityid_;
  int type_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// -------------------------------------------------------------------

class AppCameraRays final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rustplus.AppCameraRays) */ {
 public:
  inline AppCameraRays() : AppCameraRays(nullptr) {}
  ~AppCameraRays() override;
  explicit constexpr AppCameraRays(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCameraRays(const AppCameraRays& from);
  AppCameraRays(AppCameraRays&& from) noexcept
    : AppCameraRays() {
    *this = ::std::move(from);
  }

  inline AppCameraRays& operator=(const AppCameraRays& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCameraRays& operator=(AppCameraRays&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCameraRays& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCameraRays* internal_default_instance() {
    return reinterpret_cast<const AppCameraRays*>(
               &_AppCameraRays_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(AppCameraRays& a, AppCameraRays& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCameraRays* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCameraRays* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppCameraRays* New() const final {
    return new AppCameraRays();
  }

  AppCameraRays* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppCameraRays>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCameraRays& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppCameraRays& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCameraRays* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rustplus.AppCameraRays";
  }
  protected:
  explicit AppCameraRays(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AppCameraRays_Entity Entity;

  typedef AppCameraRays_EntityType EntityType;
  static constexpr EntityType Tree =
    AppCameraRays_EntityType_Tree;
  static constexpr EntityType Player =
    AppCameraRays_EntityType_Player;
  static inline bool EntityType_IsValid(int m_iValue) {
    return AppCameraRays_EntityType_IsValid(m_iValue);
  }
  static constexpr EntityType EntityType_MIN =
    AppCameraRays_EntityType_EntityType_MIN;
  static constexpr EntityType EntityType_MAX =
    AppCameraRays_EntityType_EntityType_MAX;
  static constexpr int EntityType_ARRAYSIZE =
    AppCameraRays_EntityType_EntityType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EntityType_descriptor() {
    return AppCameraRays_EntityType_descriptor();
  }
  template<typename T>
  static inline const std::string& EntityType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EntityType>::m_iValue ||
      ::std::is_integral<T>::m_iValue,
      "Incorrect type passed to function EntityType_Name.");
    return AppCameraRays_EntityType_Name(enum_t_value);
  }
  static inline bool EntityType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EntityType* m_iValue) {
    return AppCameraRays_EntityType_Parse(name, m_iValue);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 5,
    kRayDataFieldNumber = 3,
    kVerticalFovFieldNumber = 1,
    kSampleOffsetFieldNumber = 2,
    kDistanceFieldNumber = 4,
  };
  // repeated .rustplus.AppCameraRays.Entity entities = 5;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::rustplus::AppCameraRays_Entity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppCameraRays_Entity >*
      mutable_entities();
  private:
  const ::rustplus::AppCameraRays_Entity& _internal_entities(int index) const;
  ::rustplus::AppCameraRays_Entity* _internal_add_entities();
  public:
  const ::rustplus::AppCameraRays_Entity& entities(int index) const;
  ::rustplus::AppCameraRays_Entity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppCameraRays_Entity >&
      entities() const;

  // required bytes rayData = 3;
  bool has_raydata() const;
  private:
  bool _internal_has_raydata() const;
  public:
  void clear_raydata();
  const std::string& raydata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raydata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raydata();
  PROTOBUF_MUST_USE_RESULT std::string* release_raydata();
  void set_allocated_raydata(std::string* raydata);
  private:
  const std::string& _internal_raydata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raydata(const std::string& m_iValue);
  std::string* _internal_mutable_raydata();
  public:

  // required float verticalFov = 1;
  bool has_verticalfov() const;
  private:
  bool _internal_has_verticalfov() const;
  public:
  void clear_verticalfov();
  float verticalfov() const;
  void set_verticalfov(float m_iValue);
  private:
  float _internal_verticalfov() const;
  void _internal_set_verticalfov(float m_iValue);
  public:

  // required int32 sampleOffset = 2;
  bool has_sampleoffset() const;
  private:
  bool _internal_has_sampleoffset() const;
  public:
  void clear_sampleoffset();
  ::PROTOBUF_NAMESPACE_ID::int32 sampleoffset() const;
  void set_sampleoffset(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sampleoffset() const;
  void _internal_set_sampleoffset(::PROTOBUF_NAMESPACE_ID::int32 m_iValue);
  public:

  // required float distance = 4;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  float distance() const;
  void set_distance(float m_iValue);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float m_iValue);
  public:

  // @@protoc_insertion_point(class_scope:rustplus.AppCameraRays)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppCameraRays_Entity > entities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raydata_;
  float verticalfov_;
  ::PROTOBUF_NAMESPACE_ID::int32 sampleoffset_;
  float distance_;
  friend struct ::TableStruct_rustplus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector2

// optional float x = 1;
inline bool Vector2::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool Vector2::has_x() const {
  return _internal_has_x();
}
inline void Vector2::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Vector2::_internal_x() const {
  return x_;
}
inline float Vector2::x() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector2.x)
  return _internal_x();
}
inline void Vector2::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  x_ = m_iValue;
}
inline void Vector2::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector2.x)
}

// optional float y = 2;
inline bool Vector2::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool Vector2::has_y() const {
  return _internal_has_y();
}
inline void Vector2::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Vector2::_internal_y() const {
  return y_;
}
inline float Vector2::y() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector2.y)
  return _internal_y();
}
inline void Vector2::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  y_ = m_iValue;
}
inline void Vector2::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector2.y)
}

// -------------------------------------------------------------------

// Vector3

// optional float x = 1;
inline bool Vector3::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool Vector3::has_x() const {
  return _internal_has_x();
}
inline void Vector3::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Vector3::_internal_x() const {
  return x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  x_ = m_iValue;
}
inline void Vector3::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector3.x)
}

// optional float y = 2;
inline bool Vector3::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool Vector3::has_y() const {
  return _internal_has_y();
}
inline void Vector3::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Vector3::_internal_y() const {
  return y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  y_ = m_iValue;
}
inline void Vector3::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector3.y)
}

// optional float z = 3;
inline bool Vector3::_internal_has_z() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool Vector3::has_z() const {
  return _internal_has_z();
}
inline void Vector3::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Vector3::_internal_z() const {
  return z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  z_ = m_iValue;
}
inline void Vector3::set_z(float m_iValue) {
  _internal_set_z(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector3.z)
}

// -------------------------------------------------------------------

// Vector4

// optional float x = 1;
inline bool Vector4::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool Vector4::has_x() const {
  return _internal_has_x();
}
inline void Vector4::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Vector4::_internal_x() const {
  return x_;
}
inline float Vector4::x() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector4.x)
  return _internal_x();
}
inline void Vector4::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  x_ = m_iValue;
}
inline void Vector4::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector4.x)
}

// optional float y = 2;
inline bool Vector4::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool Vector4::has_y() const {
  return _internal_has_y();
}
inline void Vector4::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Vector4::_internal_y() const {
  return y_;
}
inline float Vector4::y() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector4.y)
  return _internal_y();
}
inline void Vector4::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  y_ = m_iValue;
}
inline void Vector4::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector4.y)
}

// optional float z = 3;
inline bool Vector4::_internal_has_z() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool Vector4::has_z() const {
  return _internal_has_z();
}
inline void Vector4::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Vector4::_internal_z() const {
  return z_;
}
inline float Vector4::z() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector4.z)
  return _internal_z();
}
inline void Vector4::_internal_set_z(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  z_ = m_iValue;
}
inline void Vector4::set_z(float m_iValue) {
  _internal_set_z(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector4.z)
}

// optional float w = 4;
inline bool Vector4::_internal_has_w() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool Vector4::has_w() const {
  return _internal_has_w();
}
inline void Vector4::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Vector4::_internal_w() const {
  return w_;
}
inline float Vector4::w() const {
  // @@protoc_insertion_point(field_get:rustplus.Vector4.w)
  return _internal_w();
}
inline void Vector4::_internal_set_w(float m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  w_ = m_iValue;
}
inline void Vector4::set_w(float m_iValue) {
  _internal_set_w(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Vector4.w)
}

// -------------------------------------------------------------------

// Half3

// optional float x = 1;
inline bool Half3::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool Half3::has_x() const {
  return _internal_has_x();
}
inline void Half3::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Half3::_internal_x() const {
  return x_;
}
inline float Half3::x() const {
  // @@protoc_insertion_point(field_get:rustplus.Half3.x)
  return _internal_x();
}
inline void Half3::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  x_ = m_iValue;
}
inline void Half3::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Half3.x)
}

// optional float y = 2;
inline bool Half3::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool Half3::has_y() const {
  return _internal_has_y();
}
inline void Half3::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Half3::_internal_y() const {
  return y_;
}
inline float Half3::y() const {
  // @@protoc_insertion_point(field_get:rustplus.Half3.y)
  return _internal_y();
}
inline void Half3::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  y_ = m_iValue;
}
inline void Half3::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Half3.y)
}

// optional float z = 3;
inline bool Half3::_internal_has_z() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool Half3::has_z() const {
  return _internal_has_z();
}
inline void Half3::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Half3::_internal_z() const {
  return z_;
}
inline float Half3::z() const {
  // @@protoc_insertion_point(field_get:rustplus.Half3.z)
  return _internal_z();
}
inline void Half3::_internal_set_z(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  z_ = m_iValue;
}
inline void Half3::set_z(float m_iValue) {
  _internal_set_z(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Half3.z)
}

// -------------------------------------------------------------------

// Color

// optional float r = 1;
inline bool Color::_internal_has_r() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool Color::has_r() const {
  return _internal_has_r();
}
inline void Color::clear_r() {
  r_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Color::_internal_r() const {
  return r_;
}
inline float Color::r() const {
  // @@protoc_insertion_point(field_get:rustplus.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(float m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  r_ = m_iValue;
}
inline void Color::set_r(float m_iValue) {
  _internal_set_r(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Color.r)
}

// optional float g = 2;
inline bool Color::_internal_has_g() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool Color::has_g() const {
  return _internal_has_g();
}
inline void Color::clear_g() {
  g_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Color::_internal_g() const {
  return g_;
}
inline float Color::g() const {
  // @@protoc_insertion_point(field_get:rustplus.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  g_ = m_iValue;
}
inline void Color::set_g(float m_iValue) {
  _internal_set_g(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Color.g)
}

// optional float b = 3;
inline bool Color::_internal_has_b() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool Color::has_b() const {
  return _internal_has_b();
}
inline void Color::clear_b() {
  b_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Color::_internal_b() const {
  return b_;
}
inline float Color::b() const {
  // @@protoc_insertion_point(field_get:rustplus.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  b_ = m_iValue;
}
inline void Color::set_b(float m_iValue) {
  _internal_set_b(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Color.b)
}

// optional float a = 4;
inline bool Color::_internal_has_a() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool Color::has_a() const {
  return _internal_has_a();
}
inline void Color::clear_a() {
  a_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Color::_internal_a() const {
  return a_;
}
inline float Color::a() const {
  // @@protoc_insertion_point(field_get:rustplus.Color.a)
  return _internal_a();
}
inline void Color::_internal_set_a(float m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  a_ = m_iValue;
}
inline void Color::set_a(float m_iValue) {
  _internal_set_a(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.Color.a)
}

// -------------------------------------------------------------------

// Ray

// optional .rustplus.Vector3 origin = 1;
inline bool Ray::_internal_has_origin() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || origin_ != nullptr);
  return m_iValue;
}
inline bool Ray::has_origin() const {
  return _internal_has_origin();
}
inline void Ray::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::Vector3& Ray::_internal_origin() const {
  const ::rustplus::Vector3* p = origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector3&>(
      ::rustplus::_Vector3_default_instance_);
}
inline const ::rustplus::Vector3& Ray::origin() const {
  // @@protoc_insertion_point(field_get:rustplus.Ray.origin)
  return _internal_origin();
}
inline void Ray::unsafe_arena_set_allocated_origin(
    ::rustplus::Vector3* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_);
  }
  origin_ = origin;
  if (origin) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.Ray.origin)
}
inline ::rustplus::Vector3* Ray::release_origin() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::Vector3* temp = origin_;
  origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector3* Ray::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:rustplus.Ray.origin)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::Vector3* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::rustplus::Vector3* Ray::_internal_mutable_origin() {
  _has_bits_[0] |= 0x00000001u;
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector3>(GetArenaForAllocation());
    origin_ = p;
  }
  return origin_;
}
inline ::rustplus::Vector3* Ray::mutable_origin() {
  ::rustplus::Vector3* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:rustplus.Ray.origin)
  return _msg;
}
inline void Ray::set_allocated_origin(::rustplus::Vector3* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector3>::GetOwningArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:rustplus.Ray.origin)
}

// optional .rustplus.Vector3 direction = 2;
inline bool Ray::_internal_has_direction() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || direction_ != nullptr);
  return m_iValue;
}
inline bool Ray::has_direction() const {
  return _internal_has_direction();
}
inline void Ray::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::Vector3& Ray::_internal_direction() const {
  const ::rustplus::Vector3* p = direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector3&>(
      ::rustplus::_Vector3_default_instance_);
}
inline const ::rustplus::Vector3& Ray::direction() const {
  // @@protoc_insertion_point(field_get:rustplus.Ray.direction)
  return _internal_direction();
}
inline void Ray::unsafe_arena_set_allocated_direction(
    ::rustplus::Vector3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction_);
  }
  direction_ = direction;
  if (direction) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.Ray.direction)
}
inline ::rustplus::Vector3* Ray::release_direction() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::Vector3* temp = direction_;
  direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector3* Ray::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:rustplus.Ray.direction)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::Vector3* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::rustplus::Vector3* Ray::_internal_mutable_direction() {
  _has_bits_[0] |= 0x00000002u;
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector3>(GetArenaForAllocation());
    direction_ = p;
  }
  return direction_;
}
inline ::rustplus::Vector3* Ray::mutable_direction() {
  ::rustplus::Vector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:rustplus.Ray.direction)
  return _msg;
}
inline void Ray::set_allocated_direction(::rustplus::Vector3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector3>::GetOwningArena(direction);
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:rustplus.Ray.direction)
}

// -------------------------------------------------------------------

// ClanActionResult

// required int32 requestId = 1;
inline bool ClanActionResult::_internal_has_requestid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanActionResult::has_requestid() const {
  return _internal_has_requestid();
}
inline void ClanActionResult::clear_requestid() {
  requestid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanActionResult::_internal_requestid() const {
  return requestid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanActionResult::requestid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanActionResult.requestId)
  return _internal_requestid();
}
inline void ClanActionResult::_internal_set_requestid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  requestid_ = m_iValue;
}
inline void ClanActionResult::set_requestid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_requestid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanActionResult.requestId)
}

// required int32 result = 2;
inline bool ClanActionResult::_internal_has_result() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanActionResult::has_result() const {
  return _internal_has_result();
}
inline void ClanActionResult::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanActionResult::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanActionResult::result() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanActionResult.result)
  return _internal_result();
}
inline void ClanActionResult::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  result_ = m_iValue;
}
inline void ClanActionResult::set_result(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_result(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanActionResult.result)
}

// required bool hasClanInfo = 3;
inline bool ClanActionResult::_internal_has_hasclaninfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool ClanActionResult::has_hasclaninfo() const {
  return _internal_has_hasclaninfo();
}
inline void ClanActionResult::clear_hasclaninfo() {
  hasclaninfo_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClanActionResult::_internal_hasclaninfo() const {
  return hasclaninfo_;
}
inline bool ClanActionResult::hasclaninfo() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanActionResult.hasClanInfo)
  return _internal_hasclaninfo();
}
inline void ClanActionResult::_internal_set_hasclaninfo(bool m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  hasclaninfo_ = m_iValue;
}
inline void ClanActionResult::set_hasclaninfo(bool m_iValue) {
  _internal_set_hasclaninfo(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanActionResult.hasClanInfo)
}

// optional .rustplus.ClanInfo clanInfo = 4;
inline bool ClanActionResult::_internal_has_claninfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || claninfo_ != nullptr);
  return m_iValue;
}
inline bool ClanActionResult::has_claninfo() const {
  return _internal_has_claninfo();
}
inline void ClanActionResult::clear_claninfo() {
  if (claninfo_ != nullptr) claninfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::ClanInfo& ClanActionResult::_internal_claninfo() const {
  const ::rustplus::ClanInfo* p = claninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::ClanInfo&>(
      ::rustplus::_ClanInfo_default_instance_);
}
inline const ::rustplus::ClanInfo& ClanActionResult::claninfo() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanActionResult.clanInfo)
  return _internal_claninfo();
}
inline void ClanActionResult::unsafe_arena_set_allocated_claninfo(
    ::rustplus::ClanInfo* claninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claninfo_);
  }
  claninfo_ = claninfo;
  if (claninfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.ClanActionResult.clanInfo)
}
inline ::rustplus::ClanInfo* ClanActionResult::release_claninfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::ClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::ClanInfo* ClanActionResult::unsafe_arena_release_claninfo() {
  // @@protoc_insertion_point(field_release:rustplus.ClanActionResult.clanInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::ClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
  return temp;
}
inline ::rustplus::ClanInfo* ClanActionResult::_internal_mutable_claninfo() {
  _has_bits_[0] |= 0x00000001u;
  if (claninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::ClanInfo>(GetArenaForAllocation());
    claninfo_ = p;
  }
  return claninfo_;
}
inline ::rustplus::ClanInfo* ClanActionResult::mutable_claninfo() {
  ::rustplus::ClanInfo* _msg = _internal_mutable_claninfo();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanActionResult.clanInfo)
  return _msg;
}
inline void ClanActionResult::set_allocated_claninfo(::rustplus::ClanInfo* claninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete claninfo_;
  }
  if (claninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::ClanInfo>::GetOwningArena(claninfo);
    if (message_arena != submessage_arena) {
      claninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  claninfo_ = claninfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanActionResult.clanInfo)
}

// -------------------------------------------------------------------

// ClanInfo_Role

// required int32 roleId = 1;
inline bool ClanInfo_Role::_internal_has_roleid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_roleid() const {
  return _internal_has_roleid();
}
inline void ClanInfo_Role::clear_roleid() {
  roleid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo_Role::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo_Role::roleid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.roleId)
  return _internal_roleid();
}
inline void ClanInfo_Role::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  roleid_ = m_iValue;
}
inline void ClanInfo_Role::set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_roleid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.roleId)
}

// required int32 rank = 2;
inline bool ClanInfo_Role::_internal_has_rank() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_rank() const {
  return _internal_has_rank();
}
inline void ClanInfo_Role::clear_rank() {
  rank_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo_Role::_internal_rank() const {
  return rank_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo_Role::rank() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.rank)
  return _internal_rank();
}
inline void ClanInfo_Role::_internal_set_rank(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  rank_ = m_iValue;
}
inline void ClanInfo_Role::set_rank(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_rank(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.rank)
}

// required string name = 3;
inline bool ClanInfo_Role::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_name() const {
  return _internal_has_name();
}
inline void ClanInfo_Role::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClanInfo_Role::name() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanInfo_Role::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.name)
}
inline std::string* ClanInfo_Role::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.Role.name)
  return _s;
}
inline const std::string& ClanInfo_Role::_internal_name() const {
  return name_.Get();
}
inline void ClanInfo_Role::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanInfo_Role::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanInfo_Role::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.ClanInfo.Role.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanInfo_Role::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanInfo.Role.name)
}

// required bool canSetMotd = 4;
inline bool ClanInfo_Role::_internal_has_cansetmotd() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_cansetmotd() const {
  return _internal_has_cansetmotd();
}
inline void ClanInfo_Role::clear_cansetmotd() {
  cansetmotd_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClanInfo_Role::_internal_cansetmotd() const {
  return cansetmotd_;
}
inline bool ClanInfo_Role::cansetmotd() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canSetMotd)
  return _internal_cansetmotd();
}
inline void ClanInfo_Role::_internal_set_cansetmotd(bool m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  cansetmotd_ = m_iValue;
}
inline void ClanInfo_Role::set_cansetmotd(bool m_iValue) {
  _internal_set_cansetmotd(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canSetMotd)
}

// required bool canSetLogo = 5;
inline bool ClanInfo_Role::_internal_has_cansetlogo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_cansetlogo() const {
  return _internal_has_cansetlogo();
}
inline void ClanInfo_Role::clear_cansetlogo() {
  cansetlogo_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ClanInfo_Role::_internal_cansetlogo() const {
  return cansetlogo_;
}
inline bool ClanInfo_Role::cansetlogo() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canSetLogo)
  return _internal_cansetlogo();
}
inline void ClanInfo_Role::_internal_set_cansetlogo(bool m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  cansetlogo_ = m_iValue;
}
inline void ClanInfo_Role::set_cansetlogo(bool m_iValue) {
  _internal_set_cansetlogo(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canSetLogo)
}

// required bool canInvite = 6;
inline bool ClanInfo_Role::_internal_has_caninvite() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_caninvite() const {
  return _internal_has_caninvite();
}
inline void ClanInfo_Role::clear_caninvite() {
  caninvite_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ClanInfo_Role::_internal_caninvite() const {
  return caninvite_;
}
inline bool ClanInfo_Role::caninvite() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canInvite)
  return _internal_caninvite();
}
inline void ClanInfo_Role::_internal_set_caninvite(bool m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  caninvite_ = m_iValue;
}
inline void ClanInfo_Role::set_caninvite(bool m_iValue) {
  _internal_set_caninvite(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canInvite)
}

// required bool canKick = 7;
inline bool ClanInfo_Role::_internal_has_cankick() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_cankick() const {
  return _internal_has_cankick();
}
inline void ClanInfo_Role::clear_cankick() {
  cankick_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ClanInfo_Role::_internal_cankick() const {
  return cankick_;
}
inline bool ClanInfo_Role::cankick() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canKick)
  return _internal_cankick();
}
inline void ClanInfo_Role::_internal_set_cankick(bool m_iValue) {
  _has_bits_[0] |= 0x00000040u;
  cankick_ = m_iValue;
}
inline void ClanInfo_Role::set_cankick(bool m_iValue) {
  _internal_set_cankick(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canKick)
}

// required bool canPromote = 8;
inline bool ClanInfo_Role::_internal_has_canpromote() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_canpromote() const {
  return _internal_has_canpromote();
}
inline void ClanInfo_Role::clear_canpromote() {
  canpromote_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ClanInfo_Role::_internal_canpromote() const {
  return canpromote_;
}
inline bool ClanInfo_Role::canpromote() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canPromote)
  return _internal_canpromote();
}
inline void ClanInfo_Role::_internal_set_canpromote(bool m_iValue) {
  _has_bits_[0] |= 0x00000080u;
  canpromote_ = m_iValue;
}
inline void ClanInfo_Role::set_canpromote(bool m_iValue) {
  _internal_set_canpromote(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canPromote)
}

// required bool canDemote = 9;
inline bool ClanInfo_Role::_internal_has_candemote() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_candemote() const {
  return _internal_has_candemote();
}
inline void ClanInfo_Role::clear_candemote() {
  candemote_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ClanInfo_Role::_internal_candemote() const {
  return candemote_;
}
inline bool ClanInfo_Role::candemote() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canDemote)
  return _internal_candemote();
}
inline void ClanInfo_Role::_internal_set_candemote(bool m_iValue) {
  _has_bits_[0] |= 0x00000100u;
  candemote_ = m_iValue;
}
inline void ClanInfo_Role::set_candemote(bool m_iValue) {
  _internal_set_candemote(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canDemote)
}

// required bool canSetPlayerNotes = 10;
inline bool ClanInfo_Role::_internal_has_cansetplayernotes() const {
  bool m_iValue = (_has_bits_[0] & 0x00000200u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_cansetplayernotes() const {
  return _internal_has_cansetplayernotes();
}
inline void ClanInfo_Role::clear_cansetplayernotes() {
  cansetplayernotes_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ClanInfo_Role::_internal_cansetplayernotes() const {
  return cansetplayernotes_;
}
inline bool ClanInfo_Role::cansetplayernotes() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canSetPlayerNotes)
  return _internal_cansetplayernotes();
}
inline void ClanInfo_Role::_internal_set_cansetplayernotes(bool m_iValue) {
  _has_bits_[0] |= 0x00000200u;
  cansetplayernotes_ = m_iValue;
}
inline void ClanInfo_Role::set_cansetplayernotes(bool m_iValue) {
  _internal_set_cansetplayernotes(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canSetPlayerNotes)
}

// required bool canAccessLogs = 11;
inline bool ClanInfo_Role::_internal_has_canaccesslogs() const {
  bool m_iValue = (_has_bits_[0] & 0x00000400u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Role::has_canaccesslogs() const {
  return _internal_has_canaccesslogs();
}
inline void ClanInfo_Role::clear_canaccesslogs() {
  canaccesslogs_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ClanInfo_Role::_internal_canaccesslogs() const {
  return canaccesslogs_;
}
inline bool ClanInfo_Role::canaccesslogs() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Role.canAccessLogs)
  return _internal_canaccesslogs();
}
inline void ClanInfo_Role::_internal_set_canaccesslogs(bool m_iValue) {
  _has_bits_[0] |= 0x00000400u;
  canaccesslogs_ = m_iValue;
}
inline void ClanInfo_Role::set_canaccesslogs(bool m_iValue) {
  _internal_set_canaccesslogs(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Role.canAccessLogs)
}

// -------------------------------------------------------------------

// ClanInfo_Member

// required int64 steamId = 1;
inline bool ClanInfo_Member::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Member::has_steamid() const {
  return _internal_has_steamid();
}
inline void ClanInfo_Member::clear_steamid() {
  steamid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Member::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Member::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Member.steamId)
  return _internal_steamid();
}
inline void ClanInfo_Member::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = m_iValue;
}
inline void ClanInfo_Member::set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Member.steamId)
}

// required int32 roleId = 2;
inline bool ClanInfo_Member::_internal_has_roleid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Member::has_roleid() const {
  return _internal_has_roleid();
}
inline void ClanInfo_Member::clear_roleid() {
  roleid_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo_Member::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo_Member::roleid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Member.roleId)
  return _internal_roleid();
}
inline void ClanInfo_Member::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  roleid_ = m_iValue;
}
inline void ClanInfo_Member::set_roleid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_roleid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Member.roleId)
}

// required int64 joined = 3;
inline bool ClanInfo_Member::_internal_has_joined() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Member::has_joined() const {
  return _internal_has_joined();
}
inline void ClanInfo_Member::clear_joined() {
  joined_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Member::_internal_joined() const {
  return joined_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Member::joined() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Member.joined)
  return _internal_joined();
}
inline void ClanInfo_Member::_internal_set_joined(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  joined_ = m_iValue;
}
inline void ClanInfo_Member::set_joined(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_joined(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Member.joined)
}

// required int64 lastSeen = 4;
inline bool ClanInfo_Member::_internal_has_lastseen() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Member::has_lastseen() const {
  return _internal_has_lastseen();
}
inline void ClanInfo_Member::clear_lastseen() {
  lastseen_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Member::_internal_lastseen() const {
  return lastseen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Member::lastseen() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Member.lastSeen)
  return _internal_lastseen();
}
inline void ClanInfo_Member::_internal_set_lastseen(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  lastseen_ = m_iValue;
}
inline void ClanInfo_Member::set_lastseen(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_lastseen(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Member.lastSeen)
}

// optional string notes = 5;
inline bool ClanInfo_Member::_internal_has_notes() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Member::has_notes() const {
  return _internal_has_notes();
}
inline void ClanInfo_Member::clear_notes() {
  notes_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClanInfo_Member::notes() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Member.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanInfo_Member::set_notes(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 notes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Member.notes)
}
inline std::string* ClanInfo_Member::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.Member.notes)
  return _s;
}
inline const std::string& ClanInfo_Member::_internal_notes() const {
  return notes_.Get();
}
inline void ClanInfo_Member::_internal_set_notes(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  notes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanInfo_Member::_internal_mutable_notes() {
  _has_bits_[0] |= 0x00000001u;
  return notes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanInfo_Member::release_notes() {
  // @@protoc_insertion_point(field_release:rustplus.ClanInfo.Member.notes)
  if (!_internal_has_notes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return notes_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanInfo_Member::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  notes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), notes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanInfo.Member.notes)
}

// optional bool online = 6;
inline bool ClanInfo_Member::_internal_has_online() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Member::has_online() const {
  return _internal_has_online();
}
inline void ClanInfo_Member::clear_online() {
  online_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ClanInfo_Member::_internal_online() const {
  return online_;
}
inline bool ClanInfo_Member::online() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Member.online)
  return _internal_online();
}
inline void ClanInfo_Member::_internal_set_online(bool m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  online_ = m_iValue;
}
inline void ClanInfo_Member::set_online(bool m_iValue) {
  _internal_set_online(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Member.online)
}

// -------------------------------------------------------------------

// ClanInfo_Invite

// required int64 steamId = 1;
inline bool ClanInfo_Invite::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Invite::has_steamid() const {
  return _internal_has_steamid();
}
inline void ClanInfo_Invite::clear_steamid() {
  steamid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Invite::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Invite::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Invite.steamId)
  return _internal_steamid();
}
inline void ClanInfo_Invite::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = m_iValue;
}
inline void ClanInfo_Invite::set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Invite.steamId)
}

// required int64 recruiter = 2;
inline bool ClanInfo_Invite::_internal_has_recruiter() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Invite::has_recruiter() const {
  return _internal_has_recruiter();
}
inline void ClanInfo_Invite::clear_recruiter() {
  recruiter_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Invite::_internal_recruiter() const {
  return recruiter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Invite::recruiter() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Invite.recruiter)
  return _internal_recruiter();
}
inline void ClanInfo_Invite::_internal_set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  recruiter_ = m_iValue;
}
inline void ClanInfo_Invite::set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_recruiter(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Invite.recruiter)
}

// required int64 timestamp = 3;
inline bool ClanInfo_Invite::_internal_has_timestamp() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanInfo_Invite::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ClanInfo_Invite::clear_timestamp() {
  timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Invite::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo_Invite::timestamp() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.Invite.timestamp)
  return _internal_timestamp();
}
inline void ClanInfo_Invite::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = m_iValue;
}
inline void ClanInfo_Invite::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_timestamp(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.Invite.timestamp)
}

// -------------------------------------------------------------------

// ClanInfo

// required int64 clanId = 1;
inline bool ClanInfo::_internal_has_clanid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_clanid() const {
  return _internal_has_clanid();
}
inline void ClanInfo::clear_clanid() {
  clanid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::_internal_clanid() const {
  return clanid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::clanid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.clanId)
  return _internal_clanid();
}
inline void ClanInfo::_internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  clanid_ = m_iValue;
}
inline void ClanInfo::set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_clanid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.clanId)
}

// required string name = 2;
inline bool ClanInfo::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_name() const {
  return _internal_has_name();
}
inline void ClanInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClanInfo::name() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.name)
}
inline std::string* ClanInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.name)
  return _s;
}
inline const std::string& ClanInfo::_internal_name() const {
  return name_.Get();
}
inline void ClanInfo::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanInfo::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.ClanInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanInfo.name)
}

// required int64 created = 3;
inline bool ClanInfo::_internal_has_created() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_created() const {
  return _internal_has_created();
}
inline void ClanInfo::clear_created() {
  created_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::_internal_created() const {
  return created_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::created() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.created)
  return _internal_created();
}
inline void ClanInfo::_internal_set_created(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  created_ = m_iValue;
}
inline void ClanInfo::set_created(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_created(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.created)
}

// required int64 creator = 4;
inline bool ClanInfo::_internal_has_creator() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_creator() const {
  return _internal_has_creator();
}
inline void ClanInfo::clear_creator() {
  creator_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::_internal_creator() const {
  return creator_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::creator() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.creator)
  return _internal_creator();
}
inline void ClanInfo::_internal_set_creator(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  creator_ = m_iValue;
}
inline void ClanInfo::set_creator(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_creator(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.creator)
}

// optional string motd = 5;
inline bool ClanInfo::_internal_has_motd() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_motd() const {
  return _internal_has_motd();
}
inline void ClanInfo::clear_motd() {
  motd_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClanInfo::motd() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.motd)
  return _internal_motd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanInfo::set_motd(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 motd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.motd)
}
inline std::string* ClanInfo::mutable_motd() {
  std::string* _s = _internal_mutable_motd();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.motd)
  return _s;
}
inline const std::string& ClanInfo::_internal_motd() const {
  return motd_.Get();
}
inline void ClanInfo::_internal_set_motd(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  motd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanInfo::_internal_mutable_motd() {
  _has_bits_[0] |= 0x00000002u;
  return motd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanInfo::release_motd() {
  // @@protoc_insertion_point(field_release:rustplus.ClanInfo.motd)
  if (!_internal_has_motd()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return motd_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanInfo::set_allocated_motd(std::string* motd) {
  if (motd != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  motd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), motd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanInfo.motd)
}

// optional int64 motdTimestamp = 6;
inline bool ClanInfo::_internal_has_motdtimestamp() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_motdtimestamp() const {
  return _internal_has_motdtimestamp();
}
inline void ClanInfo::clear_motdtimestamp() {
  motdtimestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::_internal_motdtimestamp() const {
  return motdtimestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::motdtimestamp() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.motdTimestamp)
  return _internal_motdtimestamp();
}
inline void ClanInfo::_internal_set_motdtimestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000040u;
  motdtimestamp_ = m_iValue;
}
inline void ClanInfo::set_motdtimestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_motdtimestamp(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.motdTimestamp)
}

// optional int64 motdAuthor = 7;
inline bool ClanInfo::_internal_has_motdauthor() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_motdauthor() const {
  return _internal_has_motdauthor();
}
inline void ClanInfo::clear_motdauthor() {
  motdauthor_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::_internal_motdauthor() const {
  return motdauthor_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInfo::motdauthor() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.motdAuthor)
  return _internal_motdauthor();
}
inline void ClanInfo::_internal_set_motdauthor(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000080u;
  motdauthor_ = m_iValue;
}
inline void ClanInfo::set_motdauthor(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_motdauthor(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.motdAuthor)
}

// optional bytes logo = 8;
inline bool ClanInfo::_internal_has_logo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_logo() const {
  return _internal_has_logo();
}
inline void ClanInfo::clear_logo() {
  logo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClanInfo::logo() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.logo)
  return _internal_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanInfo::set_logo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 logo_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.logo)
}
inline std::string* ClanInfo::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.logo)
  return _s;
}
inline const std::string& ClanInfo::_internal_logo() const {
  return logo_.Get();
}
inline void ClanInfo::_internal_set_logo(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  logo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanInfo::_internal_mutable_logo() {
  _has_bits_[0] |= 0x00000004u;
  return logo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanInfo::release_logo() {
  // @@protoc_insertion_point(field_release:rustplus.ClanInfo.logo)
  if (!_internal_has_logo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return logo_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanInfo::set_allocated_logo(std::string* logo) {
  if (logo != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  logo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanInfo.logo)
}

// optional sint32 color = 9;
inline bool ClanInfo::_internal_has_color() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_color() const {
  return _internal_has_color();
}
inline void ClanInfo::clear_color() {
  color_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo::color() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.color)
  return _internal_color();
}
inline void ClanInfo::_internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000100u;
  color_ = m_iValue;
}
inline void ClanInfo::set_color(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_color(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.color)
}

// repeated .rustplus.ClanInfo.Role roles = 10;
inline int ClanInfo::_internal_roles_size() const {
  return roles_.size();
}
inline int ClanInfo::roles_size() const {
  return _internal_roles_size();
}
inline void ClanInfo::clear_roles() {
  roles_.Clear();
}
inline ::rustplus::ClanInfo_Role* ClanInfo::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.roles)
  return roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Role >*
ClanInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.ClanInfo.roles)
  return &roles_;
}
inline const ::rustplus::ClanInfo_Role& ClanInfo::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const ::rustplus::ClanInfo_Role& ClanInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.roles)
  return _internal_roles(index);
}
inline ::rustplus::ClanInfo_Role* ClanInfo::_internal_add_roles() {
  return roles_.Add();
}
inline ::rustplus::ClanInfo_Role* ClanInfo::add_roles() {
  ::rustplus::ClanInfo_Role* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:rustplus.ClanInfo.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Role >&
ClanInfo::roles() const {
  // @@protoc_insertion_point(field_list:rustplus.ClanInfo.roles)
  return roles_;
}

// repeated .rustplus.ClanInfo.Member members = 11;
inline int ClanInfo::_internal_members_size() const {
  return members_.size();
}
inline int ClanInfo::members_size() const {
  return _internal_members_size();
}
inline void ClanInfo::clear_members() {
  members_.Clear();
}
inline ::rustplus::ClanInfo_Member* ClanInfo::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Member >*
ClanInfo::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.ClanInfo.members)
  return &members_;
}
inline const ::rustplus::ClanInfo_Member& ClanInfo::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::rustplus::ClanInfo_Member& ClanInfo::members(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.members)
  return _internal_members(index);
}
inline ::rustplus::ClanInfo_Member* ClanInfo::_internal_add_members() {
  return members_.Add();
}
inline ::rustplus::ClanInfo_Member* ClanInfo::add_members() {
  ::rustplus::ClanInfo_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:rustplus.ClanInfo.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Member >&
ClanInfo::members() const {
  // @@protoc_insertion_point(field_list:rustplus.ClanInfo.members)
  return members_;
}

// repeated .rustplus.ClanInfo.Invite invites = 12;
inline int ClanInfo::_internal_invites_size() const {
  return invites_.size();
}
inline int ClanInfo::invites_size() const {
  return _internal_invites_size();
}
inline void ClanInfo::clear_invites() {
  invites_.Clear();
}
inline ::rustplus::ClanInfo_Invite* ClanInfo::mutable_invites(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInfo.invites)
  return invites_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Invite >*
ClanInfo::mutable_invites() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.ClanInfo.invites)
  return &invites_;
}
inline const ::rustplus::ClanInfo_Invite& ClanInfo::_internal_invites(int index) const {
  return invites_.Get(index);
}
inline const ::rustplus::ClanInfo_Invite& ClanInfo::invites(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.invites)
  return _internal_invites(index);
}
inline ::rustplus::ClanInfo_Invite* ClanInfo::_internal_add_invites() {
  return invites_.Add();
}
inline ::rustplus::ClanInfo_Invite* ClanInfo::add_invites() {
  ::rustplus::ClanInfo_Invite* _add = _internal_add_invites();
  // @@protoc_insertion_point(field_add:rustplus.ClanInfo.invites)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInfo_Invite >&
ClanInfo::invites() const {
  // @@protoc_insertion_point(field_list:rustplus.ClanInfo.invites)
  return invites_;
}

// optional int32 maxMemberCount = 13;
inline bool ClanInfo::_internal_has_maxmembercount() const {
  bool m_iValue = (_has_bits_[0] & 0x00000200u) != 0;
  return m_iValue;
}
inline bool ClanInfo::has_maxmembercount() const {
  return _internal_has_maxmembercount();
}
inline void ClanInfo::clear_maxmembercount() {
  maxmembercount_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo::_internal_maxmembercount() const {
  return maxmembercount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClanInfo::maxmembercount() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInfo.maxMemberCount)
  return _internal_maxmembercount();
}
inline void ClanInfo::_internal_set_maxmembercount(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000200u;
  maxmembercount_ = m_iValue;
}
inline void ClanInfo::set_maxmembercount(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_maxmembercount(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInfo.maxMemberCount)
}

// -------------------------------------------------------------------

// ClanLog_Entry

// required int64 timestamp = 1;
inline bool ClanLog_Entry::_internal_has_timestamp() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool ClanLog_Entry::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ClanLog_Entry::clear_timestamp() {
  timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanLog_Entry::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanLog_Entry::timestamp() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.Entry.timestamp)
  return _internal_timestamp();
}
inline void ClanLog_Entry::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  timestamp_ = m_iValue;
}
inline void ClanLog_Entry::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_timestamp(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.Entry.timestamp)
}

// required string eventKey = 2;
inline bool ClanLog_Entry::_internal_has_eventkey() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanLog_Entry::has_eventkey() const {
  return _internal_has_eventkey();
}
inline void ClanLog_Entry::clear_eventkey() {
  eventkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClanLog_Entry::eventkey() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.Entry.eventKey)
  return _internal_eventkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanLog_Entry::set_eventkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 eventkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.Entry.eventKey)
}
inline std::string* ClanLog_Entry::mutable_eventkey() {
  std::string* _s = _internal_mutable_eventkey();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanLog.Entry.eventKey)
  return _s;
}
inline const std::string& ClanLog_Entry::_internal_eventkey() const {
  return eventkey_.Get();
}
inline void ClanLog_Entry::_internal_set_eventkey(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  eventkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::_internal_mutable_eventkey() {
  _has_bits_[0] |= 0x00000001u;
  return eventkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::release_eventkey() {
  // @@protoc_insertion_point(field_release:rustplus.ClanLog.Entry.eventKey)
  if (!_internal_has_eventkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return eventkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanLog_Entry::set_allocated_eventkey(std::string* eventkey) {
  if (eventkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  eventkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), eventkey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanLog.Entry.eventKey)
}

// optional string arg1 = 3;
inline bool ClanLog_Entry::_internal_has_arg1() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanLog_Entry::has_arg1() const {
  return _internal_has_arg1();
}
inline void ClanLog_Entry::clear_arg1() {
  arg1_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClanLog_Entry::arg1() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.Entry.arg1)
  return _internal_arg1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanLog_Entry::set_arg1(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 arg1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.Entry.arg1)
}
inline std::string* ClanLog_Entry::mutable_arg1() {
  std::string* _s = _internal_mutable_arg1();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanLog.Entry.arg1)
  return _s;
}
inline const std::string& ClanLog_Entry::_internal_arg1() const {
  return arg1_.Get();
}
inline void ClanLog_Entry::_internal_set_arg1(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  arg1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::_internal_mutable_arg1() {
  _has_bits_[0] |= 0x00000002u;
  return arg1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::release_arg1() {
  // @@protoc_insertion_point(field_release:rustplus.ClanLog.Entry.arg1)
  if (!_internal_has_arg1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return arg1_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanLog_Entry::set_allocated_arg1(std::string* arg1) {
  if (arg1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  arg1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg1,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanLog.Entry.arg1)
}

// optional string arg2 = 4;
inline bool ClanLog_Entry::_internal_has_arg2() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanLog_Entry::has_arg2() const {
  return _internal_has_arg2();
}
inline void ClanLog_Entry::clear_arg2() {
  arg2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClanLog_Entry::arg2() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.Entry.arg2)
  return _internal_arg2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanLog_Entry::set_arg2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 arg2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.Entry.arg2)
}
inline std::string* ClanLog_Entry::mutable_arg2() {
  std::string* _s = _internal_mutable_arg2();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanLog.Entry.arg2)
  return _s;
}
inline const std::string& ClanLog_Entry::_internal_arg2() const {
  return arg2_.Get();
}
inline void ClanLog_Entry::_internal_set_arg2(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  arg2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::_internal_mutable_arg2() {
  _has_bits_[0] |= 0x00000004u;
  return arg2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::release_arg2() {
  // @@protoc_insertion_point(field_release:rustplus.ClanLog.Entry.arg2)
  if (!_internal_has_arg2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return arg2_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanLog_Entry::set_allocated_arg2(std::string* arg2) {
  if (arg2 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  arg2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanLog.Entry.arg2)
}

// optional string arg3 = 5;
inline bool ClanLog_Entry::_internal_has_arg3() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool ClanLog_Entry::has_arg3() const {
  return _internal_has_arg3();
}
inline void ClanLog_Entry::clear_arg3() {
  arg3_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClanLog_Entry::arg3() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.Entry.arg3)
  return _internal_arg3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanLog_Entry::set_arg3(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 arg3_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.Entry.arg3)
}
inline std::string* ClanLog_Entry::mutable_arg3() {
  std::string* _s = _internal_mutable_arg3();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanLog.Entry.arg3)
  return _s;
}
inline const std::string& ClanLog_Entry::_internal_arg3() const {
  return arg3_.Get();
}
inline void ClanLog_Entry::_internal_set_arg3(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  arg3_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::_internal_mutable_arg3() {
  _has_bits_[0] |= 0x00000008u;
  return arg3_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::release_arg3() {
  // @@protoc_insertion_point(field_release:rustplus.ClanLog.Entry.arg3)
  if (!_internal_has_arg3()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return arg3_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanLog_Entry::set_allocated_arg3(std::string* arg3) {
  if (arg3 != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  arg3_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg3,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanLog.Entry.arg3)
}

// optional string arg4 = 6;
inline bool ClanLog_Entry::_internal_has_arg4() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool ClanLog_Entry::has_arg4() const {
  return _internal_has_arg4();
}
inline void ClanLog_Entry::clear_arg4() {
  arg4_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ClanLog_Entry::arg4() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.Entry.arg4)
  return _internal_arg4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClanLog_Entry::set_arg4(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 arg4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.Entry.arg4)
}
inline std::string* ClanLog_Entry::mutable_arg4() {
  std::string* _s = _internal_mutable_arg4();
  // @@protoc_insertion_point(field_mutable:rustplus.ClanLog.Entry.arg4)
  return _s;
}
inline const std::string& ClanLog_Entry::_internal_arg4() const {
  return arg4_.Get();
}
inline void ClanLog_Entry::_internal_set_arg4(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  arg4_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::_internal_mutable_arg4() {
  _has_bits_[0] |= 0x00000010u;
  return arg4_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClanLog_Entry::release_arg4() {
  // @@protoc_insertion_point(field_release:rustplus.ClanLog.Entry.arg4)
  if (!_internal_has_arg4()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return arg4_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClanLog_Entry::set_allocated_arg4(std::string* arg4) {
  if (arg4 != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  arg4_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg4,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.ClanLog.Entry.arg4)
}

// -------------------------------------------------------------------

// ClanLog

// required int64 clanId = 1;
inline bool ClanLog::_internal_has_clanid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanLog::has_clanid() const {
  return _internal_has_clanid();
}
inline void ClanLog::clear_clanid() {
  clanid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanLog::_internal_clanid() const {
  return clanid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanLog::clanid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.clanId)
  return _internal_clanid();
}
inline void ClanLog::_internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  clanid_ = m_iValue;
}
inline void ClanLog::set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_clanid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanLog.clanId)
}

// repeated .rustplus.ClanLog.Entry logEntries = 2;
inline int ClanLog::_internal_logentries_size() const {
  return logentries_.size();
}
inline int ClanLog::logentries_size() const {
  return _internal_logentries_size();
}
inline void ClanLog::clear_logentries() {
  logentries_.Clear();
}
inline ::rustplus::ClanLog_Entry* ClanLog::mutable_logentries(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.ClanLog.logEntries)
  return logentries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanLog_Entry >*
ClanLog::mutable_logentries() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.ClanLog.logEntries)
  return &logentries_;
}
inline const ::rustplus::ClanLog_Entry& ClanLog::_internal_logentries(int index) const {
  return logentries_.Get(index);
}
inline const ::rustplus::ClanLog_Entry& ClanLog::logentries(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.ClanLog.logEntries)
  return _internal_logentries(index);
}
inline ::rustplus::ClanLog_Entry* ClanLog::_internal_add_logentries() {
  return logentries_.Add();
}
inline ::rustplus::ClanLog_Entry* ClanLog::add_logentries() {
  ::rustplus::ClanLog_Entry* _add = _internal_add_logentries();
  // @@protoc_insertion_point(field_add:rustplus.ClanLog.logEntries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanLog_Entry >&
ClanLog::logentries() const {
  // @@protoc_insertion_point(field_list:rustplus.ClanLog.logEntries)
  return logentries_;
}

// -------------------------------------------------------------------

// ClanInvitations_Invitation

// required int64 clanId = 1;
inline bool ClanInvitations_Invitation::_internal_has_clanid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool ClanInvitations_Invitation::has_clanid() const {
  return _internal_has_clanid();
}
inline void ClanInvitations_Invitation::clear_clanid() {
  clanid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInvitations_Invitation::_internal_clanid() const {
  return clanid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInvitations_Invitation::clanid() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInvitations.Invitation.clanId)
  return _internal_clanid();
}
inline void ClanInvitations_Invitation::_internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  clanid_ = m_iValue;
}
inline void ClanInvitations_Invitation::set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_clanid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInvitations.Invitation.clanId)
}

// required int64 recruiter = 2;
inline bool ClanInvitations_Invitation::_internal_has_recruiter() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool ClanInvitations_Invitation::has_recruiter() const {
  return _internal_has_recruiter();
}
inline void ClanInvitations_Invitation::clear_recruiter() {
  recruiter_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInvitations_Invitation::_internal_recruiter() const {
  return recruiter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInvitations_Invitation::recruiter() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInvitations.Invitation.recruiter)
  return _internal_recruiter();
}
inline void ClanInvitations_Invitation::_internal_set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  recruiter_ = m_iValue;
}
inline void ClanInvitations_Invitation::set_recruiter(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_recruiter(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInvitations.Invitation.recruiter)
}

// required int64 timestamp = 3;
inline bool ClanInvitations_Invitation::_internal_has_timestamp() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool ClanInvitations_Invitation::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ClanInvitations_Invitation::clear_timestamp() {
  timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInvitations_Invitation::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ClanInvitations_Invitation::timestamp() const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInvitations.Invitation.timestamp)
  return _internal_timestamp();
}
inline void ClanInvitations_Invitation::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = m_iValue;
}
inline void ClanInvitations_Invitation::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_timestamp(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.ClanInvitations.Invitation.timestamp)
}

// -------------------------------------------------------------------

// ClanInvitations

// repeated .rustplus.ClanInvitations.Invitation invitations = 1;
inline int ClanInvitations::_internal_invitations_size() const {
  return invitations_.size();
}
inline int ClanInvitations::invitations_size() const {
  return _internal_invitations_size();
}
inline void ClanInvitations::clear_invitations() {
  invitations_.Clear();
}
inline ::rustplus::ClanInvitations_Invitation* ClanInvitations::mutable_invitations(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.ClanInvitations.invitations)
  return invitations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInvitations_Invitation >*
ClanInvitations::mutable_invitations() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.ClanInvitations.invitations)
  return &invitations_;
}
inline const ::rustplus::ClanInvitations_Invitation& ClanInvitations::_internal_invitations(int index) const {
  return invitations_.Get(index);
}
inline const ::rustplus::ClanInvitations_Invitation& ClanInvitations::invitations(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.ClanInvitations.invitations)
  return _internal_invitations(index);
}
inline ::rustplus::ClanInvitations_Invitation* ClanInvitations::_internal_add_invitations() {
  return invitations_.Add();
}
inline ::rustplus::ClanInvitations_Invitation* ClanInvitations::add_invitations() {
  ::rustplus::ClanInvitations_Invitation* _add = _internal_add_invitations();
  // @@protoc_insertion_point(field_add:rustplus.ClanInvitations.invitations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::ClanInvitations_Invitation >&
ClanInvitations::invitations() const {
  // @@protoc_insertion_point(field_list:rustplus.ClanInvitations.invitations)
  return invitations_;
}

// -------------------------------------------------------------------

// AppRequest

// required uint32 seq = 1;
inline bool AppRequest::_internal_has_seq() const {
  bool m_iValue = (_has_bits_[0] & 0x00200000u) != 0;
  return m_iValue;
}
inline bool AppRequest::has_seq() const {
  return _internal_has_seq();
}
inline void AppRequest::clear_seq() {
  seq_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppRequest::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppRequest::seq() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.seq)
  return _internal_seq();
}
inline void AppRequest::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00200000u;
  seq_ = m_iValue;
}
inline void AppRequest::set_seq(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_seq(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppRequest.seq)
}

// required uint64 playerId = 2;
inline bool AppRequest::_internal_has_playerid() const {
  bool m_iValue = (_has_bits_[0] & 0x00100000u) != 0;
  return m_iValue;
}
inline bool AppRequest::has_playerid() const {
  return _internal_has_playerid();
}
inline void AppRequest::clear_playerid() {
  playerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppRequest::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppRequest::playerid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.playerId)
  return _internal_playerid();
}
inline void AppRequest::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00100000u;
  playerid_ = m_iValue;
}
inline void AppRequest::set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_playerid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppRequest.playerId)
}

// required int32 playerToken = 3;
inline bool AppRequest::_internal_has_playertoken() const {
  bool m_iValue = (_has_bits_[0] & 0x00400000u) != 0;
  return m_iValue;
}
inline bool AppRequest::has_playertoken() const {
  return _internal_has_playertoken();
}
inline void AppRequest::clear_playertoken() {
  playertoken_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppRequest::_internal_playertoken() const {
  return playertoken_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppRequest::playertoken() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.playerToken)
  return _internal_playertoken();
}
inline void AppRequest::_internal_set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00400000u;
  playertoken_ = m_iValue;
}
inline void AppRequest::set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_playertoken(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppRequest.playerToken)
}

// optional uint32 entityId = 4;
inline bool AppRequest::_internal_has_entityid() const {
  bool m_iValue = (_has_bits_[0] & 0x00800000u) != 0;
  return m_iValue;
}
inline bool AppRequest::has_entityid() const {
  return _internal_has_entityid();
}
inline void AppRequest::clear_entityid() {
  entityid_ = 0u;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppRequest::_internal_entityid() const {
  return entityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppRequest::entityid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.entityId)
  return _internal_entityid();
}
inline void AppRequest::_internal_set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00800000u;
  entityid_ = m_iValue;
}
inline void AppRequest::set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_entityid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppRequest.entityId)
}

// optional .rustplus.AppEmpty getInfo = 8;
inline bool AppRequest::_internal_has_getinfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getinfo_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getinfo() const {
  return _internal_has_getinfo();
}
inline void AppRequest::clear_getinfo() {
  if (getinfo_ != nullptr) getinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getinfo() const {
  const ::rustplus::AppEmpty* p = getinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getinfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getInfo)
  return _internal_getinfo();
}
inline void AppRequest::unsafe_arena_set_allocated_getinfo(
    ::rustplus::AppEmpty* getinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getinfo_);
  }
  getinfo_ = getinfo;
  if (getinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getInfo)
}
inline ::rustplus::AppEmpty* AppRequest::release_getinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppEmpty* temp = getinfo_;
  getinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getinfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppEmpty* temp = getinfo_;
  getinfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (getinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getinfo_ = p;
  }
  return getinfo_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getinfo() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getinfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getInfo)
  return _msg;
}
inline void AppRequest::set_allocated_getinfo(::rustplus::AppEmpty* getinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getinfo_;
  }
  if (getinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getinfo);
    if (message_arena != submessage_arena) {
      getinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  getinfo_ = getinfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getInfo)
}

// optional .rustplus.AppEmpty getTime = 9;
inline bool AppRequest::_internal_has_gettime() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || gettime_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_gettime() const {
  return _internal_has_gettime();
}
inline void AppRequest::clear_gettime() {
  if (gettime_ != nullptr) gettime_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_gettime() const {
  const ::rustplus::AppEmpty* p = gettime_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::gettime() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getTime)
  return _internal_gettime();
}
inline void AppRequest::unsafe_arena_set_allocated_gettime(
    ::rustplus::AppEmpty* gettime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gettime_);
  }
  gettime_ = gettime;
  if (gettime) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getTime)
}
inline ::rustplus::AppEmpty* AppRequest::release_gettime() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppEmpty* temp = gettime_;
  gettime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_gettime() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getTime)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppEmpty* temp = gettime_;
  gettime_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_gettime() {
  _has_bits_[0] |= 0x00000002u;
  if (gettime_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    gettime_ = p;
  }
  return gettime_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_gettime() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_gettime();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getTime)
  return _msg;
}
inline void AppRequest::set_allocated_gettime(::rustplus::AppEmpty* gettime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gettime_;
  }
  if (gettime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(gettime);
    if (message_arena != submessage_arena) {
      gettime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gettime, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gettime_ = gettime;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getTime)
}

// optional .rustplus.AppEmpty getMap = 10;
inline bool AppRequest::_internal_has_getmap() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getmap_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getmap() const {
  return _internal_has_getmap();
}
inline void AppRequest::clear_getmap() {
  if (getmap_ != nullptr) getmap_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getmap() const {
  const ::rustplus::AppEmpty* p = getmap_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getmap() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getMap)
  return _internal_getmap();
}
inline void AppRequest::unsafe_arena_set_allocated_getmap(
    ::rustplus::AppEmpty* getmap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getmap_);
  }
  getmap_ = getmap;
  if (getmap) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getMap)
}
inline ::rustplus::AppEmpty* AppRequest::release_getmap() {
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::AppEmpty* temp = getmap_;
  getmap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getmap() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getMap)
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::AppEmpty* temp = getmap_;
  getmap_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getmap() {
  _has_bits_[0] |= 0x00000004u;
  if (getmap_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getmap_ = p;
  }
  return getmap_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getmap() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getmap();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getMap)
  return _msg;
}
inline void AppRequest::set_allocated_getmap(::rustplus::AppEmpty* getmap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getmap_;
  }
  if (getmap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getmap);
    if (message_arena != submessage_arena) {
      getmap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getmap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  getmap_ = getmap;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getMap)
}

// optional .rustplus.AppEmpty getTeamInfo = 11;
inline bool AppRequest::_internal_has_getteaminfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getteaminfo_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getteaminfo() const {
  return _internal_has_getteaminfo();
}
inline void AppRequest::clear_getteaminfo() {
  if (getteaminfo_ != nullptr) getteaminfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getteaminfo() const {
  const ::rustplus::AppEmpty* p = getteaminfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getteaminfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getTeamInfo)
  return _internal_getteaminfo();
}
inline void AppRequest::unsafe_arena_set_allocated_getteaminfo(
    ::rustplus::AppEmpty* getteaminfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getteaminfo_);
  }
  getteaminfo_ = getteaminfo;
  if (getteaminfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getTeamInfo)
}
inline ::rustplus::AppEmpty* AppRequest::release_getteaminfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::AppEmpty* temp = getteaminfo_;
  getteaminfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getteaminfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getTeamInfo)
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::AppEmpty* temp = getteaminfo_;
  getteaminfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getteaminfo() {
  _has_bits_[0] |= 0x00000008u;
  if (getteaminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getteaminfo_ = p;
  }
  return getteaminfo_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getteaminfo() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getteaminfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getTeamInfo)
  return _msg;
}
inline void AppRequest::set_allocated_getteaminfo(::rustplus::AppEmpty* getteaminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getteaminfo_;
  }
  if (getteaminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getteaminfo);
    if (message_arena != submessage_arena) {
      getteaminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getteaminfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  getteaminfo_ = getteaminfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getTeamInfo)
}

// optional .rustplus.AppEmpty getTeamChat = 12;
inline bool AppRequest::_internal_has_getteamchat() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getteamchat_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getteamchat() const {
  return _internal_has_getteamchat();
}
inline void AppRequest::clear_getteamchat() {
  if (getteamchat_ != nullptr) getteamchat_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getteamchat() const {
  const ::rustplus::AppEmpty* p = getteamchat_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getteamchat() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getTeamChat)
  return _internal_getteamchat();
}
inline void AppRequest::unsafe_arena_set_allocated_getteamchat(
    ::rustplus::AppEmpty* getteamchat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getteamchat_);
  }
  getteamchat_ = getteamchat;
  if (getteamchat) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getTeamChat)
}
inline ::rustplus::AppEmpty* AppRequest::release_getteamchat() {
  _has_bits_[0] &= ~0x00000010u;
  ::rustplus::AppEmpty* temp = getteamchat_;
  getteamchat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getteamchat() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getTeamChat)
  _has_bits_[0] &= ~0x00000010u;
  ::rustplus::AppEmpty* temp = getteamchat_;
  getteamchat_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getteamchat() {
  _has_bits_[0] |= 0x00000010u;
  if (getteamchat_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getteamchat_ = p;
  }
  return getteamchat_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getteamchat() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getteamchat();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getTeamChat)
  return _msg;
}
inline void AppRequest::set_allocated_getteamchat(::rustplus::AppEmpty* getteamchat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getteamchat_;
  }
  if (getteamchat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getteamchat);
    if (message_arena != submessage_arena) {
      getteamchat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getteamchat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  getteamchat_ = getteamchat;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getTeamChat)
}

// optional .rustplus.AppSendMessage sendTeamMessage = 13;
inline bool AppRequest::_internal_has_sendteammessage() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!m_iValue || sendteammessage_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_sendteammessage() const {
  return _internal_has_sendteammessage();
}
inline void AppRequest::clear_sendteammessage() {
  if (sendteammessage_ != nullptr) sendteammessage_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::rustplus::AppSendMessage& AppRequest::_internal_sendteammessage() const {
  const ::rustplus::AppSendMessage* p = sendteammessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppSendMessage&>(
      ::rustplus::_AppSendMessage_default_instance_);
}
inline const ::rustplus::AppSendMessage& AppRequest::sendteammessage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.sendTeamMessage)
  return _internal_sendteammessage();
}
inline void AppRequest::unsafe_arena_set_allocated_sendteammessage(
    ::rustplus::AppSendMessage* sendteammessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sendteammessage_);
  }
  sendteammessage_ = sendteammessage;
  if (sendteammessage) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.sendTeamMessage)
}
inline ::rustplus::AppSendMessage* AppRequest::release_sendteammessage() {
  _has_bits_[0] &= ~0x00000020u;
  ::rustplus::AppSendMessage* temp = sendteammessage_;
  sendteammessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppSendMessage* AppRequest::unsafe_arena_release_sendteammessage() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.sendTeamMessage)
  _has_bits_[0] &= ~0x00000020u;
  ::rustplus::AppSendMessage* temp = sendteammessage_;
  sendteammessage_ = nullptr;
  return temp;
}
inline ::rustplus::AppSendMessage* AppRequest::_internal_mutable_sendteammessage() {
  _has_bits_[0] |= 0x00000020u;
  if (sendteammessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppSendMessage>(GetArenaForAllocation());
    sendteammessage_ = p;
  }
  return sendteammessage_;
}
inline ::rustplus::AppSendMessage* AppRequest::mutable_sendteammessage() {
  ::rustplus::AppSendMessage* _msg = _internal_mutable_sendteammessage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.sendTeamMessage)
  return _msg;
}
inline void AppRequest::set_allocated_sendteammessage(::rustplus::AppSendMessage* sendteammessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sendteammessage_;
  }
  if (sendteammessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppSendMessage>::GetOwningArena(sendteammessage);
    if (message_arena != submessage_arena) {
      sendteammessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sendteammessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  sendteammessage_ = sendteammessage;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.sendTeamMessage)
}

// optional .rustplus.AppEmpty getEntityInfo = 14;
inline bool AppRequest::_internal_has_getentityinfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getentityinfo_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getentityinfo() const {
  return _internal_has_getentityinfo();
}
inline void AppRequest::clear_getentityinfo() {
  if (getentityinfo_ != nullptr) getentityinfo_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getentityinfo() const {
  const ::rustplus::AppEmpty* p = getentityinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getentityinfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getEntityInfo)
  return _internal_getentityinfo();
}
inline void AppRequest::unsafe_arena_set_allocated_getentityinfo(
    ::rustplus::AppEmpty* getentityinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getentityinfo_);
  }
  getentityinfo_ = getentityinfo;
  if (getentityinfo) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getEntityInfo)
}
inline ::rustplus::AppEmpty* AppRequest::release_getentityinfo() {
  _has_bits_[0] &= ~0x00000040u;
  ::rustplus::AppEmpty* temp = getentityinfo_;
  getentityinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getentityinfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getEntityInfo)
  _has_bits_[0] &= ~0x00000040u;
  ::rustplus::AppEmpty* temp = getentityinfo_;
  getentityinfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getentityinfo() {
  _has_bits_[0] |= 0x00000040u;
  if (getentityinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getentityinfo_ = p;
  }
  return getentityinfo_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getentityinfo() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getentityinfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getEntityInfo)
  return _msg;
}
inline void AppRequest::set_allocated_getentityinfo(::rustplus::AppEmpty* getentityinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getentityinfo_;
  }
  if (getentityinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getentityinfo);
    if (message_arena != submessage_arena) {
      getentityinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getentityinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  getentityinfo_ = getentityinfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getEntityInfo)
}

// optional .rustplus.AppSetEntityValue setEntityValue = 15;
inline bool AppRequest::_internal_has_setentityvalue() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!m_iValue || setentityvalue_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_setentityvalue() const {
  return _internal_has_setentityvalue();
}
inline void AppRequest::clear_setentityvalue() {
  if (setentityvalue_ != nullptr) setentityvalue_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::rustplus::AppSetEntityValue& AppRequest::_internal_setentityvalue() const {
  const ::rustplus::AppSetEntityValue* p = setentityvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppSetEntityValue&>(
      ::rustplus::_AppSetEntityValue_default_instance_);
}
inline const ::rustplus::AppSetEntityValue& AppRequest::setentityvalue() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.setEntityValue)
  return _internal_setentityvalue();
}
inline void AppRequest::unsafe_arena_set_allocated_setentityvalue(
    ::rustplus::AppSetEntityValue* setentityvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setentityvalue_);
  }
  setentityvalue_ = setentityvalue;
  if (setentityvalue) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.setEntityValue)
}
inline ::rustplus::AppSetEntityValue* AppRequest::release_setentityvalue() {
  _has_bits_[0] &= ~0x00000080u;
  ::rustplus::AppSetEntityValue* temp = setentityvalue_;
  setentityvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppSetEntityValue* AppRequest::unsafe_arena_release_setentityvalue() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.setEntityValue)
  _has_bits_[0] &= ~0x00000080u;
  ::rustplus::AppSetEntityValue* temp = setentityvalue_;
  setentityvalue_ = nullptr;
  return temp;
}
inline ::rustplus::AppSetEntityValue* AppRequest::_internal_mutable_setentityvalue() {
  _has_bits_[0] |= 0x00000080u;
  if (setentityvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppSetEntityValue>(GetArenaForAllocation());
    setentityvalue_ = p;
  }
  return setentityvalue_;
}
inline ::rustplus::AppSetEntityValue* AppRequest::mutable_setentityvalue() {
  ::rustplus::AppSetEntityValue* _msg = _internal_mutable_setentityvalue();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.setEntityValue)
  return _msg;
}
inline void AppRequest::set_allocated_setentityvalue(::rustplus::AppSetEntityValue* setentityvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete setentityvalue_;
  }
  if (setentityvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppSetEntityValue>::GetOwningArena(setentityvalue);
    if (message_arena != submessage_arena) {
      setentityvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setentityvalue, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  setentityvalue_ = setentityvalue;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.setEntityValue)
}

// optional .rustplus.AppEmpty checkSubscription = 16;
inline bool AppRequest::_internal_has_checksubscription() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!m_iValue || checksubscription_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_checksubscription() const {
  return _internal_has_checksubscription();
}
inline void AppRequest::clear_checksubscription() {
  if (checksubscription_ != nullptr) checksubscription_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_checksubscription() const {
  const ::rustplus::AppEmpty* p = checksubscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::checksubscription() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.checkSubscription)
  return _internal_checksubscription();
}
inline void AppRequest::unsafe_arena_set_allocated_checksubscription(
    ::rustplus::AppEmpty* checksubscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(checksubscription_);
  }
  checksubscription_ = checksubscription;
  if (checksubscription) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.checkSubscription)
}
inline ::rustplus::AppEmpty* AppRequest::release_checksubscription() {
  _has_bits_[0] &= ~0x00000100u;
  ::rustplus::AppEmpty* temp = checksubscription_;
  checksubscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_checksubscription() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.checkSubscription)
  _has_bits_[0] &= ~0x00000100u;
  ::rustplus::AppEmpty* temp = checksubscription_;
  checksubscription_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_checksubscription() {
  _has_bits_[0] |= 0x00000100u;
  if (checksubscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    checksubscription_ = p;
  }
  return checksubscription_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_checksubscription() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_checksubscription();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.checkSubscription)
  return _msg;
}
inline void AppRequest::set_allocated_checksubscription(::rustplus::AppEmpty* checksubscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete checksubscription_;
  }
  if (checksubscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(checksubscription);
    if (message_arena != submessage_arena) {
      checksubscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksubscription, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  checksubscription_ = checksubscription;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.checkSubscription)
}

// optional .rustplus.AppFlag setSubscription = 17;
inline bool AppRequest::_internal_has_setsubscription() const {
  bool m_iValue = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!m_iValue || setsubscription_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_setsubscription() const {
  return _internal_has_setsubscription();
}
inline void AppRequest::clear_setsubscription() {
  if (setsubscription_ != nullptr) setsubscription_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::rustplus::AppFlag& AppRequest::_internal_setsubscription() const {
  const ::rustplus::AppFlag* p = setsubscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppFlag&>(
      ::rustplus::_AppFlag_default_instance_);
}
inline const ::rustplus::AppFlag& AppRequest::setsubscription() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.setSubscription)
  return _internal_setsubscription();
}
inline void AppRequest::unsafe_arena_set_allocated_setsubscription(
    ::rustplus::AppFlag* setsubscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setsubscription_);
  }
  setsubscription_ = setsubscription;
  if (setsubscription) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.setSubscription)
}
inline ::rustplus::AppFlag* AppRequest::release_setsubscription() {
  _has_bits_[0] &= ~0x00000200u;
  ::rustplus::AppFlag* temp = setsubscription_;
  setsubscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppFlag* AppRequest::unsafe_arena_release_setsubscription() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.setSubscription)
  _has_bits_[0] &= ~0x00000200u;
  ::rustplus::AppFlag* temp = setsubscription_;
  setsubscription_ = nullptr;
  return temp;
}
inline ::rustplus::AppFlag* AppRequest::_internal_mutable_setsubscription() {
  _has_bits_[0] |= 0x00000200u;
  if (setsubscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppFlag>(GetArenaForAllocation());
    setsubscription_ = p;
  }
  return setsubscription_;
}
inline ::rustplus::AppFlag* AppRequest::mutable_setsubscription() {
  ::rustplus::AppFlag* _msg = _internal_mutable_setsubscription();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.setSubscription)
  return _msg;
}
inline void AppRequest::set_allocated_setsubscription(::rustplus::AppFlag* setsubscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete setsubscription_;
  }
  if (setsubscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppFlag>::GetOwningArena(setsubscription);
    if (message_arena != submessage_arena) {
      setsubscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setsubscription, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  setsubscription_ = setsubscription;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.setSubscription)
}

// optional .rustplus.AppEmpty getMapMarkers = 18;
inline bool AppRequest::_internal_has_getmapmarkers() const {
  bool m_iValue = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getmapmarkers_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getmapmarkers() const {
  return _internal_has_getmapmarkers();
}
inline void AppRequest::clear_getmapmarkers() {
  if (getmapmarkers_ != nullptr) getmapmarkers_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getmapmarkers() const {
  const ::rustplus::AppEmpty* p = getmapmarkers_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getmapmarkers() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getMapMarkers)
  return _internal_getmapmarkers();
}
inline void AppRequest::unsafe_arena_set_allocated_getmapmarkers(
    ::rustplus::AppEmpty* getmapmarkers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getmapmarkers_);
  }
  getmapmarkers_ = getmapmarkers;
  if (getmapmarkers) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getMapMarkers)
}
inline ::rustplus::AppEmpty* AppRequest::release_getmapmarkers() {
  _has_bits_[0] &= ~0x00000400u;
  ::rustplus::AppEmpty* temp = getmapmarkers_;
  getmapmarkers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getmapmarkers() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getMapMarkers)
  _has_bits_[0] &= ~0x00000400u;
  ::rustplus::AppEmpty* temp = getmapmarkers_;
  getmapmarkers_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getmapmarkers() {
  _has_bits_[0] |= 0x00000400u;
  if (getmapmarkers_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getmapmarkers_ = p;
  }
  return getmapmarkers_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getmapmarkers() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getmapmarkers();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getMapMarkers)
  return _msg;
}
inline void AppRequest::set_allocated_getmapmarkers(::rustplus::AppEmpty* getmapmarkers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getmapmarkers_;
  }
  if (getmapmarkers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getmapmarkers);
    if (message_arena != submessage_arena) {
      getmapmarkers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getmapmarkers, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  getmapmarkers_ = getmapmarkers;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getMapMarkers)
}

// optional .rustplus.AppPromoteToLeader promoteToLeader = 20;
inline bool AppRequest::_internal_has_promotetoleader() const {
  bool m_iValue = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!m_iValue || promotetoleader_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_promotetoleader() const {
  return _internal_has_promotetoleader();
}
inline void AppRequest::clear_promotetoleader() {
  if (promotetoleader_ != nullptr) promotetoleader_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::rustplus::AppPromoteToLeader& AppRequest::_internal_promotetoleader() const {
  const ::rustplus::AppPromoteToLeader* p = promotetoleader_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppPromoteToLeader&>(
      ::rustplus::_AppPromoteToLeader_default_instance_);
}
inline const ::rustplus::AppPromoteToLeader& AppRequest::promotetoleader() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.promoteToLeader)
  return _internal_promotetoleader();
}
inline void AppRequest::unsafe_arena_set_allocated_promotetoleader(
    ::rustplus::AppPromoteToLeader* promotetoleader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(promotetoleader_);
  }
  promotetoleader_ = promotetoleader;
  if (promotetoleader) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.promoteToLeader)
}
inline ::rustplus::AppPromoteToLeader* AppRequest::release_promotetoleader() {
  _has_bits_[0] &= ~0x00000800u;
  ::rustplus::AppPromoteToLeader* temp = promotetoleader_;
  promotetoleader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppPromoteToLeader* AppRequest::unsafe_arena_release_promotetoleader() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.promoteToLeader)
  _has_bits_[0] &= ~0x00000800u;
  ::rustplus::AppPromoteToLeader* temp = promotetoleader_;
  promotetoleader_ = nullptr;
  return temp;
}
inline ::rustplus::AppPromoteToLeader* AppRequest::_internal_mutable_promotetoleader() {
  _has_bits_[0] |= 0x00000800u;
  if (promotetoleader_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppPromoteToLeader>(GetArenaForAllocation());
    promotetoleader_ = p;
  }
  return promotetoleader_;
}
inline ::rustplus::AppPromoteToLeader* AppRequest::mutable_promotetoleader() {
  ::rustplus::AppPromoteToLeader* _msg = _internal_mutable_promotetoleader();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.promoteToLeader)
  return _msg;
}
inline void AppRequest::set_allocated_promotetoleader(::rustplus::AppPromoteToLeader* promotetoleader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete promotetoleader_;
  }
  if (promotetoleader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppPromoteToLeader>::GetOwningArena(promotetoleader);
    if (message_arena != submessage_arena) {
      promotetoleader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, promotetoleader, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  promotetoleader_ = promotetoleader;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.promoteToLeader)
}

// optional .rustplus.AppEmpty getClanInfo = 21;
inline bool AppRequest::_internal_has_getclaninfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getclaninfo_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getclaninfo() const {
  return _internal_has_getclaninfo();
}
inline void AppRequest::clear_getclaninfo() {
  if (getclaninfo_ != nullptr) getclaninfo_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getclaninfo() const {
  const ::rustplus::AppEmpty* p = getclaninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getclaninfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getClanInfo)
  return _internal_getclaninfo();
}
inline void AppRequest::unsafe_arena_set_allocated_getclaninfo(
    ::rustplus::AppEmpty* getclaninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getclaninfo_);
  }
  getclaninfo_ = getclaninfo;
  if (getclaninfo) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getClanInfo)
}
inline ::rustplus::AppEmpty* AppRequest::release_getclaninfo() {
  _has_bits_[0] &= ~0x00001000u;
  ::rustplus::AppEmpty* temp = getclaninfo_;
  getclaninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getclaninfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getClanInfo)
  _has_bits_[0] &= ~0x00001000u;
  ::rustplus::AppEmpty* temp = getclaninfo_;
  getclaninfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getclaninfo() {
  _has_bits_[0] |= 0x00001000u;
  if (getclaninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getclaninfo_ = p;
  }
  return getclaninfo_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getclaninfo() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getclaninfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getClanInfo)
  return _msg;
}
inline void AppRequest::set_allocated_getclaninfo(::rustplus::AppEmpty* getclaninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getclaninfo_;
  }
  if (getclaninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getclaninfo);
    if (message_arena != submessage_arena) {
      getclaninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getclaninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  getclaninfo_ = getclaninfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getClanInfo)
}

// optional .rustplus.AppSendMessage setClanMotd = 22;
inline bool AppRequest::_internal_has_setclanmotd() const {
  bool m_iValue = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || setclanmotd_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_setclanmotd() const {
  return _internal_has_setclanmotd();
}
inline void AppRequest::clear_setclanmotd() {
  if (setclanmotd_ != nullptr) setclanmotd_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::rustplus::AppSendMessage& AppRequest::_internal_setclanmotd() const {
  const ::rustplus::AppSendMessage* p = setclanmotd_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppSendMessage&>(
      ::rustplus::_AppSendMessage_default_instance_);
}
inline const ::rustplus::AppSendMessage& AppRequest::setclanmotd() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.setClanMotd)
  return _internal_setclanmotd();
}
inline void AppRequest::unsafe_arena_set_allocated_setclanmotd(
    ::rustplus::AppSendMessage* setclanmotd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setclanmotd_);
  }
  setclanmotd_ = setclanmotd;
  if (setclanmotd) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.setClanMotd)
}
inline ::rustplus::AppSendMessage* AppRequest::release_setclanmotd() {
  _has_bits_[0] &= ~0x00002000u;
  ::rustplus::AppSendMessage* temp = setclanmotd_;
  setclanmotd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppSendMessage* AppRequest::unsafe_arena_release_setclanmotd() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.setClanMotd)
  _has_bits_[0] &= ~0x00002000u;
  ::rustplus::AppSendMessage* temp = setclanmotd_;
  setclanmotd_ = nullptr;
  return temp;
}
inline ::rustplus::AppSendMessage* AppRequest::_internal_mutable_setclanmotd() {
  _has_bits_[0] |= 0x00002000u;
  if (setclanmotd_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppSendMessage>(GetArenaForAllocation());
    setclanmotd_ = p;
  }
  return setclanmotd_;
}
inline ::rustplus::AppSendMessage* AppRequest::mutable_setclanmotd() {
  ::rustplus::AppSendMessage* _msg = _internal_mutable_setclanmotd();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.setClanMotd)
  return _msg;
}
inline void AppRequest::set_allocated_setclanmotd(::rustplus::AppSendMessage* setclanmotd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete setclanmotd_;
  }
  if (setclanmotd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppSendMessage>::GetOwningArena(setclanmotd);
    if (message_arena != submessage_arena) {
      setclanmotd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setclanmotd, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  setclanmotd_ = setclanmotd;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.setClanMotd)
}

// optional .rustplus.AppEmpty getClanChat = 23;
inline bool AppRequest::_internal_has_getclanchat() const {
  bool m_iValue = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getclanchat_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getclanchat() const {
  return _internal_has_getclanchat();
}
inline void AppRequest::clear_getclanchat() {
  if (getclanchat_ != nullptr) getclanchat_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_getclanchat() const {
  const ::rustplus::AppEmpty* p = getclanchat_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::getclanchat() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getClanChat)
  return _internal_getclanchat();
}
inline void AppRequest::unsafe_arena_set_allocated_getclanchat(
    ::rustplus::AppEmpty* getclanchat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getclanchat_);
  }
  getclanchat_ = getclanchat;
  if (getclanchat) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getClanChat)
}
inline ::rustplus::AppEmpty* AppRequest::release_getclanchat() {
  _has_bits_[0] &= ~0x00004000u;
  ::rustplus::AppEmpty* temp = getclanchat_;
  getclanchat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_getclanchat() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getClanChat)
  _has_bits_[0] &= ~0x00004000u;
  ::rustplus::AppEmpty* temp = getclanchat_;
  getclanchat_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_getclanchat() {
  _has_bits_[0] |= 0x00004000u;
  if (getclanchat_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    getclanchat_ = p;
  }
  return getclanchat_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_getclanchat() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_getclanchat();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getClanChat)
  return _msg;
}
inline void AppRequest::set_allocated_getclanchat(::rustplus::AppEmpty* getclanchat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getclanchat_;
  }
  if (getclanchat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(getclanchat);
    if (message_arena != submessage_arena) {
      getclanchat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getclanchat, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  getclanchat_ = getclanchat;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getClanChat)
}

// optional .rustplus.AppSendMessage sendClanMessage = 24;
inline bool AppRequest::_internal_has_sendclanmessage() const {
  bool m_iValue = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || sendclanmessage_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_sendclanmessage() const {
  return _internal_has_sendclanmessage();
}
inline void AppRequest::clear_sendclanmessage() {
  if (sendclanmessage_ != nullptr) sendclanmessage_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::rustplus::AppSendMessage& AppRequest::_internal_sendclanmessage() const {
  const ::rustplus::AppSendMessage* p = sendclanmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppSendMessage&>(
      ::rustplus::_AppSendMessage_default_instance_);
}
inline const ::rustplus::AppSendMessage& AppRequest::sendclanmessage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.sendClanMessage)
  return _internal_sendclanmessage();
}
inline void AppRequest::unsafe_arena_set_allocated_sendclanmessage(
    ::rustplus::AppSendMessage* sendclanmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sendclanmessage_);
  }
  sendclanmessage_ = sendclanmessage;
  if (sendclanmessage) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.sendClanMessage)
}
inline ::rustplus::AppSendMessage* AppRequest::release_sendclanmessage() {
  _has_bits_[0] &= ~0x00008000u;
  ::rustplus::AppSendMessage* temp = sendclanmessage_;
  sendclanmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppSendMessage* AppRequest::unsafe_arena_release_sendclanmessage() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.sendClanMessage)
  _has_bits_[0] &= ~0x00008000u;
  ::rustplus::AppSendMessage* temp = sendclanmessage_;
  sendclanmessage_ = nullptr;
  return temp;
}
inline ::rustplus::AppSendMessage* AppRequest::_internal_mutable_sendclanmessage() {
  _has_bits_[0] |= 0x00008000u;
  if (sendclanmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppSendMessage>(GetArenaForAllocation());
    sendclanmessage_ = p;
  }
  return sendclanmessage_;
}
inline ::rustplus::AppSendMessage* AppRequest::mutable_sendclanmessage() {
  ::rustplus::AppSendMessage* _msg = _internal_mutable_sendclanmessage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.sendClanMessage)
  return _msg;
}
inline void AppRequest::set_allocated_sendclanmessage(::rustplus::AppSendMessage* sendclanmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sendclanmessage_;
  }
  if (sendclanmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppSendMessage>::GetOwningArena(sendclanmessage);
    if (message_arena != submessage_arena) {
      sendclanmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sendclanmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  sendclanmessage_ = sendclanmessage;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.sendClanMessage)
}

// optional .rustplus.AppGetNexusAuth getNexusAuth = 25;
inline bool AppRequest::_internal_has_getnexusauth() const {
  bool m_iValue = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || getnexusauth_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_getnexusauth() const {
  return _internal_has_getnexusauth();
}
inline void AppRequest::clear_getnexusauth() {
  if (getnexusauth_ != nullptr) getnexusauth_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::rustplus::AppGetNexusAuth& AppRequest::_internal_getnexusauth() const {
  const ::rustplus::AppGetNexusAuth* p = getnexusauth_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppGetNexusAuth&>(
      ::rustplus::_AppGetNexusAuth_default_instance_);
}
inline const ::rustplus::AppGetNexusAuth& AppRequest::getnexusauth() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.getNexusAuth)
  return _internal_getnexusauth();
}
inline void AppRequest::unsafe_arena_set_allocated_getnexusauth(
    ::rustplus::AppGetNexusAuth* getnexusauth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getnexusauth_);
  }
  getnexusauth_ = getnexusauth;
  if (getnexusauth) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.getNexusAuth)
}
inline ::rustplus::AppGetNexusAuth* AppRequest::release_getnexusauth() {
  _has_bits_[0] &= ~0x00010000u;
  ::rustplus::AppGetNexusAuth* temp = getnexusauth_;
  getnexusauth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppGetNexusAuth* AppRequest::unsafe_arena_release_getnexusauth() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.getNexusAuth)
  _has_bits_[0] &= ~0x00010000u;
  ::rustplus::AppGetNexusAuth* temp = getnexusauth_;
  getnexusauth_ = nullptr;
  return temp;
}
inline ::rustplus::AppGetNexusAuth* AppRequest::_internal_mutable_getnexusauth() {
  _has_bits_[0] |= 0x00010000u;
  if (getnexusauth_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppGetNexusAuth>(GetArenaForAllocation());
    getnexusauth_ = p;
  }
  return getnexusauth_;
}
inline ::rustplus::AppGetNexusAuth* AppRequest::mutable_getnexusauth() {
  ::rustplus::AppGetNexusAuth* _msg = _internal_mutable_getnexusauth();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.getNexusAuth)
  return _msg;
}
inline void AppRequest::set_allocated_getnexusauth(::rustplus::AppGetNexusAuth* getnexusauth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getnexusauth_;
  }
  if (getnexusauth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppGetNexusAuth>::GetOwningArena(getnexusauth);
    if (message_arena != submessage_arena) {
      getnexusauth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getnexusauth, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  getnexusauth_ = getnexusauth;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.getNexusAuth)
}

// optional .rustplus.AppCameraSubscribe cameraSubscribe = 30;
inline bool AppRequest::_internal_has_camerasubscribe() const {
  bool m_iValue = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || camerasubscribe_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_camerasubscribe() const {
  return _internal_has_camerasubscribe();
}
inline void AppRequest::clear_camerasubscribe() {
  if (camerasubscribe_ != nullptr) camerasubscribe_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::rustplus::AppCameraSubscribe& AppRequest::_internal_camerasubscribe() const {
  const ::rustplus::AppCameraSubscribe* p = camerasubscribe_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppCameraSubscribe&>(
      ::rustplus::_AppCameraSubscribe_default_instance_);
}
inline const ::rustplus::AppCameraSubscribe& AppRequest::camerasubscribe() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.cameraSubscribe)
  return _internal_camerasubscribe();
}
inline void AppRequest::unsafe_arena_set_allocated_camerasubscribe(
    ::rustplus::AppCameraSubscribe* camerasubscribe) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camerasubscribe_);
  }
  camerasubscribe_ = camerasubscribe;
  if (camerasubscribe) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.cameraSubscribe)
}
inline ::rustplus::AppCameraSubscribe* AppRequest::release_camerasubscribe() {
  _has_bits_[0] &= ~0x00020000u;
  ::rustplus::AppCameraSubscribe* temp = camerasubscribe_;
  camerasubscribe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppCameraSubscribe* AppRequest::unsafe_arena_release_camerasubscribe() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.cameraSubscribe)
  _has_bits_[0] &= ~0x00020000u;
  ::rustplus::AppCameraSubscribe* temp = camerasubscribe_;
  camerasubscribe_ = nullptr;
  return temp;
}
inline ::rustplus::AppCameraSubscribe* AppRequest::_internal_mutable_camerasubscribe() {
  _has_bits_[0] |= 0x00020000u;
  if (camerasubscribe_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppCameraSubscribe>(GetArenaForAllocation());
    camerasubscribe_ = p;
  }
  return camerasubscribe_;
}
inline ::rustplus::AppCameraSubscribe* AppRequest::mutable_camerasubscribe() {
  ::rustplus::AppCameraSubscribe* _msg = _internal_mutable_camerasubscribe();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.cameraSubscribe)
  return _msg;
}
inline void AppRequest::set_allocated_camerasubscribe(::rustplus::AppCameraSubscribe* camerasubscribe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete camerasubscribe_;
  }
  if (camerasubscribe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppCameraSubscribe>::GetOwningArena(camerasubscribe);
    if (message_arena != submessage_arena) {
      camerasubscribe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camerasubscribe, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  camerasubscribe_ = camerasubscribe;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.cameraSubscribe)
}

// optional .rustplus.AppEmpty cameraUnsubscribe = 31;
inline bool AppRequest::_internal_has_cameraunsubscribe() const {
  bool m_iValue = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || cameraunsubscribe_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_cameraunsubscribe() const {
  return _internal_has_cameraunsubscribe();
}
inline void AppRequest::clear_cameraunsubscribe() {
  if (cameraunsubscribe_ != nullptr) cameraunsubscribe_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::rustplus::AppEmpty& AppRequest::_internal_cameraunsubscribe() const {
  const ::rustplus::AppEmpty* p = cameraunsubscribe_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEmpty&>(
      ::rustplus::_AppEmpty_default_instance_);
}
inline const ::rustplus::AppEmpty& AppRequest::cameraunsubscribe() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.cameraUnsubscribe)
  return _internal_cameraunsubscribe();
}
inline void AppRequest::unsafe_arena_set_allocated_cameraunsubscribe(
    ::rustplus::AppEmpty* cameraunsubscribe) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cameraunsubscribe_);
  }
  cameraunsubscribe_ = cameraunsubscribe;
  if (cameraunsubscribe) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.cameraUnsubscribe)
}
inline ::rustplus::AppEmpty* AppRequest::release_cameraunsubscribe() {
  _has_bits_[0] &= ~0x00040000u;
  ::rustplus::AppEmpty* temp = cameraunsubscribe_;
  cameraunsubscribe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::unsafe_arena_release_cameraunsubscribe() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.cameraUnsubscribe)
  _has_bits_[0] &= ~0x00040000u;
  ::rustplus::AppEmpty* temp = cameraunsubscribe_;
  cameraunsubscribe_ = nullptr;
  return temp;
}
inline ::rustplus::AppEmpty* AppRequest::_internal_mutable_cameraunsubscribe() {
  _has_bits_[0] |= 0x00040000u;
  if (cameraunsubscribe_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEmpty>(GetArenaForAllocation());
    cameraunsubscribe_ = p;
  }
  return cameraunsubscribe_;
}
inline ::rustplus::AppEmpty* AppRequest::mutable_cameraunsubscribe() {
  ::rustplus::AppEmpty* _msg = _internal_mutable_cameraunsubscribe();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.cameraUnsubscribe)
  return _msg;
}
inline void AppRequest::set_allocated_cameraunsubscribe(::rustplus::AppEmpty* cameraunsubscribe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cameraunsubscribe_;
  }
  if (cameraunsubscribe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEmpty>::GetOwningArena(cameraunsubscribe);
    if (message_arena != submessage_arena) {
      cameraunsubscribe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cameraunsubscribe, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  cameraunsubscribe_ = cameraunsubscribe;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.cameraUnsubscribe)
}

// optional .rustplus.AppCameraInput cameraInput = 32;
inline bool AppRequest::_internal_has_camerainput() const {
  bool m_iValue = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || camerainput_ != nullptr);
  return m_iValue;
}
inline bool AppRequest::has_camerainput() const {
  return _internal_has_camerainput();
}
inline void AppRequest::clear_camerainput() {
  if (camerainput_ != nullptr) camerainput_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::rustplus::AppCameraInput& AppRequest::_internal_camerainput() const {
  const ::rustplus::AppCameraInput* p = camerainput_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppCameraInput&>(
      ::rustplus::_AppCameraInput_default_instance_);
}
inline const ::rustplus::AppCameraInput& AppRequest::camerainput() const {
  // @@protoc_insertion_point(field_get:rustplus.AppRequest.cameraInput)
  return _internal_camerainput();
}
inline void AppRequest::unsafe_arena_set_allocated_camerainput(
    ::rustplus::AppCameraInput* camerainput) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camerainput_);
  }
  camerainput_ = camerainput;
  if (camerainput) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppRequest.cameraInput)
}
inline ::rustplus::AppCameraInput* AppRequest::release_camerainput() {
  _has_bits_[0] &= ~0x00080000u;
  ::rustplus::AppCameraInput* temp = camerainput_;
  camerainput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppCameraInput* AppRequest::unsafe_arena_release_camerainput() {
  // @@protoc_insertion_point(field_release:rustplus.AppRequest.cameraInput)
  _has_bits_[0] &= ~0x00080000u;
  ::rustplus::AppCameraInput* temp = camerainput_;
  camerainput_ = nullptr;
  return temp;
}
inline ::rustplus::AppCameraInput* AppRequest::_internal_mutable_camerainput() {
  _has_bits_[0] |= 0x00080000u;
  if (camerainput_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppCameraInput>(GetArenaForAllocation());
    camerainput_ = p;
  }
  return camerainput_;
}
inline ::rustplus::AppCameraInput* AppRequest::mutable_camerainput() {
  ::rustplus::AppCameraInput* _msg = _internal_mutable_camerainput();
  // @@protoc_insertion_point(field_mutable:rustplus.AppRequest.cameraInput)
  return _msg;
}
inline void AppRequest::set_allocated_camerainput(::rustplus::AppCameraInput* camerainput) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete camerainput_;
  }
  if (camerainput) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppCameraInput>::GetOwningArena(camerainput);
    if (message_arena != submessage_arena) {
      camerainput = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camerainput, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  camerainput_ = camerainput;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppRequest.cameraInput)
}

// -------------------------------------------------------------------

// AppMessage

// optional .rustplus.AppResponse response = 1;
inline bool AppMessage::_internal_has_response() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || response_ != nullptr);
  return m_iValue;
}
inline bool AppMessage::has_response() const {
  return _internal_has_response();
}
inline void AppMessage::clear_response() {
  if (response_ != nullptr) response_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppResponse& AppMessage::_internal_response() const {
  const ::rustplus::AppResponse* p = response_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppResponse&>(
      ::rustplus::_AppResponse_default_instance_);
}
inline const ::rustplus::AppResponse& AppMessage::response() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMessage.response)
  return _internal_response();
}
inline void AppMessage::unsafe_arena_set_allocated_response(
    ::rustplus::AppResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppMessage.response)
}
inline ::rustplus::AppResponse* AppMessage::release_response() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppResponse* temp = response_;
  response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppResponse* AppMessage::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:rustplus.AppMessage.response)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::rustplus::AppResponse* AppMessage::_internal_mutable_response() {
  _has_bits_[0] |= 0x00000001u;
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppResponse>(GetArenaForAllocation());
    response_ = p;
  }
  return response_;
}
inline ::rustplus::AppResponse* AppMessage::mutable_response() {
  ::rustplus::AppResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMessage.response)
  return _msg;
}
inline void AppMessage::set_allocated_response(::rustplus::AppResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppResponse>::GetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMessage.response)
}

// optional .rustplus.AppBroadcast broadcast = 2;
inline bool AppMessage::_internal_has_broadcast() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || broadcast_ != nullptr);
  return m_iValue;
}
inline bool AppMessage::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void AppMessage::clear_broadcast() {
  if (broadcast_ != nullptr) broadcast_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::AppBroadcast& AppMessage::_internal_broadcast() const {
  const ::rustplus::AppBroadcast* p = broadcast_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppBroadcast&>(
      ::rustplus::_AppBroadcast_default_instance_);
}
inline const ::rustplus::AppBroadcast& AppMessage::broadcast() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMessage.broadcast)
  return _internal_broadcast();
}
inline void AppMessage::unsafe_arena_set_allocated_broadcast(
    ::rustplus::AppBroadcast* broadcast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcast_);
  }
  broadcast_ = broadcast;
  if (broadcast) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppMessage.broadcast)
}
inline ::rustplus::AppBroadcast* AppMessage::release_broadcast() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppBroadcast* temp = broadcast_;
  broadcast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppBroadcast* AppMessage::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_release:rustplus.AppMessage.broadcast)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppBroadcast* temp = broadcast_;
  broadcast_ = nullptr;
  return temp;
}
inline ::rustplus::AppBroadcast* AppMessage::_internal_mutable_broadcast() {
  _has_bits_[0] |= 0x00000002u;
  if (broadcast_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppBroadcast>(GetArenaForAllocation());
    broadcast_ = p;
  }
  return broadcast_;
}
inline ::rustplus::AppBroadcast* AppMessage::mutable_broadcast() {
  ::rustplus::AppBroadcast* _msg = _internal_mutable_broadcast();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMessage.broadcast)
  return _msg;
}
inline void AppMessage::set_allocated_broadcast(::rustplus::AppBroadcast* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete broadcast_;
  }
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppBroadcast>::GetOwningArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMessage.broadcast)
}

// -------------------------------------------------------------------

// AppResponse

// required int32 seq = 1;
inline bool AppResponse::_internal_has_seq() const {
  bool m_iValue = (_has_bits_[0] & 0x00004000u) != 0;
  return m_iValue;
}
inline bool AppResponse::has_seq() const {
  return _internal_has_seq();
}
inline void AppResponse::clear_seq() {
  seq_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppResponse::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppResponse::seq() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.seq)
  return _internal_seq();
}
inline void AppResponse::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00004000u;
  seq_ = m_iValue;
}
inline void AppResponse::set_seq(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_seq(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppResponse.seq)
}

// optional .rustplus.AppSuccess success = 4;
inline bool AppResponse::_internal_has_success() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || success_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_success() const {
  return _internal_has_success();
}
inline void AppResponse::clear_success() {
  if (success_ != nullptr) success_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppSuccess& AppResponse::_internal_success() const {
  const ::rustplus::AppSuccess* p = success_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppSuccess&>(
      ::rustplus::_AppSuccess_default_instance_);
}
inline const ::rustplus::AppSuccess& AppResponse::success() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.success)
  return _internal_success();
}
inline void AppResponse::unsafe_arena_set_allocated_success(
    ::rustplus::AppSuccess* success) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(success_);
  }
  success_ = success;
  if (success) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.success)
}
inline ::rustplus::AppSuccess* AppResponse::release_success() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppSuccess* temp = success_;
  success_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppSuccess* AppResponse::unsafe_arena_release_success() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.success)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppSuccess* temp = success_;
  success_ = nullptr;
  return temp;
}
inline ::rustplus::AppSuccess* AppResponse::_internal_mutable_success() {
  _has_bits_[0] |= 0x00000001u;
  if (success_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppSuccess>(GetArenaForAllocation());
    success_ = p;
  }
  return success_;
}
inline ::rustplus::AppSuccess* AppResponse::mutable_success() {
  ::rustplus::AppSuccess* _msg = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.success)
  return _msg;
}
inline void AppResponse::set_allocated_success(::rustplus::AppSuccess* success) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete success_;
  }
  if (success) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppSuccess>::GetOwningArena(success);
    if (message_arena != submessage_arena) {
      success = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, success, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  success_ = success;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.success)
}

// optional .rustplus.AppError error = 5;
inline bool AppResponse::_internal_has_error() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || error_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_error() const {
  return _internal_has_error();
}
inline void AppResponse::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::AppError& AppResponse::_internal_error() const {
  const ::rustplus::AppError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppError&>(
      ::rustplus::_AppError_default_instance_);
}
inline const ::rustplus::AppError& AppResponse::error() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.error)
  return _internal_error();
}
inline void AppResponse::unsafe_arena_set_allocated_error(
    ::rustplus::AppError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.error)
}
inline ::rustplus::AppError* AppResponse::release_error() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppError* AppResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.error)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::rustplus::AppError* AppResponse::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000002u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::rustplus::AppError* AppResponse::mutable_error() {
  ::rustplus::AppError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.error)
  return _msg;
}
inline void AppResponse::set_allocated_error(::rustplus::AppError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppError>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.error)
}

// optional .rustplus.AppInfo info = 6;
inline bool AppResponse::_internal_has_info() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!m_iValue || info_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_info() const {
  return _internal_has_info();
}
inline void AppResponse::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rustplus::AppInfo& AppResponse::_internal_info() const {
  const ::rustplus::AppInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppInfo&>(
      ::rustplus::_AppInfo_default_instance_);
}
inline const ::rustplus::AppInfo& AppResponse::info() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.info)
  return _internal_info();
}
inline void AppResponse::unsafe_arena_set_allocated_info(
    ::rustplus::AppInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.info)
}
inline ::rustplus::AppInfo* AppResponse::release_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::AppInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppInfo* AppResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.info)
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::AppInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::rustplus::AppInfo* AppResponse::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000004u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::rustplus::AppInfo* AppResponse::mutable_info() {
  ::rustplus::AppInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.info)
  return _msg;
}
inline void AppResponse::set_allocated_info(::rustplus::AppInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.info)
}

// optional .rustplus.AppTime time = 7;
inline bool AppResponse::_internal_has_time() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!m_iValue || time_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_time() const {
  return _internal_has_time();
}
inline void AppResponse::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::rustplus::AppTime& AppResponse::_internal_time() const {
  const ::rustplus::AppTime* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppTime&>(
      ::rustplus::_AppTime_default_instance_);
}
inline const ::rustplus::AppTime& AppResponse::time() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.time)
  return _internal_time();
}
inline void AppResponse::unsafe_arena_set_allocated_time(
    ::rustplus::AppTime* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.time)
}
inline ::rustplus::AppTime* AppResponse::release_time() {
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::AppTime* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppTime* AppResponse::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.time)
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::AppTime* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::rustplus::AppTime* AppResponse::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000008u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppTime>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::rustplus::AppTime* AppResponse::mutable_time() {
  ::rustplus::AppTime* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.time)
  return _msg;
}
inline void AppResponse::set_allocated_time(::rustplus::AppTime* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppTime>::GetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.time)
}

// optional .rustplus.AppMap map = 8;
inline bool AppResponse::_internal_has_map() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!m_iValue || map_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_map() const {
  return _internal_has_map();
}
inline void AppResponse::clear_map() {
  if (map_ != nullptr) map_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::rustplus::AppMap& AppResponse::_internal_map() const {
  const ::rustplus::AppMap* p = map_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppMap&>(
      ::rustplus::_AppMap_default_instance_);
}
inline const ::rustplus::AppMap& AppResponse::map() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.map)
  return _internal_map();
}
inline void AppResponse::unsafe_arena_set_allocated_map(
    ::rustplus::AppMap* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map_);
  }
  map_ = map;
  if (map) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.map)
}
inline ::rustplus::AppMap* AppResponse::release_map() {
  _has_bits_[0] &= ~0x00000010u;
  ::rustplus::AppMap* temp = map_;
  map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppMap* AppResponse::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.map)
  _has_bits_[0] &= ~0x00000010u;
  ::rustplus::AppMap* temp = map_;
  map_ = nullptr;
  return temp;
}
inline ::rustplus::AppMap* AppResponse::_internal_mutable_map() {
  _has_bits_[0] |= 0x00000010u;
  if (map_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppMap>(GetArenaForAllocation());
    map_ = p;
  }
  return map_;
}
inline ::rustplus::AppMap* AppResponse::mutable_map() {
  ::rustplus::AppMap* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.map)
  return _msg;
}
inline void AppResponse::set_allocated_map(::rustplus::AppMap* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete map_;
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppMap>::GetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  map_ = map;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.map)
}

// optional .rustplus.AppTeamInfo teamInfo = 9;
inline bool AppResponse::_internal_has_teaminfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!m_iValue || teaminfo_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_teaminfo() const {
  return _internal_has_teaminfo();
}
inline void AppResponse::clear_teaminfo() {
  if (teaminfo_ != nullptr) teaminfo_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::rustplus::AppTeamInfo& AppResponse::_internal_teaminfo() const {
  const ::rustplus::AppTeamInfo* p = teaminfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppTeamInfo&>(
      ::rustplus::_AppTeamInfo_default_instance_);
}
inline const ::rustplus::AppTeamInfo& AppResponse::teaminfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.teamInfo)
  return _internal_teaminfo();
}
inline void AppResponse::unsafe_arena_set_allocated_teaminfo(
    ::rustplus::AppTeamInfo* teaminfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(teaminfo_);
  }
  teaminfo_ = teaminfo;
  if (teaminfo) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.teamInfo)
}
inline ::rustplus::AppTeamInfo* AppResponse::release_teaminfo() {
  _has_bits_[0] &= ~0x00000020u;
  ::rustplus::AppTeamInfo* temp = teaminfo_;
  teaminfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppTeamInfo* AppResponse::unsafe_arena_release_teaminfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.teamInfo)
  _has_bits_[0] &= ~0x00000020u;
  ::rustplus::AppTeamInfo* temp = teaminfo_;
  teaminfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppTeamInfo* AppResponse::_internal_mutable_teaminfo() {
  _has_bits_[0] |= 0x00000020u;
  if (teaminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppTeamInfo>(GetArenaForAllocation());
    teaminfo_ = p;
  }
  return teaminfo_;
}
inline ::rustplus::AppTeamInfo* AppResponse::mutable_teaminfo() {
  ::rustplus::AppTeamInfo* _msg = _internal_mutable_teaminfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.teamInfo)
  return _msg;
}
inline void AppResponse::set_allocated_teaminfo(::rustplus::AppTeamInfo* teaminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete teaminfo_;
  }
  if (teaminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppTeamInfo>::GetOwningArena(teaminfo);
    if (message_arena != submessage_arena) {
      teaminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teaminfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  teaminfo_ = teaminfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.teamInfo)
}

// optional .rustplus.AppTeamChat teamChat = 10;
inline bool AppResponse::_internal_has_teamchat() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!m_iValue || teamchat_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_teamchat() const {
  return _internal_has_teamchat();
}
inline void AppResponse::clear_teamchat() {
  if (teamchat_ != nullptr) teamchat_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::rustplus::AppTeamChat& AppResponse::_internal_teamchat() const {
  const ::rustplus::AppTeamChat* p = teamchat_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppTeamChat&>(
      ::rustplus::_AppTeamChat_default_instance_);
}
inline const ::rustplus::AppTeamChat& AppResponse::teamchat() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.teamChat)
  return _internal_teamchat();
}
inline void AppResponse::unsafe_arena_set_allocated_teamchat(
    ::rustplus::AppTeamChat* teamchat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(teamchat_);
  }
  teamchat_ = teamchat;
  if (teamchat) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.teamChat)
}
inline ::rustplus::AppTeamChat* AppResponse::release_teamchat() {
  _has_bits_[0] &= ~0x00000040u;
  ::rustplus::AppTeamChat* temp = teamchat_;
  teamchat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppTeamChat* AppResponse::unsafe_arena_release_teamchat() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.teamChat)
  _has_bits_[0] &= ~0x00000040u;
  ::rustplus::AppTeamChat* temp = teamchat_;
  teamchat_ = nullptr;
  return temp;
}
inline ::rustplus::AppTeamChat* AppResponse::_internal_mutable_teamchat() {
  _has_bits_[0] |= 0x00000040u;
  if (teamchat_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppTeamChat>(GetArenaForAllocation());
    teamchat_ = p;
  }
  return teamchat_;
}
inline ::rustplus::AppTeamChat* AppResponse::mutable_teamchat() {
  ::rustplus::AppTeamChat* _msg = _internal_mutable_teamchat();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.teamChat)
  return _msg;
}
inline void AppResponse::set_allocated_teamchat(::rustplus::AppTeamChat* teamchat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete teamchat_;
  }
  if (teamchat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppTeamChat>::GetOwningArena(teamchat);
    if (message_arena != submessage_arena) {
      teamchat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teamchat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  teamchat_ = teamchat;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.teamChat)
}

// optional .rustplus.AppEntityInfo entityInfo = 11;
inline bool AppResponse::_internal_has_entityinfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!m_iValue || entityinfo_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_entityinfo() const {
  return _internal_has_entityinfo();
}
inline void AppResponse::clear_entityinfo() {
  if (entityinfo_ != nullptr) entityinfo_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::rustplus::AppEntityInfo& AppResponse::_internal_entityinfo() const {
  const ::rustplus::AppEntityInfo* p = entityinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEntityInfo&>(
      ::rustplus::_AppEntityInfo_default_instance_);
}
inline const ::rustplus::AppEntityInfo& AppResponse::entityinfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.entityInfo)
  return _internal_entityinfo();
}
inline void AppResponse::unsafe_arena_set_allocated_entityinfo(
    ::rustplus::AppEntityInfo* entityinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entityinfo_);
  }
  entityinfo_ = entityinfo;
  if (entityinfo) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.entityInfo)
}
inline ::rustplus::AppEntityInfo* AppResponse::release_entityinfo() {
  _has_bits_[0] &= ~0x00000080u;
  ::rustplus::AppEntityInfo* temp = entityinfo_;
  entityinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEntityInfo* AppResponse::unsafe_arena_release_entityinfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.entityInfo)
  _has_bits_[0] &= ~0x00000080u;
  ::rustplus::AppEntityInfo* temp = entityinfo_;
  entityinfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppEntityInfo* AppResponse::_internal_mutable_entityinfo() {
  _has_bits_[0] |= 0x00000080u;
  if (entityinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEntityInfo>(GetArenaForAllocation());
    entityinfo_ = p;
  }
  return entityinfo_;
}
inline ::rustplus::AppEntityInfo* AppResponse::mutable_entityinfo() {
  ::rustplus::AppEntityInfo* _msg = _internal_mutable_entityinfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.entityInfo)
  return _msg;
}
inline void AppResponse::set_allocated_entityinfo(::rustplus::AppEntityInfo* entityinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entityinfo_;
  }
  if (entityinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEntityInfo>::GetOwningArena(entityinfo);
    if (message_arena != submessage_arena) {
      entityinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entityinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  entityinfo_ = entityinfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.entityInfo)
}

// optional .rustplus.AppFlag flag = 12;
inline bool AppResponse::_internal_has_flag() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!m_iValue || flag_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_flag() const {
  return _internal_has_flag();
}
inline void AppResponse::clear_flag() {
  if (flag_ != nullptr) flag_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::rustplus::AppFlag& AppResponse::_internal_flag() const {
  const ::rustplus::AppFlag* p = flag_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppFlag&>(
      ::rustplus::_AppFlag_default_instance_);
}
inline const ::rustplus::AppFlag& AppResponse::flag() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.flag)
  return _internal_flag();
}
inline void AppResponse::unsafe_arena_set_allocated_flag(
    ::rustplus::AppFlag* flag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flag_);
  }
  flag_ = flag;
  if (flag) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.flag)
}
inline ::rustplus::AppFlag* AppResponse::release_flag() {
  _has_bits_[0] &= ~0x00000100u;
  ::rustplus::AppFlag* temp = flag_;
  flag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppFlag* AppResponse::unsafe_arena_release_flag() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.flag)
  _has_bits_[0] &= ~0x00000100u;
  ::rustplus::AppFlag* temp = flag_;
  flag_ = nullptr;
  return temp;
}
inline ::rustplus::AppFlag* AppResponse::_internal_mutable_flag() {
  _has_bits_[0] |= 0x00000100u;
  if (flag_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppFlag>(GetArenaForAllocation());
    flag_ = p;
  }
  return flag_;
}
inline ::rustplus::AppFlag* AppResponse::mutable_flag() {
  ::rustplus::AppFlag* _msg = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.flag)
  return _msg;
}
inline void AppResponse::set_allocated_flag(::rustplus::AppFlag* flag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete flag_;
  }
  if (flag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppFlag>::GetOwningArena(flag);
    if (message_arena != submessage_arena) {
      flag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flag, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  flag_ = flag;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.flag)
}

// optional .rustplus.AppMapMarkers mapMarkers = 13;
inline bool AppResponse::_internal_has_mapmarkers() const {
  bool m_iValue = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!m_iValue || mapmarkers_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_mapmarkers() const {
  return _internal_has_mapmarkers();
}
inline void AppResponse::clear_mapmarkers() {
  if (mapmarkers_ != nullptr) mapmarkers_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::rustplus::AppMapMarkers& AppResponse::_internal_mapmarkers() const {
  const ::rustplus::AppMapMarkers* p = mapmarkers_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppMapMarkers&>(
      ::rustplus::_AppMapMarkers_default_instance_);
}
inline const ::rustplus::AppMapMarkers& AppResponse::mapmarkers() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.mapMarkers)
  return _internal_mapmarkers();
}
inline void AppResponse::unsafe_arena_set_allocated_mapmarkers(
    ::rustplus::AppMapMarkers* mapmarkers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapmarkers_);
  }
  mapmarkers_ = mapmarkers;
  if (mapmarkers) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.mapMarkers)
}
inline ::rustplus::AppMapMarkers* AppResponse::release_mapmarkers() {
  _has_bits_[0] &= ~0x00000200u;
  ::rustplus::AppMapMarkers* temp = mapmarkers_;
  mapmarkers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppMapMarkers* AppResponse::unsafe_arena_release_mapmarkers() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.mapMarkers)
  _has_bits_[0] &= ~0x00000200u;
  ::rustplus::AppMapMarkers* temp = mapmarkers_;
  mapmarkers_ = nullptr;
  return temp;
}
inline ::rustplus::AppMapMarkers* AppResponse::_internal_mutable_mapmarkers() {
  _has_bits_[0] |= 0x00000200u;
  if (mapmarkers_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppMapMarkers>(GetArenaForAllocation());
    mapmarkers_ = p;
  }
  return mapmarkers_;
}
inline ::rustplus::AppMapMarkers* AppResponse::mutable_mapmarkers() {
  ::rustplus::AppMapMarkers* _msg = _internal_mutable_mapmarkers();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.mapMarkers)
  return _msg;
}
inline void AppResponse::set_allocated_mapmarkers(::rustplus::AppMapMarkers* mapmarkers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mapmarkers_;
  }
  if (mapmarkers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppMapMarkers>::GetOwningArena(mapmarkers);
    if (message_arena != submessage_arena) {
      mapmarkers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapmarkers, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  mapmarkers_ = mapmarkers;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.mapMarkers)
}

// optional .rustplus.AppClanInfo clanInfo = 15;
inline bool AppResponse::_internal_has_claninfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!m_iValue || claninfo_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_claninfo() const {
  return _internal_has_claninfo();
}
inline void AppResponse::clear_claninfo() {
  if (claninfo_ != nullptr) claninfo_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::rustplus::AppClanInfo& AppResponse::_internal_claninfo() const {
  const ::rustplus::AppClanInfo* p = claninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppClanInfo&>(
      ::rustplus::_AppClanInfo_default_instance_);
}
inline const ::rustplus::AppClanInfo& AppResponse::claninfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.clanInfo)
  return _internal_claninfo();
}
inline void AppResponse::unsafe_arena_set_allocated_claninfo(
    ::rustplus::AppClanInfo* claninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claninfo_);
  }
  claninfo_ = claninfo;
  if (claninfo) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.clanInfo)
}
inline ::rustplus::AppClanInfo* AppResponse::release_claninfo() {
  _has_bits_[0] &= ~0x00000400u;
  ::rustplus::AppClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppClanInfo* AppResponse::unsafe_arena_release_claninfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.clanInfo)
  _has_bits_[0] &= ~0x00000400u;
  ::rustplus::AppClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppClanInfo* AppResponse::_internal_mutable_claninfo() {
  _has_bits_[0] |= 0x00000400u;
  if (claninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppClanInfo>(GetArenaForAllocation());
    claninfo_ = p;
  }
  return claninfo_;
}
inline ::rustplus::AppClanInfo* AppResponse::mutable_claninfo() {
  ::rustplus::AppClanInfo* _msg = _internal_mutable_claninfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.clanInfo)
  return _msg;
}
inline void AppResponse::set_allocated_claninfo(::rustplus::AppClanInfo* claninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete claninfo_;
  }
  if (claninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppClanInfo>::GetOwningArena(claninfo);
    if (message_arena != submessage_arena) {
      claninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  claninfo_ = claninfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.clanInfo)
}

// optional .rustplus.AppClanChat clanChat = 16;
inline bool AppResponse::_internal_has_clanchat() const {
  bool m_iValue = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!m_iValue || clanchat_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_clanchat() const {
  return _internal_has_clanchat();
}
inline void AppResponse::clear_clanchat() {
  if (clanchat_ != nullptr) clanchat_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::rustplus::AppClanChat& AppResponse::_internal_clanchat() const {
  const ::rustplus::AppClanChat* p = clanchat_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppClanChat&>(
      ::rustplus::_AppClanChat_default_instance_);
}
inline const ::rustplus::AppClanChat& AppResponse::clanchat() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.clanChat)
  return _internal_clanchat();
}
inline void AppResponse::unsafe_arena_set_allocated_clanchat(
    ::rustplus::AppClanChat* clanchat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clanchat_);
  }
  clanchat_ = clanchat;
  if (clanchat) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.clanChat)
}
inline ::rustplus::AppClanChat* AppResponse::release_clanchat() {
  _has_bits_[0] &= ~0x00000800u;
  ::rustplus::AppClanChat* temp = clanchat_;
  clanchat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppClanChat* AppResponse::unsafe_arena_release_clanchat() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.clanChat)
  _has_bits_[0] &= ~0x00000800u;
  ::rustplus::AppClanChat* temp = clanchat_;
  clanchat_ = nullptr;
  return temp;
}
inline ::rustplus::AppClanChat* AppResponse::_internal_mutable_clanchat() {
  _has_bits_[0] |= 0x00000800u;
  if (clanchat_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppClanChat>(GetArenaForAllocation());
    clanchat_ = p;
  }
  return clanchat_;
}
inline ::rustplus::AppClanChat* AppResponse::mutable_clanchat() {
  ::rustplus::AppClanChat* _msg = _internal_mutable_clanchat();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.clanChat)
  return _msg;
}
inline void AppResponse::set_allocated_clanchat(::rustplus::AppClanChat* clanchat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clanchat_;
  }
  if (clanchat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppClanChat>::GetOwningArena(clanchat);
    if (message_arena != submessage_arena) {
      clanchat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clanchat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  clanchat_ = clanchat;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.clanChat)
}

// optional .rustplus.AppNexusAuth nexusAuth = 17;
inline bool AppResponse::_internal_has_nexusauth() const {
  bool m_iValue = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || nexusauth_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_nexusauth() const {
  return _internal_has_nexusauth();
}
inline void AppResponse::clear_nexusauth() {
  if (nexusauth_ != nullptr) nexusauth_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::rustplus::AppNexusAuth& AppResponse::_internal_nexusauth() const {
  const ::rustplus::AppNexusAuth* p = nexusauth_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppNexusAuth&>(
      ::rustplus::_AppNexusAuth_default_instance_);
}
inline const ::rustplus::AppNexusAuth& AppResponse::nexusauth() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.nexusAuth)
  return _internal_nexusauth();
}
inline void AppResponse::unsafe_arena_set_allocated_nexusauth(
    ::rustplus::AppNexusAuth* nexusauth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexusauth_);
  }
  nexusauth_ = nexusauth;
  if (nexusauth) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.nexusAuth)
}
inline ::rustplus::AppNexusAuth* AppResponse::release_nexusauth() {
  _has_bits_[0] &= ~0x00001000u;
  ::rustplus::AppNexusAuth* temp = nexusauth_;
  nexusauth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppNexusAuth* AppResponse::unsafe_arena_release_nexusauth() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.nexusAuth)
  _has_bits_[0] &= ~0x00001000u;
  ::rustplus::AppNexusAuth* temp = nexusauth_;
  nexusauth_ = nullptr;
  return temp;
}
inline ::rustplus::AppNexusAuth* AppResponse::_internal_mutable_nexusauth() {
  _has_bits_[0] |= 0x00001000u;
  if (nexusauth_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppNexusAuth>(GetArenaForAllocation());
    nexusauth_ = p;
  }
  return nexusauth_;
}
inline ::rustplus::AppNexusAuth* AppResponse::mutable_nexusauth() {
  ::rustplus::AppNexusAuth* _msg = _internal_mutable_nexusauth();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.nexusAuth)
  return _msg;
}
inline void AppResponse::set_allocated_nexusauth(::rustplus::AppNexusAuth* nexusauth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nexusauth_;
  }
  if (nexusauth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppNexusAuth>::GetOwningArena(nexusauth);
    if (message_arena != submessage_arena) {
      nexusauth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexusauth, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  nexusauth_ = nexusauth;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.nexusAuth)
}

// optional .rustplus.AppCameraInfo cameraSubscribeInfo = 20;
inline bool AppResponse::_internal_has_camerasubscribeinfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!m_iValue || camerasubscribeinfo_ != nullptr);
  return m_iValue;
}
inline bool AppResponse::has_camerasubscribeinfo() const {
  return _internal_has_camerasubscribeinfo();
}
inline void AppResponse::clear_camerasubscribeinfo() {
  if (camerasubscribeinfo_ != nullptr) camerasubscribeinfo_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::rustplus::AppCameraInfo& AppResponse::_internal_camerasubscribeinfo() const {
  const ::rustplus::AppCameraInfo* p = camerasubscribeinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppCameraInfo&>(
      ::rustplus::_AppCameraInfo_default_instance_);
}
inline const ::rustplus::AppCameraInfo& AppResponse::camerasubscribeinfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppResponse.cameraSubscribeInfo)
  return _internal_camerasubscribeinfo();
}
inline void AppResponse::unsafe_arena_set_allocated_camerasubscribeinfo(
    ::rustplus::AppCameraInfo* camerasubscribeinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camerasubscribeinfo_);
  }
  camerasubscribeinfo_ = camerasubscribeinfo;
  if (camerasubscribeinfo) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppResponse.cameraSubscribeInfo)
}
inline ::rustplus::AppCameraInfo* AppResponse::release_camerasubscribeinfo() {
  _has_bits_[0] &= ~0x00002000u;
  ::rustplus::AppCameraInfo* temp = camerasubscribeinfo_;
  camerasubscribeinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppCameraInfo* AppResponse::unsafe_arena_release_camerasubscribeinfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppResponse.cameraSubscribeInfo)
  _has_bits_[0] &= ~0x00002000u;
  ::rustplus::AppCameraInfo* temp = camerasubscribeinfo_;
  camerasubscribeinfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppCameraInfo* AppResponse::_internal_mutable_camerasubscribeinfo() {
  _has_bits_[0] |= 0x00002000u;
  if (camerasubscribeinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppCameraInfo>(GetArenaForAllocation());
    camerasubscribeinfo_ = p;
  }
  return camerasubscribeinfo_;
}
inline ::rustplus::AppCameraInfo* AppResponse::mutable_camerasubscribeinfo() {
  ::rustplus::AppCameraInfo* _msg = _internal_mutable_camerasubscribeinfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppResponse.cameraSubscribeInfo)
  return _msg;
}
inline void AppResponse::set_allocated_camerasubscribeinfo(::rustplus::AppCameraInfo* camerasubscribeinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete camerasubscribeinfo_;
  }
  if (camerasubscribeinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppCameraInfo>::GetOwningArena(camerasubscribeinfo);
    if (message_arena != submessage_arena) {
      camerasubscribeinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camerasubscribeinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  camerasubscribeinfo_ = camerasubscribeinfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppResponse.cameraSubscribeInfo)
}

// -------------------------------------------------------------------

// AppBroadcast

// optional .rustplus.AppTeamChanged teamChanged = 4;
inline bool AppBroadcast::_internal_has_teamchanged() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || teamchanged_ != nullptr);
  return m_iValue;
}
inline bool AppBroadcast::has_teamchanged() const {
  return _internal_has_teamchanged();
}
inline void AppBroadcast::clear_teamchanged() {
  if (teamchanged_ != nullptr) teamchanged_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppTeamChanged& AppBroadcast::_internal_teamchanged() const {
  const ::rustplus::AppTeamChanged* p = teamchanged_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppTeamChanged&>(
      ::rustplus::_AppTeamChanged_default_instance_);
}
inline const ::rustplus::AppTeamChanged& AppBroadcast::teamchanged() const {
  // @@protoc_insertion_point(field_get:rustplus.AppBroadcast.teamChanged)
  return _internal_teamchanged();
}
inline void AppBroadcast::unsafe_arena_set_allocated_teamchanged(
    ::rustplus::AppTeamChanged* teamchanged) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(teamchanged_);
  }
  teamchanged_ = teamchanged;
  if (teamchanged) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppBroadcast.teamChanged)
}
inline ::rustplus::AppTeamChanged* AppBroadcast::release_teamchanged() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppTeamChanged* temp = teamchanged_;
  teamchanged_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppTeamChanged* AppBroadcast::unsafe_arena_release_teamchanged() {
  // @@protoc_insertion_point(field_release:rustplus.AppBroadcast.teamChanged)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppTeamChanged* temp = teamchanged_;
  teamchanged_ = nullptr;
  return temp;
}
inline ::rustplus::AppTeamChanged* AppBroadcast::_internal_mutable_teamchanged() {
  _has_bits_[0] |= 0x00000001u;
  if (teamchanged_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppTeamChanged>(GetArenaForAllocation());
    teamchanged_ = p;
  }
  return teamchanged_;
}
inline ::rustplus::AppTeamChanged* AppBroadcast::mutable_teamchanged() {
  ::rustplus::AppTeamChanged* _msg = _internal_mutable_teamchanged();
  // @@protoc_insertion_point(field_mutable:rustplus.AppBroadcast.teamChanged)
  return _msg;
}
inline void AppBroadcast::set_allocated_teamchanged(::rustplus::AppTeamChanged* teamchanged) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete teamchanged_;
  }
  if (teamchanged) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppTeamChanged>::GetOwningArena(teamchanged);
    if (message_arena != submessage_arena) {
      teamchanged = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teamchanged, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  teamchanged_ = teamchanged;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppBroadcast.teamChanged)
}

// optional .rustplus.AppNewTeamMessage newTeamMessage = 5;
inline bool AppBroadcast::_internal_has_newteammessage() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || newteammessage_ != nullptr);
  return m_iValue;
}
inline bool AppBroadcast::has_newteammessage() const {
  return _internal_has_newteammessage();
}
inline void AppBroadcast::clear_newteammessage() {
  if (newteammessage_ != nullptr) newteammessage_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::AppNewTeamMessage& AppBroadcast::_internal_newteammessage() const {
  const ::rustplus::AppNewTeamMessage* p = newteammessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppNewTeamMessage&>(
      ::rustplus::_AppNewTeamMessage_default_instance_);
}
inline const ::rustplus::AppNewTeamMessage& AppBroadcast::newteammessage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppBroadcast.newTeamMessage)
  return _internal_newteammessage();
}
inline void AppBroadcast::unsafe_arena_set_allocated_newteammessage(
    ::rustplus::AppNewTeamMessage* newteammessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newteammessage_);
  }
  newteammessage_ = newteammessage;
  if (newteammessage) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppBroadcast.newTeamMessage)
}
inline ::rustplus::AppNewTeamMessage* AppBroadcast::release_newteammessage() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppNewTeamMessage* temp = newteammessage_;
  newteammessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppNewTeamMessage* AppBroadcast::unsafe_arena_release_newteammessage() {
  // @@protoc_insertion_point(field_release:rustplus.AppBroadcast.newTeamMessage)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::AppNewTeamMessage* temp = newteammessage_;
  newteammessage_ = nullptr;
  return temp;
}
inline ::rustplus::AppNewTeamMessage* AppBroadcast::_internal_mutable_newteammessage() {
  _has_bits_[0] |= 0x00000002u;
  if (newteammessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppNewTeamMessage>(GetArenaForAllocation());
    newteammessage_ = p;
  }
  return newteammessage_;
}
inline ::rustplus::AppNewTeamMessage* AppBroadcast::mutable_newteammessage() {
  ::rustplus::AppNewTeamMessage* _msg = _internal_mutable_newteammessage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppBroadcast.newTeamMessage)
  return _msg;
}
inline void AppBroadcast::set_allocated_newteammessage(::rustplus::AppNewTeamMessage* newteammessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete newteammessage_;
  }
  if (newteammessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppNewTeamMessage>::GetOwningArena(newteammessage);
    if (message_arena != submessage_arena) {
      newteammessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newteammessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  newteammessage_ = newteammessage;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppBroadcast.newTeamMessage)
}

// optional .rustplus.AppEntityChanged entityChanged = 6;
inline bool AppBroadcast::_internal_has_entitychanged() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!m_iValue || entitychanged_ != nullptr);
  return m_iValue;
}
inline bool AppBroadcast::has_entitychanged() const {
  return _internal_has_entitychanged();
}
inline void AppBroadcast::clear_entitychanged() {
  if (entitychanged_ != nullptr) entitychanged_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rustplus::AppEntityChanged& AppBroadcast::_internal_entitychanged() const {
  const ::rustplus::AppEntityChanged* p = entitychanged_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEntityChanged&>(
      ::rustplus::_AppEntityChanged_default_instance_);
}
inline const ::rustplus::AppEntityChanged& AppBroadcast::entitychanged() const {
  // @@protoc_insertion_point(field_get:rustplus.AppBroadcast.entityChanged)
  return _internal_entitychanged();
}
inline void AppBroadcast::unsafe_arena_set_allocated_entitychanged(
    ::rustplus::AppEntityChanged* entitychanged) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entitychanged_);
  }
  entitychanged_ = entitychanged;
  if (entitychanged) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppBroadcast.entityChanged)
}
inline ::rustplus::AppEntityChanged* AppBroadcast::release_entitychanged() {
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::AppEntityChanged* temp = entitychanged_;
  entitychanged_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEntityChanged* AppBroadcast::unsafe_arena_release_entitychanged() {
  // @@protoc_insertion_point(field_release:rustplus.AppBroadcast.entityChanged)
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::AppEntityChanged* temp = entitychanged_;
  entitychanged_ = nullptr;
  return temp;
}
inline ::rustplus::AppEntityChanged* AppBroadcast::_internal_mutable_entitychanged() {
  _has_bits_[0] |= 0x00000004u;
  if (entitychanged_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEntityChanged>(GetArenaForAllocation());
    entitychanged_ = p;
  }
  return entitychanged_;
}
inline ::rustplus::AppEntityChanged* AppBroadcast::mutable_entitychanged() {
  ::rustplus::AppEntityChanged* _msg = _internal_mutable_entitychanged();
  // @@protoc_insertion_point(field_mutable:rustplus.AppBroadcast.entityChanged)
  return _msg;
}
inline void AppBroadcast::set_allocated_entitychanged(::rustplus::AppEntityChanged* entitychanged) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entitychanged_;
  }
  if (entitychanged) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEntityChanged>::GetOwningArena(entitychanged);
    if (message_arena != submessage_arena) {
      entitychanged = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entitychanged, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  entitychanged_ = entitychanged;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppBroadcast.entityChanged)
}

// optional .rustplus.AppClanChanged clanChanged = 7;
inline bool AppBroadcast::_internal_has_clanchanged() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!m_iValue || clanchanged_ != nullptr);
  return m_iValue;
}
inline bool AppBroadcast::has_clanchanged() const {
  return _internal_has_clanchanged();
}
inline void AppBroadcast::clear_clanchanged() {
  if (clanchanged_ != nullptr) clanchanged_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::rustplus::AppClanChanged& AppBroadcast::_internal_clanchanged() const {
  const ::rustplus::AppClanChanged* p = clanchanged_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppClanChanged&>(
      ::rustplus::_AppClanChanged_default_instance_);
}
inline const ::rustplus::AppClanChanged& AppBroadcast::clanchanged() const {
  // @@protoc_insertion_point(field_get:rustplus.AppBroadcast.clanChanged)
  return _internal_clanchanged();
}
inline void AppBroadcast::unsafe_arena_set_allocated_clanchanged(
    ::rustplus::AppClanChanged* clanchanged) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clanchanged_);
  }
  clanchanged_ = clanchanged;
  if (clanchanged) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppBroadcast.clanChanged)
}
inline ::rustplus::AppClanChanged* AppBroadcast::release_clanchanged() {
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::AppClanChanged* temp = clanchanged_;
  clanchanged_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppClanChanged* AppBroadcast::unsafe_arena_release_clanchanged() {
  // @@protoc_insertion_point(field_release:rustplus.AppBroadcast.clanChanged)
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::AppClanChanged* temp = clanchanged_;
  clanchanged_ = nullptr;
  return temp;
}
inline ::rustplus::AppClanChanged* AppBroadcast::_internal_mutable_clanchanged() {
  _has_bits_[0] |= 0x00000008u;
  if (clanchanged_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppClanChanged>(GetArenaForAllocation());
    clanchanged_ = p;
  }
  return clanchanged_;
}
inline ::rustplus::AppClanChanged* AppBroadcast::mutable_clanchanged() {
  ::rustplus::AppClanChanged* _msg = _internal_mutable_clanchanged();
  // @@protoc_insertion_point(field_mutable:rustplus.AppBroadcast.clanChanged)
  return _msg;
}
inline void AppBroadcast::set_allocated_clanchanged(::rustplus::AppClanChanged* clanchanged) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clanchanged_;
  }
  if (clanchanged) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppClanChanged>::GetOwningArena(clanchanged);
    if (message_arena != submessage_arena) {
      clanchanged = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clanchanged, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  clanchanged_ = clanchanged;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppBroadcast.clanChanged)
}

// optional .rustplus.AppNewClanMessage clanMessage = 8;
inline bool AppBroadcast::_internal_has_clanmessage() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!m_iValue || clanmessage_ != nullptr);
  return m_iValue;
}
inline bool AppBroadcast::has_clanmessage() const {
  return _internal_has_clanmessage();
}
inline void AppBroadcast::clear_clanmessage() {
  if (clanmessage_ != nullptr) clanmessage_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::rustplus::AppNewClanMessage& AppBroadcast::_internal_clanmessage() const {
  const ::rustplus::AppNewClanMessage* p = clanmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppNewClanMessage&>(
      ::rustplus::_AppNewClanMessage_default_instance_);
}
inline const ::rustplus::AppNewClanMessage& AppBroadcast::clanmessage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppBroadcast.clanMessage)
  return _internal_clanmessage();
}
inline void AppBroadcast::unsafe_arena_set_allocated_clanmessage(
    ::rustplus::AppNewClanMessage* clanmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clanmessage_);
  }
  clanmessage_ = clanmessage;
  if (clanmessage) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppBroadcast.clanMessage)
}
inline ::rustplus::AppNewClanMessage* AppBroadcast::release_clanmessage() {
  _has_bits_[0] &= ~0x00000010u;
  ::rustplus::AppNewClanMessage* temp = clanmessage_;
  clanmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppNewClanMessage* AppBroadcast::unsafe_arena_release_clanmessage() {
  // @@protoc_insertion_point(field_release:rustplus.AppBroadcast.clanMessage)
  _has_bits_[0] &= ~0x00000010u;
  ::rustplus::AppNewClanMessage* temp = clanmessage_;
  clanmessage_ = nullptr;
  return temp;
}
inline ::rustplus::AppNewClanMessage* AppBroadcast::_internal_mutable_clanmessage() {
  _has_bits_[0] |= 0x00000010u;
  if (clanmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppNewClanMessage>(GetArenaForAllocation());
    clanmessage_ = p;
  }
  return clanmessage_;
}
inline ::rustplus::AppNewClanMessage* AppBroadcast::mutable_clanmessage() {
  ::rustplus::AppNewClanMessage* _msg = _internal_mutable_clanmessage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppBroadcast.clanMessage)
  return _msg;
}
inline void AppBroadcast::set_allocated_clanmessage(::rustplus::AppNewClanMessage* clanmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clanmessage_;
  }
  if (clanmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppNewClanMessage>::GetOwningArena(clanmessage);
    if (message_arena != submessage_arena) {
      clanmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clanmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  clanmessage_ = clanmessage;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppBroadcast.clanMessage)
}

// optional .rustplus.AppCameraRays cameraRays = 10;
inline bool AppBroadcast::_internal_has_camerarays() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!m_iValue || camerarays_ != nullptr);
  return m_iValue;
}
inline bool AppBroadcast::has_camerarays() const {
  return _internal_has_camerarays();
}
inline void AppBroadcast::clear_camerarays() {
  if (camerarays_ != nullptr) camerarays_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::rustplus::AppCameraRays& AppBroadcast::_internal_camerarays() const {
  const ::rustplus::AppCameraRays* p = camerarays_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppCameraRays&>(
      ::rustplus::_AppCameraRays_default_instance_);
}
inline const ::rustplus::AppCameraRays& AppBroadcast::camerarays() const {
  // @@protoc_insertion_point(field_get:rustplus.AppBroadcast.cameraRays)
  return _internal_camerarays();
}
inline void AppBroadcast::unsafe_arena_set_allocated_camerarays(
    ::rustplus::AppCameraRays* camerarays) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camerarays_);
  }
  camerarays_ = camerarays;
  if (camerarays) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppBroadcast.cameraRays)
}
inline ::rustplus::AppCameraRays* AppBroadcast::release_camerarays() {
  _has_bits_[0] &= ~0x00000020u;
  ::rustplus::AppCameraRays* temp = camerarays_;
  camerarays_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppCameraRays* AppBroadcast::unsafe_arena_release_camerarays() {
  // @@protoc_insertion_point(field_release:rustplus.AppBroadcast.cameraRays)
  _has_bits_[0] &= ~0x00000020u;
  ::rustplus::AppCameraRays* temp = camerarays_;
  camerarays_ = nullptr;
  return temp;
}
inline ::rustplus::AppCameraRays* AppBroadcast::_internal_mutable_camerarays() {
  _has_bits_[0] |= 0x00000020u;
  if (camerarays_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppCameraRays>(GetArenaForAllocation());
    camerarays_ = p;
  }
  return camerarays_;
}
inline ::rustplus::AppCameraRays* AppBroadcast::mutable_camerarays() {
  ::rustplus::AppCameraRays* _msg = _internal_mutable_camerarays();
  // @@protoc_insertion_point(field_mutable:rustplus.AppBroadcast.cameraRays)
  return _msg;
}
inline void AppBroadcast::set_allocated_camerarays(::rustplus::AppCameraRays* camerarays) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete camerarays_;
  }
  if (camerarays) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppCameraRays>::GetOwningArena(camerarays);
    if (message_arena != submessage_arena) {
      camerarays = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camerarays, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  camerarays_ = camerarays;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppBroadcast.cameraRays)
}

// -------------------------------------------------------------------

// AppEmpty

// -------------------------------------------------------------------

// AppSendMessage

// required string message = 1;
inline bool AppSendMessage::_internal_has_message() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppSendMessage::has_message() const {
  return _internal_has_message();
}
inline void AppSendMessage::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppSendMessage::message() const {
  // @@protoc_insertion_point(field_get:rustplus.AppSendMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppSendMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppSendMessage.message)
}
inline std::string* AppSendMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rustplus.AppSendMessage.message)
  return _s;
}
inline const std::string& AppSendMessage::_internal_message() const {
  return message_.Get();
}
inline void AppSendMessage::_internal_set_message(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppSendMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppSendMessage::release_message() {
  // @@protoc_insertion_point(field_release:rustplus.AppSendMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppSendMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppSendMessage.message)
}

// -------------------------------------------------------------------

// AppSetEntityValue

// required bool value = 1;
inline bool AppSetEntityValue::_internal_has_value() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppSetEntityValue::has_value() const {
  return _internal_has_value();
}
inline void AppSetEntityValue::clear_value() {
  value_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AppSetEntityValue::_internal_value() const {
  return value_;
}
inline bool AppSetEntityValue::m_iValue() const {
  // @@protoc_insertion_point(field_get:rustplus.AppSetEntityValue.value)
  return _internal_value();
}
inline void AppSetEntityValue::_internal_set_value(bool m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  value_ = m_iValue;
}
inline void AppSetEntityValue::set_value(bool m_iValue) {
  _internal_set_value(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppSetEntityValue.value)
}

// -------------------------------------------------------------------

// AppPromoteToLeader

// required int64 steamId = 1;
inline bool AppPromoteToLeader::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppPromoteToLeader::has_steamid() const {
  return _internal_has_steamid();
}
inline void AppPromoteToLeader::clear_steamid() {
  steamid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppPromoteToLeader::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppPromoteToLeader::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppPromoteToLeader.steamId)
  return _internal_steamid();
}
inline void AppPromoteToLeader::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = m_iValue;
}
inline void AppPromoteToLeader::set_steamid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppPromoteToLeader.steamId)
}

// -------------------------------------------------------------------

// AppGetNexusAuth

// required string appKey = 1;
inline bool AppGetNexusAuth::_internal_has_appkey() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppGetNexusAuth::has_appkey() const {
  return _internal_has_appkey();
}
inline void AppGetNexusAuth::clear_appkey() {
  appkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppGetNexusAuth::appkey() const {
  // @@protoc_insertion_point(field_get:rustplus.AppGetNexusAuth.appKey)
  return _internal_appkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppGetNexusAuth::set_appkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 appkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppGetNexusAuth.appKey)
}
inline std::string* AppGetNexusAuth::mutable_appkey() {
  std::string* _s = _internal_mutable_appkey();
  // @@protoc_insertion_point(field_mutable:rustplus.AppGetNexusAuth.appKey)
  return _s;
}
inline const std::string& AppGetNexusAuth::_internal_appkey() const {
  return appkey_.Get();
}
inline void AppGetNexusAuth::_internal_set_appkey(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  appkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppGetNexusAuth::_internal_mutable_appkey() {
  _has_bits_[0] |= 0x00000001u;
  return appkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppGetNexusAuth::release_appkey() {
  // @@protoc_insertion_point(field_release:rustplus.AppGetNexusAuth.appKey)
  if (!_internal_has_appkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return appkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppGetNexusAuth::set_allocated_appkey(std::string* appkey) {
  if (appkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  appkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appkey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppGetNexusAuth.appKey)
}

// -------------------------------------------------------------------

// AppSuccess

// -------------------------------------------------------------------

// AppError

// required string error = 1;
inline bool AppError::_internal_has_error() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppError::has_error() const {
  return _internal_has_error();
}
inline void AppError::clear_error() {
  error_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppError::error() const {
  // @@protoc_insertion_point(field_get:rustplus.AppError.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppError::set_error(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppError.error)
}
inline std::string* AppError::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:rustplus.AppError.error)
  return _s;
}
inline const std::string& AppError::_internal_error() const {
  return error_.Get();
}
inline void AppError::_internal_set_error(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppError::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppError::release_error() {
  // @@protoc_insertion_point(field_release:rustplus.AppError.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppError::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppError.error)
}

// -------------------------------------------------------------------

// AppFlag

// required bool value = 1;
inline bool AppFlag::_internal_has_value() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppFlag::has_value() const {
  return _internal_has_value();
}
inline void AppFlag::clear_value() {
  value_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AppFlag::_internal_value() const {
  return value_;
}
inline bool AppFlag::m_iValue() const {
  // @@protoc_insertion_point(field_get:rustplus.AppFlag.value)
  return _internal_value();
}
inline void AppFlag::_internal_set_value(bool m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  value_ = m_iValue;
}
inline void AppFlag::set_value(bool m_iValue) {
  _internal_set_value(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppFlag.value)
}

// -------------------------------------------------------------------

// AppInfo

// required string name = 1;
inline bool AppInfo::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_name() const {
  return _internal_has_name();
}
inline void AppInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInfo::name() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.name)
}
inline std::string* AppInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.name)
  return _s;
}
inline const std::string& AppInfo::_internal_name() const {
  return name_.Get();
}
inline void AppInfo::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.name)
}

// required string headerImage = 2;
inline bool AppInfo::_internal_has_headerimage() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_headerimage() const {
  return _internal_has_headerimage();
}
inline void AppInfo::clear_headerimage() {
  headerimage_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppInfo::headerimage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.headerImage)
  return _internal_headerimage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_headerimage(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 headerimage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.headerImage)
}
inline std::string* AppInfo::mutable_headerimage() {
  std::string* _s = _internal_mutable_headerimage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.headerImage)
  return _s;
}
inline const std::string& AppInfo::_internal_headerimage() const {
  return headerimage_.Get();
}
inline void AppInfo::_internal_set_headerimage(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  headerimage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_headerimage() {
  _has_bits_[0] |= 0x00000002u;
  return headerimage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_headerimage() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.headerImage)
  if (!_internal_has_headerimage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return headerimage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_headerimage(std::string* headerimage) {
  if (headerimage != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  headerimage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headerimage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.headerImage)
}

// required string url = 3;
inline bool AppInfo::_internal_has_url() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_url() const {
  return _internal_has_url();
}
inline void AppInfo::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppInfo::url() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.url)
}
inline std::string* AppInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.url)
  return _s;
}
inline const std::string& AppInfo::_internal_url() const {
  return url_.Get();
}
inline void AppInfo::_internal_set_url(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000004u;
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_url() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.url)
}

// required string map = 4;
inline bool AppInfo::_internal_has_map() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_map() const {
  return _internal_has_map();
}
inline void AppInfo::clear_map() {
  map_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AppInfo::map() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.map)
  return _internal_map();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_map(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 map_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.map)
}
inline std::string* AppInfo::mutable_map() {
  std::string* _s = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.map)
  return _s;
}
inline const std::string& AppInfo::_internal_map() const {
  return map_.Get();
}
inline void AppInfo::_internal_set_map(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  map_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_map() {
  _has_bits_[0] |= 0x00000008u;
  return map_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_map() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.map)
  if (!_internal_has_map()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return map_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_map(std::string* map) {
  if (map != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  map_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.map)
}

// required uint32 mapSize = 5;
inline bool AppInfo::_internal_has_mapsize() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_mapsize() const {
  return _internal_has_mapsize();
}
inline void AppInfo::clear_mapsize() {
  mapsize_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_mapsize() const {
  return mapsize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::mapsize() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.mapSize)
  return _internal_mapsize();
}
inline void AppInfo::_internal_set_mapsize(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000080u;
  mapsize_ = m_iValue;
}
inline void AppInfo::set_mapsize(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_mapsize(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.mapSize)
}

// required uint32 wipeTime = 6;
inline bool AppInfo::_internal_has_wipetime() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_wipetime() const {
  return _internal_has_wipetime();
}
inline void AppInfo::clear_wipetime() {
  wipetime_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_wipetime() const {
  return wipetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::wipetime() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.wipeTime)
  return _internal_wipetime();
}
inline void AppInfo::_internal_set_wipetime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000100u;
  wipetime_ = m_iValue;
}
inline void AppInfo::set_wipetime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_wipetime(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.wipeTime)
}

// required uint32 players = 7;
inline bool AppInfo::_internal_has_players() const {
  bool m_iValue = (_has_bits_[0] & 0x00000200u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_players() const {
  return _internal_has_players();
}
inline void AppInfo::clear_players() {
  players_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_players() const {
  return players_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::players() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.players)
  return _internal_players();
}
inline void AppInfo::_internal_set_players(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000200u;
  players_ = m_iValue;
}
inline void AppInfo::set_players(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_players(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.players)
}

// required uint32 maxPlayers = 8;
inline bool AppInfo::_internal_has_maxplayers() const {
  bool m_iValue = (_has_bits_[0] & 0x00000400u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_maxplayers() const {
  return _internal_has_maxplayers();
}
inline void AppInfo::clear_maxplayers() {
  maxplayers_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_maxplayers() const {
  return maxplayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::maxplayers() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.maxPlayers)
  return _internal_maxplayers();
}
inline void AppInfo::_internal_set_maxplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000400u;
  maxplayers_ = m_iValue;
}
inline void AppInfo::set_maxplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_maxplayers(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.maxPlayers)
}

// required uint32 queuedPlayers = 9;
inline bool AppInfo::_internal_has_queuedplayers() const {
  bool m_iValue = (_has_bits_[0] & 0x00000800u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_queuedplayers() const {
  return _internal_has_queuedplayers();
}
inline void AppInfo::clear_queuedplayers() {
  queuedplayers_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_queuedplayers() const {
  return queuedplayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::queuedplayers() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.queuedPlayers)
  return _internal_queuedplayers();
}
inline void AppInfo::_internal_set_queuedplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000800u;
  queuedplayers_ = m_iValue;
}
inline void AppInfo::set_queuedplayers(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_queuedplayers(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.queuedPlayers)
}

// optional uint32 seed = 10;
inline bool AppInfo::_internal_has_seed() const {
  bool m_iValue = (_has_bits_[0] & 0x00001000u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_seed() const {
  return _internal_has_seed();
}
inline void AppInfo::clear_seed() {
  seed_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_seed() const {
  return seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::seed() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.seed)
  return _internal_seed();
}
inline void AppInfo::_internal_set_seed(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00001000u;
  seed_ = m_iValue;
}
inline void AppInfo::set_seed(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_seed(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.seed)
}

// optional uint32 salt = 11;
inline bool AppInfo::_internal_has_salt() const {
  bool m_iValue = (_has_bits_[0] & 0x00002000u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_salt() const {
  return _internal_has_salt();
}
inline void AppInfo::clear_salt() {
  salt_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::_internal_salt() const {
  return salt_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppInfo::salt() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.salt)
  return _internal_salt();
}
inline void AppInfo::_internal_set_salt(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00002000u;
  salt_ = m_iValue;
}
inline void AppInfo::set_salt(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_salt(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.salt)
}

// optional string logoImage = 12;
inline bool AppInfo::_internal_has_logoimage() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_logoimage() const {
  return _internal_has_logoimage();
}
inline void AppInfo::clear_logoimage() {
  logoimage_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AppInfo::logoimage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.logoImage)
  return _internal_logoimage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_logoimage(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 logoimage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.logoImage)
}
inline std::string* AppInfo::mutable_logoimage() {
  std::string* _s = _internal_mutable_logoimage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.logoImage)
  return _s;
}
inline const std::string& AppInfo::_internal_logoimage() const {
  return logoimage_.Get();
}
inline void AppInfo::_internal_set_logoimage(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  logoimage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_logoimage() {
  _has_bits_[0] |= 0x00000010u;
  return logoimage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_logoimage() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.logoImage)
  if (!_internal_has_logoimage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return logoimage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_logoimage(std::string* logoimage) {
  if (logoimage != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  logoimage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logoimage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.logoImage)
}

// optional string nexus = 13;
inline bool AppInfo::_internal_has_nexus() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_nexus() const {
  return _internal_has_nexus();
}
inline void AppInfo::clear_nexus() {
  nexus_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AppInfo::nexus() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.nexus)
  return _internal_nexus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_nexus(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 nexus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.nexus)
}
inline std::string* AppInfo::mutable_nexus() {
  std::string* _s = _internal_mutable_nexus();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.nexus)
  return _s;
}
inline const std::string& AppInfo::_internal_nexus() const {
  return nexus_.Get();
}
inline void AppInfo::_internal_set_nexus(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  nexus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_nexus() {
  _has_bits_[0] |= 0x00000020u;
  return nexus_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_nexus() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.nexus)
  if (!_internal_has_nexus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return nexus_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_nexus(std::string* nexus) {
  if (nexus != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  nexus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nexus,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.nexus)
}

// optional int32 nexusId = 14;
inline bool AppInfo::_internal_has_nexusid() const {
  bool m_iValue = (_has_bits_[0] & 0x00004000u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_nexusid() const {
  return _internal_has_nexusid();
}
inline void AppInfo::clear_nexusid() {
  nexusid_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppInfo::_internal_nexusid() const {
  return nexusid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppInfo::nexusid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.nexusId)
  return _internal_nexusid();
}
inline void AppInfo::_internal_set_nexusid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00004000u;
  nexusid_ = m_iValue;
}
inline void AppInfo::set_nexusid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_nexusid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.nexusId)
}

// optional string nexusZone = 15;
inline bool AppInfo::_internal_has_nexuszone() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  return m_iValue;
}
inline bool AppInfo::has_nexuszone() const {
  return _internal_has_nexuszone();
}
inline void AppInfo::clear_nexuszone() {
  nexuszone_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& AppInfo::nexuszone() const {
  // @@protoc_insertion_point(field_get:rustplus.AppInfo.nexusZone)
  return _internal_nexuszone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_nexuszone(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 nexuszone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppInfo.nexusZone)
}
inline std::string* AppInfo::mutable_nexuszone() {
  std::string* _s = _internal_mutable_nexuszone();
  // @@protoc_insertion_point(field_mutable:rustplus.AppInfo.nexusZone)
  return _s;
}
inline const std::string& AppInfo::_internal_nexuszone() const {
  return nexuszone_.Get();
}
inline void AppInfo::_internal_set_nexuszone(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000040u;
  nexuszone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_nexuszone() {
  _has_bits_[0] |= 0x00000040u;
  return nexuszone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_nexuszone() {
  // @@protoc_insertion_point(field_release:rustplus.AppInfo.nexusZone)
  if (!_internal_has_nexuszone()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return nexuszone_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfo::set_allocated_nexuszone(std::string* nexuszone) {
  if (nexuszone != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  nexuszone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nexuszone,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppInfo.nexusZone)
}

// -------------------------------------------------------------------

// AppTime

// required float dayLengthMinutes = 1;
inline bool AppTime::_internal_has_daylengthminutes() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppTime::has_daylengthminutes() const {
  return _internal_has_daylengthminutes();
}
inline void AppTime::clear_daylengthminutes() {
  daylengthminutes_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float AppTime::_internal_daylengthminutes() const {
  return daylengthminutes_;
}
inline float AppTime::daylengthminutes() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTime.dayLengthMinutes)
  return _internal_daylengthminutes();
}
inline void AppTime::_internal_set_daylengthminutes(float m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  daylengthminutes_ = m_iValue;
}
inline void AppTime::set_daylengthminutes(float m_iValue) {
  _internal_set_daylengthminutes(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTime.dayLengthMinutes)
}

// required float timeScale = 2;
inline bool AppTime::_internal_has_timescale() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppTime::has_timescale() const {
  return _internal_has_timescale();
}
inline void AppTime::clear_timescale() {
  timescale_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AppTime::_internal_timescale() const {
  return timescale_;
}
inline float AppTime::timescale() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTime.timeScale)
  return _internal_timescale();
}
inline void AppTime::_internal_set_timescale(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  timescale_ = m_iValue;
}
inline void AppTime::set_timescale(float m_iValue) {
  _internal_set_timescale(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTime.timeScale)
}

// required float sunrise = 3;
inline bool AppTime::_internal_has_sunrise() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppTime::has_sunrise() const {
  return _internal_has_sunrise();
}
inline void AppTime::clear_sunrise() {
  sunrise_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AppTime::_internal_sunrise() const {
  return sunrise_;
}
inline float AppTime::sunrise() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTime.sunrise)
  return _internal_sunrise();
}
inline void AppTime::_internal_set_sunrise(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  sunrise_ = m_iValue;
}
inline void AppTime::set_sunrise(float m_iValue) {
  _internal_set_sunrise(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTime.sunrise)
}

// required float sunset = 4;
inline bool AppTime::_internal_has_sunset() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppTime::has_sunset() const {
  return _internal_has_sunset();
}
inline void AppTime::clear_sunset() {
  sunset_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float AppTime::_internal_sunset() const {
  return sunset_;
}
inline float AppTime::sunset() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTime.sunset)
  return _internal_sunset();
}
inline void AppTime::_internal_set_sunset(float m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  sunset_ = m_iValue;
}
inline void AppTime::set_sunset(float m_iValue) {
  _internal_set_sunset(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTime.sunset)
}

// required float time = 5;
inline bool AppTime::_internal_has_time() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppTime::has_time() const {
  return _internal_has_time();
}
inline void AppTime::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float AppTime::_internal_time() const {
  return time_;
}
inline float AppTime::time() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTime.time)
  return _internal_time();
}
inline void AppTime::_internal_set_time(float m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  time_ = m_iValue;
}
inline void AppTime::set_time(float m_iValue) {
  _internal_set_time(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTime.time)
}

// -------------------------------------------------------------------

// AppMap_Monument

// required string token = 1;
inline bool AppMap_Monument::_internal_has_token() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppMap_Monument::has_token() const {
  return _internal_has_token();
}
inline void AppMap_Monument::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppMap_Monument::token() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.Monument.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMap_Monument::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppMap.Monument.token)
}
inline std::string* AppMap_Monument::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMap.Monument.token)
  return _s;
}
inline const std::string& AppMap_Monument::_internal_token() const {
  return token_.Get();
}
inline void AppMap_Monument::_internal_set_token(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppMap_Monument::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppMap_Monument::release_token() {
  // @@protoc_insertion_point(field_release:rustplus.AppMap.Monument.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppMap_Monument::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMap.Monument.token)
}

// required float x = 2;
inline bool AppMap_Monument::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppMap_Monument::has_x() const {
  return _internal_has_x();
}
inline void AppMap_Monument::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AppMap_Monument::_internal_x() const {
  return x_;
}
inline float AppMap_Monument::x() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.Monument.x)
  return _internal_x();
}
inline void AppMap_Monument::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  x_ = m_iValue;
}
inline void AppMap_Monument::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMap.Monument.x)
}

// required float y = 3;
inline bool AppMap_Monument::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppMap_Monument::has_y() const {
  return _internal_has_y();
}
inline void AppMap_Monument::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AppMap_Monument::_internal_y() const {
  return y_;
}
inline float AppMap_Monument::y() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.Monument.y)
  return _internal_y();
}
inline void AppMap_Monument::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  y_ = m_iValue;
}
inline void AppMap_Monument::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMap.Monument.y)
}

// -------------------------------------------------------------------

// AppMap

// required uint32 width = 1;
inline bool AppMap::_internal_has_width() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppMap::has_width() const {
  return _internal_has_width();
}
inline void AppMap::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppMap::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppMap::width() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.width)
  return _internal_width();
}
inline void AppMap::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  width_ = m_iValue;
}
inline void AppMap::set_width(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_width(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMap.width)
}

// required uint32 height = 2;
inline bool AppMap::_internal_has_height() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppMap::has_height() const {
  return _internal_has_height();
}
inline void AppMap::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppMap::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppMap::height() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.height)
  return _internal_height();
}
inline void AppMap::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  height_ = m_iValue;
}
inline void AppMap::set_height(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_height(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMap.height)
}

// required bytes jpgImage = 3;
inline bool AppMap::_internal_has_jpgimage() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppMap::has_jpgimage() const {
  return _internal_has_jpgimage();
}
inline void AppMap::clear_jpgimage() {
  jpgimage_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppMap::jpgimage() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.jpgImage)
  return _internal_jpgimage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMap::set_jpgimage(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 jpgimage_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppMap.jpgImage)
}
inline std::string* AppMap::mutable_jpgimage() {
  std::string* _s = _internal_mutable_jpgimage();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMap.jpgImage)
  return _s;
}
inline const std::string& AppMap::_internal_jpgimage() const {
  return jpgimage_.Get();
}
inline void AppMap::_internal_set_jpgimage(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  jpgimage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppMap::_internal_mutable_jpgimage() {
  _has_bits_[0] |= 0x00000001u;
  return jpgimage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppMap::release_jpgimage() {
  // @@protoc_insertion_point(field_release:rustplus.AppMap.jpgImage)
  if (!_internal_has_jpgimage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return jpgimage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppMap::set_allocated_jpgimage(std::string* jpgimage) {
  if (jpgimage != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  jpgimage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jpgimage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMap.jpgImage)
}

// required int32 oceanMargin = 4;
inline bool AppMap::_internal_has_oceanmargin() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppMap::has_oceanmargin() const {
  return _internal_has_oceanmargin();
}
inline void AppMap::clear_oceanmargin() {
  oceanmargin_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMap::_internal_oceanmargin() const {
  return oceanmargin_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMap::oceanmargin() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.oceanMargin)
  return _internal_oceanmargin();
}
inline void AppMap::_internal_set_oceanmargin(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  oceanmargin_ = m_iValue;
}
inline void AppMap::set_oceanmargin(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_oceanmargin(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMap.oceanMargin)
}

// repeated .rustplus.AppMap.Monument monuments = 5;
inline int AppMap::_internal_monuments_size() const {
  return monuments_.size();
}
inline int AppMap::monuments_size() const {
  return _internal_monuments_size();
}
inline void AppMap::clear_monuments() {
  monuments_.Clear();
}
inline ::rustplus::AppMap_Monument* AppMap::mutable_monuments(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppMap.monuments)
  return monuments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMap_Monument >*
AppMap::mutable_monuments() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppMap.monuments)
  return &monuments_;
}
inline const ::rustplus::AppMap_Monument& AppMap::_internal_monuments(int index) const {
  return monuments_.Get(index);
}
inline const ::rustplus::AppMap_Monument& AppMap::monuments(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.monuments)
  return _internal_monuments(index);
}
inline ::rustplus::AppMap_Monument* AppMap::_internal_add_monuments() {
  return monuments_.Add();
}
inline ::rustplus::AppMap_Monument* AppMap::add_monuments() {
  ::rustplus::AppMap_Monument* _add = _internal_add_monuments();
  // @@protoc_insertion_point(field_add:rustplus.AppMap.monuments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMap_Monument >&
AppMap::monuments() const {
  // @@protoc_insertion_point(field_list:rustplus.AppMap.monuments)
  return monuments_;
}

// optional string background = 6;
inline bool AppMap::_internal_has_background() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppMap::has_background() const {
  return _internal_has_background();
}
inline void AppMap::clear_background() {
  background_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppMap::background() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMap.background)
  return _internal_background();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMap::set_background(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 background_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppMap.background)
}
inline std::string* AppMap::mutable_background() {
  std::string* _s = _internal_mutable_background();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMap.background)
  return _s;
}
inline const std::string& AppMap::_internal_background() const {
  return background_.Get();
}
inline void AppMap::_internal_set_background(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  background_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppMap::_internal_mutable_background() {
  _has_bits_[0] |= 0x00000002u;
  return background_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppMap::release_background() {
  // @@protoc_insertion_point(field_release:rustplus.AppMap.background)
  if (!_internal_has_background()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return background_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppMap::set_allocated_background(std::string* background) {
  if (background != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  background_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), background,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMap.background)
}

// -------------------------------------------------------------------

// AppEntityInfo

// required .rustplus.AppEntityType type = 1;
inline bool AppEntityInfo::_internal_has_type() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppEntityInfo::has_type() const {
  return _internal_has_type();
}
inline void AppEntityInfo::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::rustplus::AppEntityType AppEntityInfo::_internal_type() const {
  return static_cast< ::rustplus::AppEntityType >(type_);
}
inline ::rustplus::AppEntityType AppEntityInfo::type() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityInfo.type)
  return _internal_type();
}
inline void AppEntityInfo::_internal_set_type(::rustplus::AppEntityType m_iValue) {
  assert(::rustplus::AppEntityType_IsValid(m_iValue));
  _has_bits_[0] |= 0x00000002u;
  type_ = m_iValue;
}
inline void AppEntityInfo::set_type(::rustplus::AppEntityType m_iValue) {
  _internal_set_type(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityInfo.type)
}

// required .rustplus.AppEntityPayload payload = 3;
inline bool AppEntityInfo::_internal_has_payload() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || payload_ != nullptr);
  return m_iValue;
}
inline bool AppEntityInfo::has_payload() const {
  return _internal_has_payload();
}
inline void AppEntityInfo::clear_payload() {
  if (payload_ != nullptr) payload_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppEntityPayload& AppEntityInfo::_internal_payload() const {
  const ::rustplus::AppEntityPayload* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEntityPayload&>(
      ::rustplus::_AppEntityPayload_default_instance_);
}
inline const ::rustplus::AppEntityPayload& AppEntityInfo::payload() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityInfo.payload)
  return _internal_payload();
}
inline void AppEntityInfo::unsafe_arena_set_allocated_payload(
    ::rustplus::AppEntityPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppEntityInfo.payload)
}
inline ::rustplus::AppEntityPayload* AppEntityInfo::release_payload() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppEntityPayload* temp = payload_;
  payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEntityPayload* AppEntityInfo::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:rustplus.AppEntityInfo.payload)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppEntityPayload* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::rustplus::AppEntityPayload* AppEntityInfo::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEntityPayload>(GetArenaForAllocation());
    payload_ = p;
  }
  return payload_;
}
inline ::rustplus::AppEntityPayload* AppEntityInfo::mutable_payload() {
  ::rustplus::AppEntityPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:rustplus.AppEntityInfo.payload)
  return _msg;
}
inline void AppEntityInfo::set_allocated_payload(::rustplus::AppEntityPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEntityPayload>::GetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppEntityInfo.payload)
}

// -------------------------------------------------------------------

// AppEntityPayload_Item

// required int32 itemId = 1;
inline bool AppEntityPayload_Item::_internal_has_itemid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload_Item::has_itemid() const {
  return _internal_has_itemid();
}
inline void AppEntityPayload_Item::clear_itemid() {
  itemid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppEntityPayload_Item::_internal_itemid() const {
  return itemid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppEntityPayload_Item::itemid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.Item.itemId)
  return _internal_itemid();
}
inline void AppEntityPayload_Item::_internal_set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  itemid_ = m_iValue;
}
inline void AppEntityPayload_Item::set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_itemid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.Item.itemId)
}

// required int32 quantity = 2;
inline bool AppEntityPayload_Item::_internal_has_quantity() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload_Item::has_quantity() const {
  return _internal_has_quantity();
}
inline void AppEntityPayload_Item::clear_quantity() {
  quantity_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppEntityPayload_Item::_internal_quantity() const {
  return quantity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppEntityPayload_Item::quantity() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.Item.quantity)
  return _internal_quantity();
}
inline void AppEntityPayload_Item::_internal_set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  quantity_ = m_iValue;
}
inline void AppEntityPayload_Item::set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_quantity(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.Item.quantity)
}

// required bool itemIsBlueprint = 3;
inline bool AppEntityPayload_Item::_internal_has_itemisblueprint() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload_Item::has_itemisblueprint() const {
  return _internal_has_itemisblueprint();
}
inline void AppEntityPayload_Item::clear_itemisblueprint() {
  itemisblueprint_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool AppEntityPayload_Item::_internal_itemisblueprint() const {
  return itemisblueprint_;
}
inline bool AppEntityPayload_Item::itemisblueprint() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.Item.itemIsBlueprint)
  return _internal_itemisblueprint();
}
inline void AppEntityPayload_Item::_internal_set_itemisblueprint(bool m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  itemisblueprint_ = m_iValue;
}
inline void AppEntityPayload_Item::set_itemisblueprint(bool m_iValue) {
  _internal_set_itemisblueprint(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.Item.itemIsBlueprint)
}

// -------------------------------------------------------------------

// AppEntityPayload

// optional bool value = 1;
inline bool AppEntityPayload::_internal_has_value() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload::has_value() const {
  return _internal_has_value();
}
inline void AppEntityPayload::clear_value() {
  value_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AppEntityPayload::_internal_value() const {
  return value_;
}
inline bool AppEntityPayload::m_iValue() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.value)
  return _internal_value();
}
inline void AppEntityPayload::_internal_set_value(bool m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  value_ = m_iValue;
}
inline void AppEntityPayload::set_value(bool m_iValue) {
  _internal_set_value(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.value)
}

// repeated .rustplus.AppEntityPayload.Item items = 2;
inline int AppEntityPayload::_internal_items_size() const {
  return items_.size();
}
inline int AppEntityPayload::items_size() const {
  return _internal_items_size();
}
inline void AppEntityPayload::clear_items() {
  items_.Clear();
}
inline ::rustplus::AppEntityPayload_Item* AppEntityPayload::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppEntityPayload.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppEntityPayload_Item >*
AppEntityPayload::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppEntityPayload.items)
  return &items_;
}
inline const ::rustplus::AppEntityPayload_Item& AppEntityPayload::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::rustplus::AppEntityPayload_Item& AppEntityPayload::items(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.items)
  return _internal_items(index);
}
inline ::rustplus::AppEntityPayload_Item* AppEntityPayload::_internal_add_items() {
  return items_.Add();
}
inline ::rustplus::AppEntityPayload_Item* AppEntityPayload::add_items() {
  ::rustplus::AppEntityPayload_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:rustplus.AppEntityPayload.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppEntityPayload_Item >&
AppEntityPayload::items() const {
  // @@protoc_insertion_point(field_list:rustplus.AppEntityPayload.items)
  return items_;
}

// optional int32 capacity = 3;
inline bool AppEntityPayload::_internal_has_capacity() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload::has_capacity() const {
  return _internal_has_capacity();
}
inline void AppEntityPayload::clear_capacity() {
  capacity_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppEntityPayload::_internal_capacity() const {
  return capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppEntityPayload::capacity() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.capacity)
  return _internal_capacity();
}
inline void AppEntityPayload::_internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  capacity_ = m_iValue;
}
inline void AppEntityPayload::set_capacity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_capacity(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.capacity)
}

// optional bool hasProtection = 4;
inline bool AppEntityPayload::_internal_has_hasprotection() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload::has_hasprotection() const {
  return _internal_has_hasprotection();
}
inline void AppEntityPayload::clear_hasprotection() {
  hasprotection_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AppEntityPayload::_internal_hasprotection() const {
  return hasprotection_;
}
inline bool AppEntityPayload::hasprotection() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.hasProtection)
  return _internal_hasprotection();
}
inline void AppEntityPayload::_internal_set_hasprotection(bool m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  hasprotection_ = m_iValue;
}
inline void AppEntityPayload::set_hasprotection(bool m_iValue) {
  _internal_set_hasprotection(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.hasProtection)
}

// optional uint32 protectionExpiry = 5;
inline bool AppEntityPayload::_internal_has_protectionexpiry() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppEntityPayload::has_protectionexpiry() const {
  return _internal_has_protectionexpiry();
}
inline void AppEntityPayload::clear_protectionexpiry() {
  protectionexpiry_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppEntityPayload::_internal_protectionexpiry() const {
  return protectionexpiry_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppEntityPayload::protectionexpiry() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityPayload.protectionExpiry)
  return _internal_protectionexpiry();
}
inline void AppEntityPayload::_internal_set_protectionexpiry(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  protectionexpiry_ = m_iValue;
}
inline void AppEntityPayload::set_protectionexpiry(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_protectionexpiry(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityPayload.protectionExpiry)
}

// -------------------------------------------------------------------

// AppTeamInfo_Member

// required uint64 steamId = 1;
inline bool AppTeamInfo_Member::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_steamid() const {
  return _internal_has_steamid();
}
inline void AppTeamInfo_Member::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamInfo_Member::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamInfo_Member::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.steamId)
  return _internal_steamid();
}
inline void AppTeamInfo_Member::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = m_iValue;
}
inline void AppTeamInfo_Member::set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.steamId)
}

// required string name = 2;
inline bool AppTeamInfo_Member::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_name() const {
  return _internal_has_name();
}
inline void AppTeamInfo_Member::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppTeamInfo_Member::name() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppTeamInfo_Member::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.name)
}
inline std::string* AppTeamInfo_Member::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamInfo.Member.name)
  return _s;
}
inline const std::string& AppTeamInfo_Member::_internal_name() const {
  return name_.Get();
}
inline void AppTeamInfo_Member::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppTeamInfo_Member::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppTeamInfo_Member::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.AppTeamInfo.Member.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppTeamInfo_Member::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppTeamInfo.Member.name)
}

// required float x = 3;
inline bool AppTeamInfo_Member::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_x() const {
  return _internal_has_x();
}
inline void AppTeamInfo_Member::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AppTeamInfo_Member::_internal_x() const {
  return x_;
}
inline float AppTeamInfo_Member::x() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.x)
  return _internal_x();
}
inline void AppTeamInfo_Member::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  x_ = m_iValue;
}
inline void AppTeamInfo_Member::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.x)
}

// required float y = 4;
inline bool AppTeamInfo_Member::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_y() const {
  return _internal_has_y();
}
inline void AppTeamInfo_Member::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float AppTeamInfo_Member::_internal_y() const {
  return y_;
}
inline float AppTeamInfo_Member::y() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.y)
  return _internal_y();
}
inline void AppTeamInfo_Member::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  y_ = m_iValue;
}
inline void AppTeamInfo_Member::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.y)
}

// required bool isOnline = 5;
inline bool AppTeamInfo_Member::_internal_has_isonline() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_isonline() const {
  return _internal_has_isonline();
}
inline void AppTeamInfo_Member::clear_isonline() {
  isonline_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool AppTeamInfo_Member::_internal_isonline() const {
  return isonline_;
}
inline bool AppTeamInfo_Member::isonline() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.isOnline)
  return _internal_isonline();
}
inline void AppTeamInfo_Member::_internal_set_isonline(bool m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  isonline_ = m_iValue;
}
inline void AppTeamInfo_Member::set_isonline(bool m_iValue) {
  _internal_set_isonline(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.isOnline)
}

// required uint32 spawnTime = 6;
inline bool AppTeamInfo_Member::_internal_has_spawntime() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_spawntime() const {
  return _internal_has_spawntime();
}
inline void AppTeamInfo_Member::clear_spawntime() {
  spawntime_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppTeamInfo_Member::_internal_spawntime() const {
  return spawntime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppTeamInfo_Member::spawntime() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.spawnTime)
  return _internal_spawntime();
}
inline void AppTeamInfo_Member::_internal_set_spawntime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  spawntime_ = m_iValue;
}
inline void AppTeamInfo_Member::set_spawntime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_spawntime(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.spawnTime)
}

// required bool isAlive = 7;
inline bool AppTeamInfo_Member::_internal_has_isalive() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_isalive() const {
  return _internal_has_isalive();
}
inline void AppTeamInfo_Member::clear_isalive() {
  isalive_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool AppTeamInfo_Member::_internal_isalive() const {
  return isalive_;
}
inline bool AppTeamInfo_Member::isalive() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.isAlive)
  return _internal_isalive();
}
inline void AppTeamInfo_Member::_internal_set_isalive(bool m_iValue) {
  _has_bits_[0] |= 0x00000040u;
  isalive_ = m_iValue;
}
inline void AppTeamInfo_Member::set_isalive(bool m_iValue) {
  _internal_set_isalive(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.isAlive)
}

// required uint32 deathTime = 8;
inline bool AppTeamInfo_Member::_internal_has_deathtime() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Member::has_deathtime() const {
  return _internal_has_deathtime();
}
inline void AppTeamInfo_Member::clear_deathtime() {
  deathtime_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppTeamInfo_Member::_internal_deathtime() const {
  return deathtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppTeamInfo_Member::deathtime() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Member.deathTime)
  return _internal_deathtime();
}
inline void AppTeamInfo_Member::_internal_set_deathtime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000080u;
  deathtime_ = m_iValue;
}
inline void AppTeamInfo_Member::set_deathtime(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_deathtime(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Member.deathTime)
}

// -------------------------------------------------------------------

// AppTeamInfo_Note

// required int32 type = 2;
inline bool AppTeamInfo_Note::_internal_has_type() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Note::has_type() const {
  return _internal_has_type();
}
inline void AppTeamInfo_Note::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppTeamInfo_Note::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppTeamInfo_Note::type() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Note.type)
  return _internal_type();
}
inline void AppTeamInfo_Note::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  type_ = m_iValue;
}
inline void AppTeamInfo_Note::set_type(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_type(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Note.type)
}

// required float x = 3;
inline bool AppTeamInfo_Note::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Note::has_x() const {
  return _internal_has_x();
}
inline void AppTeamInfo_Note::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AppTeamInfo_Note::_internal_x() const {
  return x_;
}
inline float AppTeamInfo_Note::x() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Note.x)
  return _internal_x();
}
inline void AppTeamInfo_Note::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  x_ = m_iValue;
}
inline void AppTeamInfo_Note::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Note.x)
}

// required float y = 4;
inline bool AppTeamInfo_Note::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo_Note::has_y() const {
  return _internal_has_y();
}
inline void AppTeamInfo_Note::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AppTeamInfo_Note::_internal_y() const {
  return y_;
}
inline float AppTeamInfo_Note::y() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.Note.y)
  return _internal_y();
}
inline void AppTeamInfo_Note::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  y_ = m_iValue;
}
inline void AppTeamInfo_Note::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.Note.y)
}

// -------------------------------------------------------------------

// AppTeamInfo

// required uint64 leaderSteamId = 1;
inline bool AppTeamInfo::_internal_has_leadersteamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppTeamInfo::has_leadersteamid() const {
  return _internal_has_leadersteamid();
}
inline void AppTeamInfo::clear_leadersteamid() {
  leadersteamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamInfo::_internal_leadersteamid() const {
  return leadersteamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamInfo::leadersteamid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.leaderSteamId)
  return _internal_leadersteamid();
}
inline void AppTeamInfo::_internal_set_leadersteamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  leadersteamid_ = m_iValue;
}
inline void AppTeamInfo::set_leadersteamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_leadersteamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamInfo.leaderSteamId)
}

// repeated .rustplus.AppTeamInfo.Member members = 2;
inline int AppTeamInfo::_internal_members_size() const {
  return members_.size();
}
inline int AppTeamInfo::members_size() const {
  return _internal_members_size();
}
inline void AppTeamInfo::clear_members() {
  members_.Clear();
}
inline ::rustplus::AppTeamInfo_Member* AppTeamInfo::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamInfo.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Member >*
AppTeamInfo::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppTeamInfo.members)
  return &members_;
}
inline const ::rustplus::AppTeamInfo_Member& AppTeamInfo::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::rustplus::AppTeamInfo_Member& AppTeamInfo::members(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.members)
  return _internal_members(index);
}
inline ::rustplus::AppTeamInfo_Member* AppTeamInfo::_internal_add_members() {
  return members_.Add();
}
inline ::rustplus::AppTeamInfo_Member* AppTeamInfo::add_members() {
  ::rustplus::AppTeamInfo_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:rustplus.AppTeamInfo.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Member >&
AppTeamInfo::members() const {
  // @@protoc_insertion_point(field_list:rustplus.AppTeamInfo.members)
  return members_;
}

// repeated .rustplus.AppTeamInfo.Note mapNotes = 3;
inline int AppTeamInfo::_internal_mapnotes_size() const {
  return mapnotes_.size();
}
inline int AppTeamInfo::mapnotes_size() const {
  return _internal_mapnotes_size();
}
inline void AppTeamInfo::clear_mapnotes() {
  mapnotes_.Clear();
}
inline ::rustplus::AppTeamInfo_Note* AppTeamInfo::mutable_mapnotes(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamInfo.mapNotes)
  return mapnotes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >*
AppTeamInfo::mutable_mapnotes() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppTeamInfo.mapNotes)
  return &mapnotes_;
}
inline const ::rustplus::AppTeamInfo_Note& AppTeamInfo::_internal_mapnotes(int index) const {
  return mapnotes_.Get(index);
}
inline const ::rustplus::AppTeamInfo_Note& AppTeamInfo::mapnotes(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.mapNotes)
  return _internal_mapnotes(index);
}
inline ::rustplus::AppTeamInfo_Note* AppTeamInfo::_internal_add_mapnotes() {
  return mapnotes_.Add();
}
inline ::rustplus::AppTeamInfo_Note* AppTeamInfo::add_mapnotes() {
  ::rustplus::AppTeamInfo_Note* _add = _internal_add_mapnotes();
  // @@protoc_insertion_point(field_add:rustplus.AppTeamInfo.mapNotes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >&
AppTeamInfo::mapnotes() const {
  // @@protoc_insertion_point(field_list:rustplus.AppTeamInfo.mapNotes)
  return mapnotes_;
}

// repeated .rustplus.AppTeamInfo.Note leaderMapNotes = 4;
inline int AppTeamInfo::_internal_leadermapnotes_size() const {
  return leadermapnotes_.size();
}
inline int AppTeamInfo::leadermapnotes_size() const {
  return _internal_leadermapnotes_size();
}
inline void AppTeamInfo::clear_leadermapnotes() {
  leadermapnotes_.Clear();
}
inline ::rustplus::AppTeamInfo_Note* AppTeamInfo::mutable_leadermapnotes(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamInfo.leaderMapNotes)
  return leadermapnotes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >*
AppTeamInfo::mutable_leadermapnotes() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppTeamInfo.leaderMapNotes)
  return &leadermapnotes_;
}
inline const ::rustplus::AppTeamInfo_Note& AppTeamInfo::_internal_leadermapnotes(int index) const {
  return leadermapnotes_.Get(index);
}
inline const ::rustplus::AppTeamInfo_Note& AppTeamInfo::leadermapnotes(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamInfo.leaderMapNotes)
  return _internal_leadermapnotes(index);
}
inline ::rustplus::AppTeamInfo_Note* AppTeamInfo::_internal_add_leadermapnotes() {
  return leadermapnotes_.Add();
}
inline ::rustplus::AppTeamInfo_Note* AppTeamInfo::add_leadermapnotes() {
  ::rustplus::AppTeamInfo_Note* _add = _internal_add_leadermapnotes();
  // @@protoc_insertion_point(field_add:rustplus.AppTeamInfo.leaderMapNotes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamInfo_Note >&
AppTeamInfo::leadermapnotes() const {
  // @@protoc_insertion_point(field_list:rustplus.AppTeamInfo.leaderMapNotes)
  return leadermapnotes_;
}

// -------------------------------------------------------------------

// AppTeamMessage

// required uint64 steamId = 1;
inline bool AppTeamMessage::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppTeamMessage::has_steamid() const {
  return _internal_has_steamid();
}
inline void AppTeamMessage::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamMessage::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamMessage::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamMessage.steamId)
  return _internal_steamid();
}
inline void AppTeamMessage::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  steamid_ = m_iValue;
}
inline void AppTeamMessage::set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamMessage.steamId)
}

// required string name = 2;
inline bool AppTeamMessage::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppTeamMessage::has_name() const {
  return _internal_has_name();
}
inline void AppTeamMessage::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppTeamMessage::name() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppTeamMessage::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppTeamMessage.name)
}
inline std::string* AppTeamMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamMessage.name)
  return _s;
}
inline const std::string& AppTeamMessage::_internal_name() const {
  return name_.Get();
}
inline void AppTeamMessage::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppTeamMessage::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppTeamMessage::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.AppTeamMessage.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppTeamMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppTeamMessage.name)
}

// required string message = 3;
inline bool AppTeamMessage::_internal_has_message() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppTeamMessage::has_message() const {
  return _internal_has_message();
}
inline void AppTeamMessage::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppTeamMessage::message() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppTeamMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppTeamMessage.message)
}
inline std::string* AppTeamMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamMessage.message)
  return _s;
}
inline const std::string& AppTeamMessage::_internal_message() const {
  return message_.Get();
}
inline void AppTeamMessage::_internal_set_message(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppTeamMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppTeamMessage::release_message() {
  // @@protoc_insertion_point(field_release:rustplus.AppTeamMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppTeamMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppTeamMessage.message)
}

// required string color = 4;
inline bool AppTeamMessage::_internal_has_color() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppTeamMessage::has_color() const {
  return _internal_has_color();
}
inline void AppTeamMessage::clear_color() {
  color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppTeamMessage::color() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamMessage.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppTeamMessage::set_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppTeamMessage.color)
}
inline std::string* AppTeamMessage::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamMessage.color)
  return _s;
}
inline const std::string& AppTeamMessage::_internal_color() const {
  return color_.Get();
}
inline void AppTeamMessage::_internal_set_color(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppTeamMessage::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000004u;
  return color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppTeamMessage::release_color() {
  // @@protoc_insertion_point(field_release:rustplus.AppTeamMessage.color)
  if (!_internal_has_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppTeamMessage::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), color,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppTeamMessage.color)
}

// required uint32 time = 5;
inline bool AppTeamMessage::_internal_has_time() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppTeamMessage::has_time() const {
  return _internal_has_time();
}
inline void AppTeamMessage::clear_time() {
  time_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppTeamMessage::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppTeamMessage::time() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamMessage.time)
  return _internal_time();
}
inline void AppTeamMessage::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  time_ = m_iValue;
}
inline void AppTeamMessage::set_time(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_time(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamMessage.time)
}

// -------------------------------------------------------------------

// AppTeamChat

// repeated .rustplus.AppTeamMessage messages = 1;
inline int AppTeamChat::_internal_messages_size() const {
  return messages_.size();
}
inline int AppTeamChat::messages_size() const {
  return _internal_messages_size();
}
inline void AppTeamChat::clear_messages() {
  messages_.Clear();
}
inline ::rustplus::AppTeamMessage* AppTeamChat::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamChat.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamMessage >*
AppTeamChat::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppTeamChat.messages)
  return &messages_;
}
inline const ::rustplus::AppTeamMessage& AppTeamChat::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::rustplus::AppTeamMessage& AppTeamChat::messages(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamChat.messages)
  return _internal_messages(index);
}
inline ::rustplus::AppTeamMessage* AppTeamChat::_internal_add_messages() {
  return messages_.Add();
}
inline ::rustplus::AppTeamMessage* AppTeamChat::add_messages() {
  ::rustplus::AppTeamMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:rustplus.AppTeamChat.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppTeamMessage >&
AppTeamChat::messages() const {
  // @@protoc_insertion_point(field_list:rustplus.AppTeamChat.messages)
  return messages_;
}

// -------------------------------------------------------------------

// AppMarker_SellOrder

// required int32 itemId = 1;
inline bool AppMarker_SellOrder::_internal_has_itemid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_itemid() const {
  return _internal_has_itemid();
}
inline void AppMarker_SellOrder::clear_itemid() {
  itemid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::_internal_itemid() const {
  return itemid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::itemid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.itemId)
  return _internal_itemid();
}
inline void AppMarker_SellOrder::_internal_set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  itemid_ = m_iValue;
}
inline void AppMarker_SellOrder::set_itemid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_itemid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.itemId)
}

// required int32 quantity = 2;
inline bool AppMarker_SellOrder::_internal_has_quantity() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_quantity() const {
  return _internal_has_quantity();
}
inline void AppMarker_SellOrder::clear_quantity() {
  quantity_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::_internal_quantity() const {
  return quantity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::quantity() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.quantity)
  return _internal_quantity();
}
inline void AppMarker_SellOrder::_internal_set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  quantity_ = m_iValue;
}
inline void AppMarker_SellOrder::set_quantity(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_quantity(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.quantity)
}

// required int32 currencyId = 3;
inline bool AppMarker_SellOrder::_internal_has_currencyid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_currencyid() const {
  return _internal_has_currencyid();
}
inline void AppMarker_SellOrder::clear_currencyid() {
  currencyid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::_internal_currencyid() const {
  return currencyid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::currencyid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.currencyId)
  return _internal_currencyid();
}
inline void AppMarker_SellOrder::_internal_set_currencyid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  currencyid_ = m_iValue;
}
inline void AppMarker_SellOrder::set_currencyid(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_currencyid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.currencyId)
}

// required int32 costPerItem = 4;
inline bool AppMarker_SellOrder::_internal_has_costperitem() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_costperitem() const {
  return _internal_has_costperitem();
}
inline void AppMarker_SellOrder::clear_costperitem() {
  costperitem_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::_internal_costperitem() const {
  return costperitem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::costperitem() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.costPerItem)
  return _internal_costperitem();
}
inline void AppMarker_SellOrder::_internal_set_costperitem(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  costperitem_ = m_iValue;
}
inline void AppMarker_SellOrder::set_costperitem(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_costperitem(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.costPerItem)
}

// required int32 amountInStock = 5;
inline bool AppMarker_SellOrder::_internal_has_amountinstock() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_amountinstock() const {
  return _internal_has_amountinstock();
}
inline void AppMarker_SellOrder::clear_amountinstock() {
  amountinstock_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::_internal_amountinstock() const {
  return amountinstock_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppMarker_SellOrder::amountinstock() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.amountInStock)
  return _internal_amountinstock();
}
inline void AppMarker_SellOrder::_internal_set_amountinstock(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  amountinstock_ = m_iValue;
}
inline void AppMarker_SellOrder::set_amountinstock(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_amountinstock(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.amountInStock)
}

// required bool itemIsBlueprint = 6;
inline bool AppMarker_SellOrder::_internal_has_itemisblueprint() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_itemisblueprint() const {
  return _internal_has_itemisblueprint();
}
inline void AppMarker_SellOrder::clear_itemisblueprint() {
  itemisblueprint_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool AppMarker_SellOrder::_internal_itemisblueprint() const {
  return itemisblueprint_;
}
inline bool AppMarker_SellOrder::itemisblueprint() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.itemIsBlueprint)
  return _internal_itemisblueprint();
}
inline void AppMarker_SellOrder::_internal_set_itemisblueprint(bool m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  itemisblueprint_ = m_iValue;
}
inline void AppMarker_SellOrder::set_itemisblueprint(bool m_iValue) {
  _internal_set_itemisblueprint(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.itemIsBlueprint)
}

// required bool currencyIsBlueprint = 7;
inline bool AppMarker_SellOrder::_internal_has_currencyisblueprint() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_currencyisblueprint() const {
  return _internal_has_currencyisblueprint();
}
inline void AppMarker_SellOrder::clear_currencyisblueprint() {
  currencyisblueprint_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool AppMarker_SellOrder::_internal_currencyisblueprint() const {
  return currencyisblueprint_;
}
inline bool AppMarker_SellOrder::currencyisblueprint() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.currencyIsBlueprint)
  return _internal_currencyisblueprint();
}
inline void AppMarker_SellOrder::_internal_set_currencyisblueprint(bool m_iValue) {
  _has_bits_[0] |= 0x00000040u;
  currencyisblueprint_ = m_iValue;
}
inline void AppMarker_SellOrder::set_currencyisblueprint(bool m_iValue) {
  _internal_set_currencyisblueprint(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.currencyIsBlueprint)
}

// optional float itemCondition = 8;
inline bool AppMarker_SellOrder::_internal_has_itemcondition() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_itemcondition() const {
  return _internal_has_itemcondition();
}
inline void AppMarker_SellOrder::clear_itemcondition() {
  itemcondition_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float AppMarker_SellOrder::_internal_itemcondition() const {
  return itemcondition_;
}
inline float AppMarker_SellOrder::itemcondition() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.itemCondition)
  return _internal_itemcondition();
}
inline void AppMarker_SellOrder::_internal_set_itemcondition(float m_iValue) {
  _has_bits_[0] |= 0x00000080u;
  itemcondition_ = m_iValue;
}
inline void AppMarker_SellOrder::set_itemcondition(float m_iValue) {
  _internal_set_itemcondition(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.itemCondition)
}

// optional float itemConditionMax = 9;
inline bool AppMarker_SellOrder::_internal_has_itemconditionmax() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  return m_iValue;
}
inline bool AppMarker_SellOrder::has_itemconditionmax() const {
  return _internal_has_itemconditionmax();
}
inline void AppMarker_SellOrder::clear_itemconditionmax() {
  itemconditionmax_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float AppMarker_SellOrder::_internal_itemconditionmax() const {
  return itemconditionmax_;
}
inline float AppMarker_SellOrder::itemconditionmax() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.SellOrder.itemConditionMax)
  return _internal_itemconditionmax();
}
inline void AppMarker_SellOrder::_internal_set_itemconditionmax(float m_iValue) {
  _has_bits_[0] |= 0x00000100u;
  itemconditionmax_ = m_iValue;
}
inline void AppMarker_SellOrder::set_itemconditionmax(float m_iValue) {
  _internal_set_itemconditionmax(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.SellOrder.itemConditionMax)
}

// -------------------------------------------------------------------

// AppMarker

// required uint32 id = 1;
inline bool AppMarker::_internal_has_id() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_id() const {
  return _internal_has_id();
}
inline void AppMarker::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppMarker::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppMarker::id() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.id)
  return _internal_id();
}
inline void AppMarker::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  id_ = m_iValue;
}
inline void AppMarker::set_id(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_id(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.id)
}

// required .rustplus.AppMarkerType type = 2;
inline bool AppMarker::_internal_has_type() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_type() const {
  return _internal_has_type();
}
inline void AppMarker::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::rustplus::AppMarkerType AppMarker::_internal_type() const {
  return static_cast< ::rustplus::AppMarkerType >(type_);
}
inline ::rustplus::AppMarkerType AppMarker::type() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.type)
  return _internal_type();
}
inline void AppMarker::_internal_set_type(::rustplus::AppMarkerType m_iValue) {
  assert(::rustplus::AppMarkerType_IsValid(m_iValue));
  _has_bits_[0] |= 0x00000010u;
  type_ = m_iValue;
}
inline void AppMarker::set_type(::rustplus::AppMarkerType m_iValue) {
  _internal_set_type(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.type)
}

// required float x = 3;
inline bool AppMarker::_internal_has_x() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_x() const {
  return _internal_has_x();
}
inline void AppMarker::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float AppMarker::_internal_x() const {
  return x_;
}
inline float AppMarker::x() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.x)
  return _internal_x();
}
inline void AppMarker::_internal_set_x(float m_iValue) {
  _has_bits_[0] |= 0x00000020u;
  x_ = m_iValue;
}
inline void AppMarker::set_x(float m_iValue) {
  _internal_set_x(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.x)
}

// required float y = 4;
inline bool AppMarker::_internal_has_y() const {
  bool m_iValue = (_has_bits_[0] & 0x00000040u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_y() const {
  return _internal_has_y();
}
inline void AppMarker::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float AppMarker::_internal_y() const {
  return y_;
}
inline float AppMarker::y() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.y)
  return _internal_y();
}
inline void AppMarker::_internal_set_y(float m_iValue) {
  _has_bits_[0] |= 0x00000040u;
  y_ = m_iValue;
}
inline void AppMarker::set_y(float m_iValue) {
  _internal_set_y(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.y)
}

// optional uint64 steamId = 5;
inline bool AppMarker::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000080u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_steamid() const {
  return _internal_has_steamid();
}
inline void AppMarker::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppMarker::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppMarker::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.steamId)
  return _internal_steamid();
}
inline void AppMarker::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00000080u;
  steamid_ = m_iValue;
}
inline void AppMarker::set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.steamId)
}

// optional float rotation = 6;
inline bool AppMarker::_internal_has_rotation() const {
  bool m_iValue = (_has_bits_[0] & 0x00000100u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_rotation() const {
  return _internal_has_rotation();
}
inline void AppMarker::clear_rotation() {
  rotation_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float AppMarker::_internal_rotation() const {
  return rotation_;
}
inline float AppMarker::rotation() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.rotation)
  return _internal_rotation();
}
inline void AppMarker::_internal_set_rotation(float m_iValue) {
  _has_bits_[0] |= 0x00000100u;
  rotation_ = m_iValue;
}
inline void AppMarker::set_rotation(float m_iValue) {
  _internal_set_rotation(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.rotation)
}

// optional float radius = 7;
inline bool AppMarker::_internal_has_radius() const {
  bool m_iValue = (_has_bits_[0] & 0x00000200u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_radius() const {
  return _internal_has_radius();
}
inline void AppMarker::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float AppMarker::_internal_radius() const {
  return radius_;
}
inline float AppMarker::radius() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.radius)
  return _internal_radius();
}
inline void AppMarker::_internal_set_radius(float m_iValue) {
  _has_bits_[0] |= 0x00000200u;
  radius_ = m_iValue;
}
inline void AppMarker::set_radius(float m_iValue) {
  _internal_set_radius(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.radius)
}

// optional .rustplus.Vector4 color1 = 8;
inline bool AppMarker::_internal_has_color1() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || color1_ != nullptr);
  return m_iValue;
}
inline bool AppMarker::has_color1() const {
  return _internal_has_color1();
}
inline void AppMarker::clear_color1() {
  if (color1_ != nullptr) color1_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::Vector4& AppMarker::_internal_color1() const {
  const ::rustplus::Vector4* p = color1_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector4&>(
      ::rustplus::_Vector4_default_instance_);
}
inline const ::rustplus::Vector4& AppMarker::color1() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.color1)
  return _internal_color1();
}
inline void AppMarker::unsafe_arena_set_allocated_color1(
    ::rustplus::Vector4* color1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color1_);
  }
  color1_ = color1;
  if (color1) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppMarker.color1)
}
inline ::rustplus::Vector4* AppMarker::release_color1() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::Vector4* temp = color1_;
  color1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector4* AppMarker::unsafe_arena_release_color1() {
  // @@protoc_insertion_point(field_release:rustplus.AppMarker.color1)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::Vector4* temp = color1_;
  color1_ = nullptr;
  return temp;
}
inline ::rustplus::Vector4* AppMarker::_internal_mutable_color1() {
  _has_bits_[0] |= 0x00000002u;
  if (color1_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector4>(GetArenaForAllocation());
    color1_ = p;
  }
  return color1_;
}
inline ::rustplus::Vector4* AppMarker::mutable_color1() {
  ::rustplus::Vector4* _msg = _internal_mutable_color1();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMarker.color1)
  return _msg;
}
inline void AppMarker::set_allocated_color1(::rustplus::Vector4* color1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete color1_;
  }
  if (color1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector4>::GetOwningArena(color1);
    if (message_arena != submessage_arena) {
      color1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  color1_ = color1;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMarker.color1)
}

// optional .rustplus.Vector4 color2 = 9;
inline bool AppMarker::_internal_has_color2() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!m_iValue || color2_ != nullptr);
  return m_iValue;
}
inline bool AppMarker::has_color2() const {
  return _internal_has_color2();
}
inline void AppMarker::clear_color2() {
  if (color2_ != nullptr) color2_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rustplus::Vector4& AppMarker::_internal_color2() const {
  const ::rustplus::Vector4* p = color2_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector4&>(
      ::rustplus::_Vector4_default_instance_);
}
inline const ::rustplus::Vector4& AppMarker::color2() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.color2)
  return _internal_color2();
}
inline void AppMarker::unsafe_arena_set_allocated_color2(
    ::rustplus::Vector4* color2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color2_);
  }
  color2_ = color2;
  if (color2) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppMarker.color2)
}
inline ::rustplus::Vector4* AppMarker::release_color2() {
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::Vector4* temp = color2_;
  color2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector4* AppMarker::unsafe_arena_release_color2() {
  // @@protoc_insertion_point(field_release:rustplus.AppMarker.color2)
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::Vector4* temp = color2_;
  color2_ = nullptr;
  return temp;
}
inline ::rustplus::Vector4* AppMarker::_internal_mutable_color2() {
  _has_bits_[0] |= 0x00000004u;
  if (color2_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector4>(GetArenaForAllocation());
    color2_ = p;
  }
  return color2_;
}
inline ::rustplus::Vector4* AppMarker::mutable_color2() {
  ::rustplus::Vector4* _msg = _internal_mutable_color2();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMarker.color2)
  return _msg;
}
inline void AppMarker::set_allocated_color2(::rustplus::Vector4* color2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete color2_;
  }
  if (color2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector4>::GetOwningArena(color2);
    if (message_arena != submessage_arena) {
      color2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  color2_ = color2;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMarker.color2)
}

// optional float alpha = 10;
inline bool AppMarker::_internal_has_alpha() const {
  bool m_iValue = (_has_bits_[0] & 0x00000400u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_alpha() const {
  return _internal_has_alpha();
}
inline void AppMarker::clear_alpha() {
  alpha_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float AppMarker::_internal_alpha() const {
  return alpha_;
}
inline float AppMarker::alpha() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.alpha)
  return _internal_alpha();
}
inline void AppMarker::_internal_set_alpha(float m_iValue) {
  _has_bits_[0] |= 0x00000400u;
  alpha_ = m_iValue;
}
inline void AppMarker::set_alpha(float m_iValue) {
  _internal_set_alpha(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.alpha)
}

// optional string name = 11;
inline bool AppMarker::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_name() const {
  return _internal_has_name();
}
inline void AppMarker::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppMarker::name() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMarker::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.name)
}
inline std::string* AppMarker::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.AppMarker.name)
  return _s;
}
inline const std::string& AppMarker::_internal_name() const {
  return name_.Get();
}
inline void AppMarker::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppMarker::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppMarker::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.AppMarker.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppMarker::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppMarker.name)
}

// optional bool outOfStock = 12;
inline bool AppMarker::_internal_has_outofstock() const {
  bool m_iValue = (_has_bits_[0] & 0x00000800u) != 0;
  return m_iValue;
}
inline bool AppMarker::has_outofstock() const {
  return _internal_has_outofstock();
}
inline void AppMarker::clear_outofstock() {
  outofstock_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool AppMarker::_internal_outofstock() const {
  return outofstock_;
}
inline bool AppMarker::outofstock() const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.outOfStock)
  return _internal_outofstock();
}
inline void AppMarker::_internal_set_outofstock(bool m_iValue) {
  _has_bits_[0] |= 0x00000800u;
  outofstock_ = m_iValue;
}
inline void AppMarker::set_outofstock(bool m_iValue) {
  _internal_set_outofstock(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppMarker.outOfStock)
}

// repeated .rustplus.AppMarker.SellOrder sellOrders = 13;
inline int AppMarker::_internal_sellorders_size() const {
  return sellorders_.size();
}
inline int AppMarker::sellorders_size() const {
  return _internal_sellorders_size();
}
inline void AppMarker::clear_sellorders() {
  sellorders_.Clear();
}
inline ::rustplus::AppMarker_SellOrder* AppMarker::mutable_sellorders(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppMarker.sellOrders)
  return sellorders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker_SellOrder >*
AppMarker::mutable_sellorders() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppMarker.sellOrders)
  return &sellorders_;
}
inline const ::rustplus::AppMarker_SellOrder& AppMarker::_internal_sellorders(int index) const {
  return sellorders_.Get(index);
}
inline const ::rustplus::AppMarker_SellOrder& AppMarker::sellorders(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppMarker.sellOrders)
  return _internal_sellorders(index);
}
inline ::rustplus::AppMarker_SellOrder* AppMarker::_internal_add_sellorders() {
  return sellorders_.Add();
}
inline ::rustplus::AppMarker_SellOrder* AppMarker::add_sellorders() {
  ::rustplus::AppMarker_SellOrder* _add = _internal_add_sellorders();
  // @@protoc_insertion_point(field_add:rustplus.AppMarker.sellOrders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker_SellOrder >&
AppMarker::sellorders() const {
  // @@protoc_insertion_point(field_list:rustplus.AppMarker.sellOrders)
  return sellorders_;
}

// -------------------------------------------------------------------

// AppMapMarkers

// repeated .rustplus.AppMarker markers = 1;
inline int AppMapMarkers::_internal_markers_size() const {
  return markers_.size();
}
inline int AppMapMarkers::markers_size() const {
  return _internal_markers_size();
}
inline void AppMapMarkers::clear_markers() {
  markers_.Clear();
}
inline ::rustplus::AppMarker* AppMapMarkers::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppMapMarkers.markers)
  return markers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker >*
AppMapMarkers::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppMapMarkers.markers)
  return &markers_;
}
inline const ::rustplus::AppMarker& AppMapMarkers::_internal_markers(int index) const {
  return markers_.Get(index);
}
inline const ::rustplus::AppMarker& AppMapMarkers::markers(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppMapMarkers.markers)
  return _internal_markers(index);
}
inline ::rustplus::AppMarker* AppMapMarkers::_internal_add_markers() {
  return markers_.Add();
}
inline ::rustplus::AppMarker* AppMapMarkers::add_markers() {
  ::rustplus::AppMarker* _add = _internal_add_markers();
  // @@protoc_insertion_point(field_add:rustplus.AppMapMarkers.markers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppMarker >&
AppMapMarkers::markers() const {
  // @@protoc_insertion_point(field_list:rustplus.AppMapMarkers.markers)
  return markers_;
}

// -------------------------------------------------------------------

// AppClanInfo

// optional .rustplus.ClanInfo clanInfo = 1;
inline bool AppClanInfo::_internal_has_claninfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || claninfo_ != nullptr);
  return m_iValue;
}
inline bool AppClanInfo::has_claninfo() const {
  return _internal_has_claninfo();
}
inline void AppClanInfo::clear_claninfo() {
  if (claninfo_ != nullptr) claninfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::ClanInfo& AppClanInfo::_internal_claninfo() const {
  const ::rustplus::ClanInfo* p = claninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::ClanInfo&>(
      ::rustplus::_ClanInfo_default_instance_);
}
inline const ::rustplus::ClanInfo& AppClanInfo::claninfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanInfo.clanInfo)
  return _internal_claninfo();
}
inline void AppClanInfo::unsafe_arena_set_allocated_claninfo(
    ::rustplus::ClanInfo* claninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claninfo_);
  }
  claninfo_ = claninfo;
  if (claninfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppClanInfo.clanInfo)
}
inline ::rustplus::ClanInfo* AppClanInfo::release_claninfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::ClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::ClanInfo* AppClanInfo::unsafe_arena_release_claninfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppClanInfo.clanInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::ClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
  return temp;
}
inline ::rustplus::ClanInfo* AppClanInfo::_internal_mutable_claninfo() {
  _has_bits_[0] |= 0x00000001u;
  if (claninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::ClanInfo>(GetArenaForAllocation());
    claninfo_ = p;
  }
  return claninfo_;
}
inline ::rustplus::ClanInfo* AppClanInfo::mutable_claninfo() {
  ::rustplus::ClanInfo* _msg = _internal_mutable_claninfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppClanInfo.clanInfo)
  return _msg;
}
inline void AppClanInfo::set_allocated_claninfo(::rustplus::ClanInfo* claninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete claninfo_;
  }
  if (claninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::ClanInfo>::GetOwningArena(claninfo);
    if (message_arena != submessage_arena) {
      claninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  claninfo_ = claninfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppClanInfo.clanInfo)
}

// -------------------------------------------------------------------

// AppClanMessage

// required uint64 steamId = 1;
inline bool AppClanMessage::_internal_has_steamid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppClanMessage::has_steamid() const {
  return _internal_has_steamid();
}
inline void AppClanMessage::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppClanMessage::_internal_steamid() const {
  return steamid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppClanMessage::steamid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanMessage.steamId)
  return _internal_steamid();
}
inline void AppClanMessage::_internal_set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = m_iValue;
}
inline void AppClanMessage::set_steamid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_steamid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppClanMessage.steamId)
}

// required string name = 2;
inline bool AppClanMessage::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppClanMessage::has_name() const {
  return _internal_has_name();
}
inline void AppClanMessage::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppClanMessage::name() const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppClanMessage::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppClanMessage.name)
}
inline std::string* AppClanMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.AppClanMessage.name)
  return _s;
}
inline const std::string& AppClanMessage::_internal_name() const {
  return name_.Get();
}
inline void AppClanMessage::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppClanMessage::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppClanMessage::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.AppClanMessage.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppClanMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppClanMessage.name)
}

// required string message = 3;
inline bool AppClanMessage::_internal_has_message() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppClanMessage::has_message() const {
  return _internal_has_message();
}
inline void AppClanMessage::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppClanMessage::message() const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppClanMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppClanMessage.message)
}
inline std::string* AppClanMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rustplus.AppClanMessage.message)
  return _s;
}
inline const std::string& AppClanMessage::_internal_message() const {
  return message_.Get();
}
inline void AppClanMessage::_internal_set_message(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppClanMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppClanMessage::release_message() {
  // @@protoc_insertion_point(field_release:rustplus.AppClanMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppClanMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppClanMessage.message)
}

// required int64 time = 4;
inline bool AppClanMessage::_internal_has_time() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppClanMessage::has_time() const {
  return _internal_has_time();
}
inline void AppClanMessage::clear_time() {
  time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppClanMessage::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppClanMessage::time() const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanMessage.time)
  return _internal_time();
}
inline void AppClanMessage::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  time_ = m_iValue;
}
inline void AppClanMessage::set_time(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_time(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppClanMessage.time)
}

// -------------------------------------------------------------------

// AppClanChat

// repeated .rustplus.AppClanMessage messages = 1;
inline int AppClanChat::_internal_messages_size() const {
  return messages_.size();
}
inline int AppClanChat::messages_size() const {
  return _internal_messages_size();
}
inline void AppClanChat::clear_messages() {
  messages_.Clear();
}
inline ::rustplus::AppClanMessage* AppClanChat::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppClanChat.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppClanMessage >*
AppClanChat::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppClanChat.messages)
  return &messages_;
}
inline const ::rustplus::AppClanMessage& AppClanChat::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::rustplus::AppClanMessage& AppClanChat::messages(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanChat.messages)
  return _internal_messages(index);
}
inline ::rustplus::AppClanMessage* AppClanChat::_internal_add_messages() {
  return messages_.Add();
}
inline ::rustplus::AppClanMessage* AppClanChat::add_messages() {
  ::rustplus::AppClanMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:rustplus.AppClanChat.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppClanMessage >&
AppClanChat::messages() const {
  // @@protoc_insertion_point(field_list:rustplus.AppClanChat.messages)
  return messages_;
}

// -------------------------------------------------------------------

// AppNexusAuth

// required string serverId = 1;
inline bool AppNexusAuth::_internal_has_serverid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppNexusAuth::has_serverid() const {
  return _internal_has_serverid();
}
inline void AppNexusAuth::clear_serverid() {
  serverid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppNexusAuth::serverid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppNexusAuth.serverId)
  return _internal_serverid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppNexusAuth::set_serverid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serverid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppNexusAuth.serverId)
}
inline std::string* AppNexusAuth::mutable_serverid() {
  std::string* _s = _internal_mutable_serverid();
  // @@protoc_insertion_point(field_mutable:rustplus.AppNexusAuth.serverId)
  return _s;
}
inline const std::string& AppNexusAuth::_internal_serverid() const {
  return serverid_.Get();
}
inline void AppNexusAuth::_internal_set_serverid(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  serverid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppNexusAuth::_internal_mutable_serverid() {
  _has_bits_[0] |= 0x00000001u;
  return serverid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppNexusAuth::release_serverid() {
  // @@protoc_insertion_point(field_release:rustplus.AppNexusAuth.serverId)
  if (!_internal_has_serverid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serverid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppNexusAuth::set_allocated_serverid(std::string* serverid) {
  if (serverid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serverid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppNexusAuth.serverId)
}

// required int32 playerToken = 2;
inline bool AppNexusAuth::_internal_has_playertoken() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppNexusAuth::has_playertoken() const {
  return _internal_has_playertoken();
}
inline void AppNexusAuth::clear_playertoken() {
  playertoken_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppNexusAuth::_internal_playertoken() const {
  return playertoken_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppNexusAuth::playertoken() const {
  // @@protoc_insertion_point(field_get:rustplus.AppNexusAuth.playerToken)
  return _internal_playertoken();
}
inline void AppNexusAuth::_internal_set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  playertoken_ = m_iValue;
}
inline void AppNexusAuth::set_playertoken(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_playertoken(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppNexusAuth.playerToken)
}

// -------------------------------------------------------------------

// AppTeamChanged

// required uint64 playerId = 1;
inline bool AppTeamChanged::_internal_has_playerid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppTeamChanged::has_playerid() const {
  return _internal_has_playerid();
}
inline void AppTeamChanged::clear_playerid() {
  playerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamChanged::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppTeamChanged::playerid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamChanged.playerId)
  return _internal_playerid();
}
inline void AppTeamChanged::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = m_iValue;
}
inline void AppTeamChanged::set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 m_iValue) {
  _internal_set_playerid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppTeamChanged.playerId)
}

// required .rustplus.AppTeamInfo teamInfo = 2;
inline bool AppTeamChanged::_internal_has_teaminfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || teaminfo_ != nullptr);
  return m_iValue;
}
inline bool AppTeamChanged::has_teaminfo() const {
  return _internal_has_teaminfo();
}
inline void AppTeamChanged::clear_teaminfo() {
  if (teaminfo_ != nullptr) teaminfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppTeamInfo& AppTeamChanged::_internal_teaminfo() const {
  const ::rustplus::AppTeamInfo* p = teaminfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppTeamInfo&>(
      ::rustplus::_AppTeamInfo_default_instance_);
}
inline const ::rustplus::AppTeamInfo& AppTeamChanged::teaminfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppTeamChanged.teamInfo)
  return _internal_teaminfo();
}
inline void AppTeamChanged::unsafe_arena_set_allocated_teaminfo(
    ::rustplus::AppTeamInfo* teaminfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(teaminfo_);
  }
  teaminfo_ = teaminfo;
  if (teaminfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppTeamChanged.teamInfo)
}
inline ::rustplus::AppTeamInfo* AppTeamChanged::release_teaminfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppTeamInfo* temp = teaminfo_;
  teaminfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppTeamInfo* AppTeamChanged::unsafe_arena_release_teaminfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppTeamChanged.teamInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppTeamInfo* temp = teaminfo_;
  teaminfo_ = nullptr;
  return temp;
}
inline ::rustplus::AppTeamInfo* AppTeamChanged::_internal_mutable_teaminfo() {
  _has_bits_[0] |= 0x00000001u;
  if (teaminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppTeamInfo>(GetArenaForAllocation());
    teaminfo_ = p;
  }
  return teaminfo_;
}
inline ::rustplus::AppTeamInfo* AppTeamChanged::mutable_teaminfo() {
  ::rustplus::AppTeamInfo* _msg = _internal_mutable_teaminfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppTeamChanged.teamInfo)
  return _msg;
}
inline void AppTeamChanged::set_allocated_teaminfo(::rustplus::AppTeamInfo* teaminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete teaminfo_;
  }
  if (teaminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppTeamInfo>::GetOwningArena(teaminfo);
    if (message_arena != submessage_arena) {
      teaminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teaminfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  teaminfo_ = teaminfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppTeamChanged.teamInfo)
}

// -------------------------------------------------------------------

// AppNewTeamMessage

// required .rustplus.AppTeamMessage message = 1;
inline bool AppNewTeamMessage::_internal_has_message() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || message_ != nullptr);
  return m_iValue;
}
inline bool AppNewTeamMessage::has_message() const {
  return _internal_has_message();
}
inline void AppNewTeamMessage::clear_message() {
  if (message_ != nullptr) message_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppTeamMessage& AppNewTeamMessage::_internal_message() const {
  const ::rustplus::AppTeamMessage* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppTeamMessage&>(
      ::rustplus::_AppTeamMessage_default_instance_);
}
inline const ::rustplus::AppTeamMessage& AppNewTeamMessage::message() const {
  // @@protoc_insertion_point(field_get:rustplus.AppNewTeamMessage.message)
  return _internal_message();
}
inline void AppNewTeamMessage::unsafe_arena_set_allocated_message(
    ::rustplus::AppTeamMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppNewTeamMessage.message)
}
inline ::rustplus::AppTeamMessage* AppNewTeamMessage::release_message() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppTeamMessage* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppTeamMessage* AppNewTeamMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:rustplus.AppNewTeamMessage.message)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppTeamMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::rustplus::AppTeamMessage* AppNewTeamMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppTeamMessage>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::rustplus::AppTeamMessage* AppNewTeamMessage::mutable_message() {
  ::rustplus::AppTeamMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rustplus.AppNewTeamMessage.message)
  return _msg;
}
inline void AppNewTeamMessage::set_allocated_message(::rustplus::AppTeamMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppTeamMessage>::GetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppNewTeamMessage.message)
}

// -------------------------------------------------------------------

// AppEntityChanged

// required uint32 entityId = 1;
inline bool AppEntityChanged::_internal_has_entityid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppEntityChanged::has_entityid() const {
  return _internal_has_entityid();
}
inline void AppEntityChanged::clear_entityid() {
  entityid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppEntityChanged::_internal_entityid() const {
  return entityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppEntityChanged::entityid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityChanged.entityId)
  return _internal_entityid();
}
inline void AppEntityChanged::_internal_set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  entityid_ = m_iValue;
}
inline void AppEntityChanged::set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_entityid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppEntityChanged.entityId)
}

// required .rustplus.AppEntityPayload payload = 2;
inline bool AppEntityChanged::_internal_has_payload() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || payload_ != nullptr);
  return m_iValue;
}
inline bool AppEntityChanged::has_payload() const {
  return _internal_has_payload();
}
inline void AppEntityChanged::clear_payload() {
  if (payload_ != nullptr) payload_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppEntityPayload& AppEntityChanged::_internal_payload() const {
  const ::rustplus::AppEntityPayload* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppEntityPayload&>(
      ::rustplus::_AppEntityPayload_default_instance_);
}
inline const ::rustplus::AppEntityPayload& AppEntityChanged::payload() const {
  // @@protoc_insertion_point(field_get:rustplus.AppEntityChanged.payload)
  return _internal_payload();
}
inline void AppEntityChanged::unsafe_arena_set_allocated_payload(
    ::rustplus::AppEntityPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppEntityChanged.payload)
}
inline ::rustplus::AppEntityPayload* AppEntityChanged::release_payload() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppEntityPayload* temp = payload_;
  payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppEntityPayload* AppEntityChanged::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:rustplus.AppEntityChanged.payload)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppEntityPayload* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::rustplus::AppEntityPayload* AppEntityChanged::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppEntityPayload>(GetArenaForAllocation());
    payload_ = p;
  }
  return payload_;
}
inline ::rustplus::AppEntityPayload* AppEntityChanged::mutable_payload() {
  ::rustplus::AppEntityPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:rustplus.AppEntityChanged.payload)
  return _msg;
}
inline void AppEntityChanged::set_allocated_payload(::rustplus::AppEntityPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppEntityPayload>::GetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppEntityChanged.payload)
}

// -------------------------------------------------------------------

// AppClanChanged

// optional .rustplus.ClanInfo clanInfo = 1;
inline bool AppClanChanged::_internal_has_claninfo() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || claninfo_ != nullptr);
  return m_iValue;
}
inline bool AppClanChanged::has_claninfo() const {
  return _internal_has_claninfo();
}
inline void AppClanChanged::clear_claninfo() {
  if (claninfo_ != nullptr) claninfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::ClanInfo& AppClanChanged::_internal_claninfo() const {
  const ::rustplus::ClanInfo* p = claninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::ClanInfo&>(
      ::rustplus::_ClanInfo_default_instance_);
}
inline const ::rustplus::ClanInfo& AppClanChanged::claninfo() const {
  // @@protoc_insertion_point(field_get:rustplus.AppClanChanged.clanInfo)
  return _internal_claninfo();
}
inline void AppClanChanged::unsafe_arena_set_allocated_claninfo(
    ::rustplus::ClanInfo* claninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claninfo_);
  }
  claninfo_ = claninfo;
  if (claninfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppClanChanged.clanInfo)
}
inline ::rustplus::ClanInfo* AppClanChanged::release_claninfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::ClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::ClanInfo* AppClanChanged::unsafe_arena_release_claninfo() {
  // @@protoc_insertion_point(field_release:rustplus.AppClanChanged.clanInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::ClanInfo* temp = claninfo_;
  claninfo_ = nullptr;
  return temp;
}
inline ::rustplus::ClanInfo* AppClanChanged::_internal_mutable_claninfo() {
  _has_bits_[0] |= 0x00000001u;
  if (claninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::ClanInfo>(GetArenaForAllocation());
    claninfo_ = p;
  }
  return claninfo_;
}
inline ::rustplus::ClanInfo* AppClanChanged::mutable_claninfo() {
  ::rustplus::ClanInfo* _msg = _internal_mutable_claninfo();
  // @@protoc_insertion_point(field_mutable:rustplus.AppClanChanged.clanInfo)
  return _msg;
}
inline void AppClanChanged::set_allocated_claninfo(::rustplus::ClanInfo* claninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete claninfo_;
  }
  if (claninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::ClanInfo>::GetOwningArena(claninfo);
    if (message_arena != submessage_arena) {
      claninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  claninfo_ = claninfo;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppClanChanged.clanInfo)
}

// -------------------------------------------------------------------

// AppNewClanMessage

// required int64 clanId = 1;
inline bool AppNewClanMessage::_internal_has_clanid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppNewClanMessage::has_clanid() const {
  return _internal_has_clanid();
}
inline void AppNewClanMessage::clear_clanid() {
  clanid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppNewClanMessage::_internal_clanid() const {
  return clanid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AppNewClanMessage::clanid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppNewClanMessage.clanId)
  return _internal_clanid();
}
inline void AppNewClanMessage::_internal_set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  clanid_ = m_iValue;
}
inline void AppNewClanMessage::set_clanid(::PROTOBUF_NAMESPACE_ID::int64 m_iValue) {
  _internal_set_clanid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppNewClanMessage.clanId)
}

// required .rustplus.AppClanMessage message = 2;
inline bool AppNewClanMessage::_internal_has_message() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || message_ != nullptr);
  return m_iValue;
}
inline bool AppNewClanMessage::has_message() const {
  return _internal_has_message();
}
inline void AppNewClanMessage::clear_message() {
  if (message_ != nullptr) message_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::AppClanMessage& AppNewClanMessage::_internal_message() const {
  const ::rustplus::AppClanMessage* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::AppClanMessage&>(
      ::rustplus::_AppClanMessage_default_instance_);
}
inline const ::rustplus::AppClanMessage& AppNewClanMessage::message() const {
  // @@protoc_insertion_point(field_get:rustplus.AppNewClanMessage.message)
  return _internal_message();
}
inline void AppNewClanMessage::unsafe_arena_set_allocated_message(
    ::rustplus::AppClanMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppNewClanMessage.message)
}
inline ::rustplus::AppClanMessage* AppNewClanMessage::release_message() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppClanMessage* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::AppClanMessage* AppNewClanMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:rustplus.AppNewClanMessage.message)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::AppClanMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::rustplus::AppClanMessage* AppNewClanMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::AppClanMessage>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::rustplus::AppClanMessage* AppNewClanMessage::mutable_message() {
  ::rustplus::AppClanMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:rustplus.AppNewClanMessage.message)
  return _msg;
}
inline void AppNewClanMessage::set_allocated_message(::rustplus::AppClanMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::AppClanMessage>::GetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppNewClanMessage.message)
}

// -------------------------------------------------------------------

// AppCameraSubscribe

// required string cameraId = 1;
inline bool AppCameraSubscribe::_internal_has_cameraid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppCameraSubscribe::has_cameraid() const {
  return _internal_has_cameraid();
}
inline void AppCameraSubscribe::clear_cameraid() {
  cameraid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppCameraSubscribe::cameraid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraSubscribe.cameraId)
  return _internal_cameraid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppCameraSubscribe::set_cameraid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cameraid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppCameraSubscribe.cameraId)
}
inline std::string* AppCameraSubscribe::mutable_cameraid() {
  std::string* _s = _internal_mutable_cameraid();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraSubscribe.cameraId)
  return _s;
}
inline const std::string& AppCameraSubscribe::_internal_cameraid() const {
  return cameraid_.Get();
}
inline void AppCameraSubscribe::_internal_set_cameraid(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  cameraid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppCameraSubscribe::_internal_mutable_cameraid() {
  _has_bits_[0] |= 0x00000001u;
  return cameraid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppCameraSubscribe::release_cameraid() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraSubscribe.cameraId)
  if (!_internal_has_cameraid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cameraid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppCameraSubscribe::set_allocated_cameraid(std::string* cameraid) {
  if (cameraid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cameraid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cameraid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraSubscribe.cameraId)
}

// -------------------------------------------------------------------

// AppCameraInput

// required int32 buttons = 1;
inline bool AppCameraInput::_internal_has_buttons() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppCameraInput::has_buttons() const {
  return _internal_has_buttons();
}
inline void AppCameraInput::clear_buttons() {
  buttons_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInput::_internal_buttons() const {
  return buttons_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInput::buttons() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInput.buttons)
  return _internal_buttons();
}
inline void AppCameraInput::_internal_set_buttons(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  buttons_ = m_iValue;
}
inline void AppCameraInput::set_buttons(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_buttons(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraInput.buttons)
}

// required .rustplus.Vector2 mouseDelta = 2;
inline bool AppCameraInput::_internal_has_mousedelta() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!m_iValue || mousedelta_ != nullptr);
  return m_iValue;
}
inline bool AppCameraInput::has_mousedelta() const {
  return _internal_has_mousedelta();
}
inline void AppCameraInput::clear_mousedelta() {
  if (mousedelta_ != nullptr) mousedelta_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rustplus::Vector2& AppCameraInput::_internal_mousedelta() const {
  const ::rustplus::Vector2* p = mousedelta_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector2&>(
      ::rustplus::_Vector2_default_instance_);
}
inline const ::rustplus::Vector2& AppCameraInput::mousedelta() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInput.mouseDelta)
  return _internal_mousedelta();
}
inline void AppCameraInput::unsafe_arena_set_allocated_mousedelta(
    ::rustplus::Vector2* mousedelta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mousedelta_);
  }
  mousedelta_ = mousedelta;
  if (mousedelta) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppCameraInput.mouseDelta)
}
inline ::rustplus::Vector2* AppCameraInput::release_mousedelta() {
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::Vector2* temp = mousedelta_;
  mousedelta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector2* AppCameraInput::unsafe_arena_release_mousedelta() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraInput.mouseDelta)
  _has_bits_[0] &= ~0x00000001u;
  ::rustplus::Vector2* temp = mousedelta_;
  mousedelta_ = nullptr;
  return temp;
}
inline ::rustplus::Vector2* AppCameraInput::_internal_mutable_mousedelta() {
  _has_bits_[0] |= 0x00000001u;
  if (mousedelta_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector2>(GetArenaForAllocation());
    mousedelta_ = p;
  }
  return mousedelta_;
}
inline ::rustplus::Vector2* AppCameraInput::mutable_mousedelta() {
  ::rustplus::Vector2* _msg = _internal_mutable_mousedelta();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraInput.mouseDelta)
  return _msg;
}
inline void AppCameraInput::set_allocated_mousedelta(::rustplus::Vector2* mousedelta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mousedelta_;
  }
  if (mousedelta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector2>::GetOwningArena(mousedelta);
    if (message_arena != submessage_arena) {
      mousedelta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mousedelta, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mousedelta_ = mousedelta;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraInput.mouseDelta)
}

// -------------------------------------------------------------------

// AppCameraInfo

// required int32 width = 1;
inline bool AppCameraInfo::_internal_has_width() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppCameraInfo::has_width() const {
  return _internal_has_width();
}
inline void AppCameraInfo::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInfo::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInfo::width() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInfo.width)
  return _internal_width();
}
inline void AppCameraInfo::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  width_ = m_iValue;
}
inline void AppCameraInfo::set_width(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_width(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraInfo.width)
}

// required int32 height = 2;
inline bool AppCameraInfo::_internal_has_height() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppCameraInfo::has_height() const {
  return _internal_has_height();
}
inline void AppCameraInfo::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInfo::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInfo::height() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInfo.height)
  return _internal_height();
}
inline void AppCameraInfo::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  height_ = m_iValue;
}
inline void AppCameraInfo::set_height(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_height(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraInfo.height)
}

// required float nearPlane = 3;
inline bool AppCameraInfo::_internal_has_nearplane() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppCameraInfo::has_nearplane() const {
  return _internal_has_nearplane();
}
inline void AppCameraInfo::clear_nearplane() {
  nearplane_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AppCameraInfo::_internal_nearplane() const {
  return nearplane_;
}
inline float AppCameraInfo::nearplane() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInfo.nearPlane)
  return _internal_nearplane();
}
inline void AppCameraInfo::_internal_set_nearplane(float m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  nearplane_ = m_iValue;
}
inline void AppCameraInfo::set_nearplane(float m_iValue) {
  _internal_set_nearplane(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraInfo.nearPlane)
}

// required float farPlane = 4;
inline bool AppCameraInfo::_internal_has_farplane() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppCameraInfo::has_farplane() const {
  return _internal_has_farplane();
}
inline void AppCameraInfo::clear_farplane() {
  farplane_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float AppCameraInfo::_internal_farplane() const {
  return farplane_;
}
inline float AppCameraInfo::farplane() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInfo.farPlane)
  return _internal_farplane();
}
inline void AppCameraInfo::_internal_set_farplane(float m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  farplane_ = m_iValue;
}
inline void AppCameraInfo::set_farplane(float m_iValue) {
  _internal_set_farplane(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraInfo.farPlane)
}

// required int32 controlFlags = 5;
inline bool AppCameraInfo::_internal_has_controlflags() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppCameraInfo::has_controlflags() const {
  return _internal_has_controlflags();
}
inline void AppCameraInfo::clear_controlflags() {
  controlflags_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInfo::_internal_controlflags() const {
  return controlflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraInfo::controlflags() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraInfo.controlFlags)
  return _internal_controlflags();
}
inline void AppCameraInfo::_internal_set_controlflags(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  controlflags_ = m_iValue;
}
inline void AppCameraInfo::set_controlflags(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_controlflags(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraInfo.controlFlags)
}

// -------------------------------------------------------------------

// AppCameraRays_Entity

// required uint32 entityId = 1;
inline bool AppCameraRays_Entity::_internal_has_entityid() const {
  bool m_iValue = (_has_bits_[0] & 0x00000010u) != 0;
  return m_iValue;
}
inline bool AppCameraRays_Entity::has_entityid() const {
  return _internal_has_entityid();
}
inline void AppCameraRays_Entity::clear_entityid() {
  entityid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppCameraRays_Entity::_internal_entityid() const {
  return entityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppCameraRays_Entity::entityid() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.Entity.entityId)
  return _internal_entityid();
}
inline void AppCameraRays_Entity::_internal_set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _has_bits_[0] |= 0x00000010u;
  entityid_ = m_iValue;
}
inline void AppCameraRays_Entity::set_entityid(::PROTOBUF_NAMESPACE_ID::uint32 m_iValue) {
  _internal_set_entityid(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.Entity.entityId)
}

// required .rustplus.AppCameraRays.EntityType type = 2;
inline bool AppCameraRays_Entity::_internal_has_type() const {
  bool m_iValue = (_has_bits_[0] & 0x00000020u) != 0;
  return m_iValue;
}
inline bool AppCameraRays_Entity::has_type() const {
  return _internal_has_type();
}
inline void AppCameraRays_Entity::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::rustplus::AppCameraRays_EntityType AppCameraRays_Entity::_internal_type() const {
  return static_cast< ::rustplus::AppCameraRays_EntityType >(type_);
}
inline ::rustplus::AppCameraRays_EntityType AppCameraRays_Entity::type() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.Entity.type)
  return _internal_type();
}
inline void AppCameraRays_Entity::_internal_set_type(::rustplus::AppCameraRays_EntityType m_iValue) {
  assert(::rustplus::AppCameraRays_EntityType_IsValid(m_iValue));
  _has_bits_[0] |= 0x00000020u;
  type_ = m_iValue;
}
inline void AppCameraRays_Entity::set_type(::rustplus::AppCameraRays_EntityType m_iValue) {
  _internal_set_type(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.Entity.type)
}

// required .rustplus.Vector3 position = 3;
inline bool AppCameraRays_Entity::_internal_has_position() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!m_iValue || position_ != nullptr);
  return m_iValue;
}
inline bool AppCameraRays_Entity::has_position() const {
  return _internal_has_position();
}
inline void AppCameraRays_Entity::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rustplus::Vector3& AppCameraRays_Entity::_internal_position() const {
  const ::rustplus::Vector3* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector3&>(
      ::rustplus::_Vector3_default_instance_);
}
inline const ::rustplus::Vector3& AppCameraRays_Entity::position() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.Entity.position)
  return _internal_position();
}
inline void AppCameraRays_Entity::unsafe_arena_set_allocated_position(
    ::rustplus::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppCameraRays.Entity.position)
}
inline ::rustplus::Vector3* AppCameraRays_Entity::release_position() {
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::Vector3* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraRays.Entity.position)
  _has_bits_[0] &= ~0x00000002u;
  ::rustplus::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000002u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector3>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::mutable_position() {
  ::rustplus::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraRays.Entity.position)
  return _msg;
}
inline void AppCameraRays_Entity::set_allocated_position(::rustplus::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector3>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraRays.Entity.position)
}

// required .rustplus.Vector3 rotation = 4;
inline bool AppCameraRays_Entity::_internal_has_rotation() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!m_iValue || rotation_ != nullptr);
  return m_iValue;
}
inline bool AppCameraRays_Entity::has_rotation() const {
  return _internal_has_rotation();
}
inline void AppCameraRays_Entity::clear_rotation() {
  if (rotation_ != nullptr) rotation_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rustplus::Vector3& AppCameraRays_Entity::_internal_rotation() const {
  const ::rustplus::Vector3* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector3&>(
      ::rustplus::_Vector3_default_instance_);
}
inline const ::rustplus::Vector3& AppCameraRays_Entity::rotation() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.Entity.rotation)
  return _internal_rotation();
}
inline void AppCameraRays_Entity::unsafe_arena_set_allocated_rotation(
    ::rustplus::Vector3* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppCameraRays.Entity.rotation)
}
inline ::rustplus::Vector3* AppCameraRays_Entity::release_rotation() {
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::Vector3* temp = rotation_;
  rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraRays.Entity.rotation)
  _has_bits_[0] &= ~0x00000004u;
  ::rustplus::Vector3* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::_internal_mutable_rotation() {
  _has_bits_[0] |= 0x00000004u;
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector3>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::mutable_rotation() {
  ::rustplus::Vector3* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraRays.Entity.rotation)
  return _msg;
}
inline void AppCameraRays_Entity::set_allocated_rotation(::rustplus::Vector3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector3>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraRays.Entity.rotation)
}

// required .rustplus.Vector3 size = 5;
inline bool AppCameraRays_Entity::_internal_has_size() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!m_iValue || size_ != nullptr);
  return m_iValue;
}
inline bool AppCameraRays_Entity::has_size() const {
  return _internal_has_size();
}
inline void AppCameraRays_Entity::clear_size() {
  if (size_ != nullptr) size_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::rustplus::Vector3& AppCameraRays_Entity::_internal_size() const {
  const ::rustplus::Vector3* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::rustplus::Vector3&>(
      ::rustplus::_Vector3_default_instance_);
}
inline const ::rustplus::Vector3& AppCameraRays_Entity::size() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.Entity.size)
  return _internal_size();
}
inline void AppCameraRays_Entity::unsafe_arena_set_allocated_size(
    ::rustplus::Vector3* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rustplus.AppCameraRays.Entity.size)
}
inline ::rustplus::Vector3* AppCameraRays_Entity::release_size() {
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::Vector3* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraRays.Entity.size)
  _has_bits_[0] &= ~0x00000008u;
  ::rustplus::Vector3* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::_internal_mutable_size() {
  _has_bits_[0] |= 0x00000008u;
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::rustplus::Vector3>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::rustplus::Vector3* AppCameraRays_Entity::mutable_size() {
  ::rustplus::Vector3* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraRays.Entity.size)
  return _msg;
}
inline void AppCameraRays_Entity::set_allocated_size(::rustplus::Vector3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rustplus::Vector3>::GetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraRays.Entity.size)
}

// optional string name = 6;
inline bool AppCameraRays_Entity::_internal_has_name() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppCameraRays_Entity::has_name() const {
  return _internal_has_name();
}
inline void AppCameraRays_Entity::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppCameraRays_Entity::name() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.Entity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppCameraRays_Entity::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.Entity.name)
}
inline std::string* AppCameraRays_Entity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraRays.Entity.name)
  return _s;
}
inline const std::string& AppCameraRays_Entity::_internal_name() const {
  return name_.Get();
}
inline void AppCameraRays_Entity::_internal_set_name(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppCameraRays_Entity::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppCameraRays_Entity::release_name() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraRays.Entity.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppCameraRays_Entity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraRays.Entity.name)
}

// -------------------------------------------------------------------

// AppCameraRays

// required float verticalFov = 1;
inline bool AppCameraRays::_internal_has_verticalfov() const {
  bool m_iValue = (_has_bits_[0] & 0x00000002u) != 0;
  return m_iValue;
}
inline bool AppCameraRays::has_verticalfov() const {
  return _internal_has_verticalfov();
}
inline void AppCameraRays::clear_verticalfov() {
  verticalfov_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AppCameraRays::_internal_verticalfov() const {
  return verticalfov_;
}
inline float AppCameraRays::verticalfov() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.verticalFov)
  return _internal_verticalfov();
}
inline void AppCameraRays::_internal_set_verticalfov(float m_iValue) {
  _has_bits_[0] |= 0x00000002u;
  verticalfov_ = m_iValue;
}
inline void AppCameraRays::set_verticalfov(float m_iValue) {
  _internal_set_verticalfov(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.verticalFov)
}

// required int32 sampleOffset = 2;
inline bool AppCameraRays::_internal_has_sampleoffset() const {
  bool m_iValue = (_has_bits_[0] & 0x00000004u) != 0;
  return m_iValue;
}
inline bool AppCameraRays::has_sampleoffset() const {
  return _internal_has_sampleoffset();
}
inline void AppCameraRays::clear_sampleoffset() {
  sampleoffset_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraRays::_internal_sampleoffset() const {
  return sampleoffset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AppCameraRays::sampleoffset() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.sampleOffset)
  return _internal_sampleoffset();
}
inline void AppCameraRays::_internal_set_sampleoffset(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _has_bits_[0] |= 0x00000004u;
  sampleoffset_ = m_iValue;
}
inline void AppCameraRays::set_sampleoffset(::PROTOBUF_NAMESPACE_ID::int32 m_iValue) {
  _internal_set_sampleoffset(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.sampleOffset)
}

// required bytes rayData = 3;
inline bool AppCameraRays::_internal_has_raydata() const {
  bool m_iValue = (_has_bits_[0] & 0x00000001u) != 0;
  return m_iValue;
}
inline bool AppCameraRays::has_raydata() const {
  return _internal_has_raydata();
}
inline void AppCameraRays::clear_raydata() {
  raydata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppCameraRays::raydata() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.rayData)
  return _internal_raydata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppCameraRays::set_raydata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 raydata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.rayData)
}
inline std::string* AppCameraRays::mutable_raydata() {
  std::string* _s = _internal_mutable_raydata();
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraRays.rayData)
  return _s;
}
inline const std::string& AppCameraRays::_internal_raydata() const {
  return raydata_.Get();
}
inline void AppCameraRays::_internal_set_raydata(const std::string& m_iValue) {
  _has_bits_[0] |= 0x00000001u;
  raydata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, m_iValue, GetArenaForAllocation());
}
inline std::string* AppCameraRays::_internal_mutable_raydata() {
  _has_bits_[0] |= 0x00000001u;
  return raydata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppCameraRays::release_raydata() {
  // @@protoc_insertion_point(field_release:rustplus.AppCameraRays.rayData)
  if (!_internal_has_raydata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return raydata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppCameraRays::set_allocated_raydata(std::string* raydata) {
  if (raydata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  raydata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raydata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rustplus.AppCameraRays.rayData)
}

// required float distance = 4;
inline bool AppCameraRays::_internal_has_distance() const {
  bool m_iValue = (_has_bits_[0] & 0x00000008u) != 0;
  return m_iValue;
}
inline bool AppCameraRays::has_distance() const {
  return _internal_has_distance();
}
inline void AppCameraRays::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float AppCameraRays::_internal_distance() const {
  return distance_;
}
inline float AppCameraRays::distance() const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.distance)
  return _internal_distance();
}
inline void AppCameraRays::_internal_set_distance(float m_iValue) {
  _has_bits_[0] |= 0x00000008u;
  distance_ = m_iValue;
}
inline void AppCameraRays::set_distance(float m_iValue) {
  _internal_set_distance(m_iValue);
  // @@protoc_insertion_point(field_set:rustplus.AppCameraRays.distance)
}

// repeated .rustplus.AppCameraRays.Entity entities = 5;
inline int AppCameraRays::_internal_entities_size() const {
  return entities_.size();
}
inline int AppCameraRays::entities_size() const {
  return _internal_entities_size();
}
inline void AppCameraRays::clear_entities() {
  entities_.Clear();
}
inline ::rustplus::AppCameraRays_Entity* AppCameraRays::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:rustplus.AppCameraRays.entities)
  return entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppCameraRays_Entity >*
AppCameraRays::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:rustplus.AppCameraRays.entities)
  return &entities_;
}
inline const ::rustplus::AppCameraRays_Entity& AppCameraRays::_internal_entities(int index) const {
  return entities_.Get(index);
}
inline const ::rustplus::AppCameraRays_Entity& AppCameraRays::entities(int index) const {
  // @@protoc_insertion_point(field_get:rustplus.AppCameraRays.entities)
  return _internal_entities(index);
}
inline ::rustplus::AppCameraRays_Entity* AppCameraRays::_internal_add_entities() {
  return entities_.Add();
}
inline ::rustplus::AppCameraRays_Entity* AppCameraRays::add_entities() {
  ::rustplus::AppCameraRays_Entity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:rustplus.AppCameraRays.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rustplus::AppCameraRays_Entity >&
AppCameraRays::entities() const {
  // @@protoc_insertion_point(field_list:rustplus.AppCameraRays.entities)
  return entities_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rustplus

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rustplus::AppCameraRays_EntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rustplus::AppCameraRays_EntityType>() {
  return ::rustplus::AppCameraRays_EntityType_descriptor();
}
template <> struct is_proto_enum< ::rustplus::AppEntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rustplus::AppEntityType>() {
  return ::rustplus::AppEntityType_descriptor();
}
template <> struct is_proto_enum< ::rustplus::AppMarkerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rustplus::AppMarkerType>() {
  return ::rustplus::AppMarkerType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rustplus_2eproto
